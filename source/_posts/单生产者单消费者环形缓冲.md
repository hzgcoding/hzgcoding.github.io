
---
title: 单生产者单消费者环形缓冲
date: 2020-01-23 15:12:50
tags:
---

头文件
```c++
#ifndef _SIMPLE_LOOP_BUFFER_H__
#define _SIMPLE_LOOP_BUFFER_H__

#include "gntype.h"
#include "gnmutex.h"
#include "gnlock.h"
#include "server_define.h"
using namespace Storm;

typedef struct _tagBlock
{
    _tagBlock() 
    {
        memset(pBuffer, 0, sizeof(char)*(MAX_CACHE_PACKET_SIZE + 1));
    }
    ~_tagBlock() {};

    char  pBuffer[MAX_CACHE_PACKET_SIZE + 1]; 
    char* GetBuff() { return pBuffer; }
    int32 GetBuffLen() { return MAX_CACHE_PACKET_SIZE + 1; }
}CBlock;

class CSimpleLoopBufferEx
{
public:
    CSimpleLoopBufferEx();
    ~CSimpleLoopBufferEx();

    void Clear();

    /**
    * @brief
    * 初始化循环缓冲区
    * @param nSize : 初始化虚幻缓冲区的大小，实际大小为nSize+1
    * @return 成功返回true，失败返回false
    */
    bool Init();

    /**
    * @brief
    * 将需要存储的Buffer拷贝到循环缓冲区的结尾
    * @param pData : [输入参数]指向需要插入循环缓冲区的Buffer起始位置
    * @param nLen : 指向需要插入的Buffer的长度
    * @return 如果循环缓冲区拥有的大小大于等于nLen，返回true，否则返回false
    * @remark 此函数不是线程安全的
    */
    INT32 PushBack(const CHAR *pData, INT32 nLen);

    /**
    * @brief
    * 从循环缓冲区的起始位置取nLen长度的Buffer，拷贝放入Buffer中
    * @param pBuf : [输入输出参数]获取数据的Buffer的起始指针
    * @param nLen : 需要读出的Buffer长度
    * @return 如果有足够所需读出的数据，返回true，否则返回false
    * @remark 此函数不是线程安全的
    */
    INT32 PopFront(CHAR * &pBuf, INT32 nLen,CHAR* szData);

    /**
    * @brief
    * 丢弃nLen长度的数据
    * @param nLen : 需要丢弃的长度
    * @return void
    * @remark 此函数不是线程安全的
    */
    bool DiscardFront(INT32 nLen);

    /**
    * @brief
    * 获取剩余可用空间大小
    * @return INT32
    * @remark 此函数不是线程安全的
    */
    INT32 GetFreeSpare();

    /**
    * @brief
    * 拷贝内存中的数据
    * @param nReadOffSet : m_pNextRead的偏移量
    * @param nLen : 需要读出的Buffer长度
    * @remark 此函数不是线程安全的
    */
    INT32 GetData(INT32 nReadOffSet,INT32 nLen, CHAR* szData);


private:
    CHAR    *m_pBuffer;
    CHAR    *m_pNextRead;
    CHAR    *m_pNextWrite;
    CHAR    *m_pEnd;
};

#endif
```

实现

```c++
#include "simpleloopbuffer.h"
#include <stdio.h>
#include <memory.h>
#include "gndebug.h"
#include "../../common/commonloggerex.h"
#include "gate_factory.h"


using namespace Storm;

CSimpleLoopBufferEx::CSimpleLoopBufferEx() :
    m_pBuffer(NULL),
    m_pNextRead(NULL),
    m_pNextWrite(NULL),
    m_pEnd(NULL)
{
}

CSimpleLoopBufferEx::~CSimpleLoopBufferEx()
{
    if (NULL != m_pBuffer)
    {
        CGateFactory::Instance()->ReleaseBlock((CBlock*)m_pBuffer);
        m_pBuffer = NULL;
        //delete[] m_pBuffer;
        //m_pBuffer = NULL;
    }
}

void CSimpleLoopBufferEx::Clear()
{
    m_pNextRead = m_pBuffer;
    m_pNextWrite = m_pBuffer;
}

bool CSimpleLoopBufferEx::Init()
{
    //m_pBuffer = SDNew char[nSize + 1];
    CBlock* pBlock = CGateFactory::Instance()->CreateBlock();
    if (!pBlock)
        return false;

    m_pBuffer = pBlock->GetBuff();
    if (NULL == m_pBuffer)
    {
        return false;
    }
    m_pNextRead = m_pBuffer;
    m_pNextWrite = m_pBuffer;
    //m_pEnd = m_pBuffer + nSize + 1;
    m_pEnd = m_pBuffer + pBlock->GetBuffLen();
    return true;
}

INT32 CSimpleLoopBufferEx::PushBack(const CHAR *pData, INT32 nLen)
{
    CHAR* poRead = m_pNextRead;
    if (m_pNextWrite >= poRead)
    {
        //  1、尾部指针减去写起始位置小于 nLen 
        //  2、读的起始位置减去内存首地址 小于nLen
        //  内存空间不够，不能将数据写入缓存
        /*                          == 内存模型 ==
                   (empty)             m_pNextRead         m_pNextWrite       (empty)
        |----------------------------------|--------------------|---------------------|
        */
        INT32 nRight = m_pEnd - m_pNextWrite;
        INT32 nLeft = poRead - m_pBuffer;
        if (nLeft + nRight <= nLen)
        {
            return -1;
        }
    }
    else
    {
        /*                          == 内存模型 ==
                                       m_pNextWrite (empty) m_pNextRead
        |----------------------------------|--------------------|---------------------|
        */
        if (poRead - m_pNextWrite <= nLen)
        {
            return -2;
        }
    }
    //     else  //  m_pNextWrite == m_pNextRead
    //     {
    //         if (m_pNextWrite > m_pBuffer)
    //         {
    //             m_oMutex.Unlock();
    //             return -3;
    //         }
    //     }
    if (m_pEnd - m_pNextWrite > nLen)
    {
        memcpy(m_pNextWrite, pData, nLen);
        m_pNextWrite += nLen;
    }
    else if (m_pEnd - m_pNextWrite == nLen)
    {
        memcpy(m_pNextWrite, pData, nLen);
        m_pNextWrite = m_pBuffer;
    }
    else
    {
        INT32 nStartLen = m_pEnd - m_pNextWrite;
        memcpy(m_pNextWrite, pData, nStartLen);
        memcpy(m_pBuffer, pData + nStartLen, nLen - nStartLen);
        m_pNextWrite = m_pBuffer + nLen - nStartLen;
    }
    return nLen;
}

INT32 CSimpleLoopBufferEx::PopFront(CHAR * &pBuf, INT32 nLen, CHAR* szData)
{
    CHAR* poNextWrite = m_pNextWrite;
    if (poNextWrite == m_pNextRead)
    {
        EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-1";
        return -1;
    }
    if (poNextWrite > m_pNextRead)
    {
        /*                          == 内存模型 ==
                   (empty)             m_pNextRead         m_pNextWrite       (empty)
        |----------------------------------|--------------------|---------------------|
        */
        if (poNextWrite - m_pNextRead < nLen)
        {
            EXLOG_ERROR << "PopFront failed! ErrCode:-2";
            return -2;
        }
    }
    else
    {
        /*                          == 内存模型 ==
                                      m_pNextWrite (empty) m_pNextRead
        |----------------------------------|--------------------|---------------------|
        */
        INT32 nRight = m_pEnd - m_pNextRead;
        INT32 nLeft = poNextWrite - m_pBuffer;
        if (nLeft + nRight < nLen)
        {
            EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-3";
            return -3;
        }
    }
    if (m_pEnd - m_pNextRead > nLen)
    {
        memcpy(szData, m_pNextRead, nLen);
        m_pNextRead += nLen;
    }
    else if (m_pEnd - m_pNextRead == nLen)
    {
        memcpy(szData, m_pNextRead, nLen);
        m_pNextRead = m_pBuffer;
    }
    else
    {
        INT32 nStartLen = m_pEnd - m_pNextRead;
        memcpy(szData, m_pNextRead, nStartLen);
        memcpy(szData + nStartLen, m_pBuffer, nLen - nStartLen);
        m_pNextRead = m_pBuffer + nLen - nStartLen;
    }
    return nLen;
}


bool CSimpleLoopBufferEx::DiscardFront(INT32 nLen)
{
    CHAR* poNextWrite = m_pNextWrite;
    if (poNextWrite == m_pNextRead)
    {
        EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-1";
        return false;
    }
    if (poNextWrite > m_pNextRead)
    {
        /*                          == 内存模型 ==
        (empty)             m_pNextRead         m_pNextWrite       (empty)
        |----------------------------------|--------------------|---------------------|
        */
        if (poNextWrite - m_pNextRead < nLen)
        {
            EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-2";
            return false;
        }
    }
    else
    {
        /*                          == 内存模型 ==
        m_pNextWrite (empty) m_pNextRead
        |----------------------------------|--------------------|---------------------|
        */
        INT32 nRight = m_pEnd - m_pNextRead;
        INT32 nLeft = poNextWrite - m_pBuffer;
        if (nLeft + nRight < nLen)
        {
            EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-3";
            return false;
        }
    }
    if (m_pEnd - m_pNextRead > nLen)
    {
        m_pNextRead += nLen;
    }
    else if (m_pEnd - m_pNextRead == nLen)
    {
        m_pNextRead = m_pBuffer;
    }
    else
    {
        INT32 nStartLen = m_pEnd - m_pNextRead;
        m_pNextRead = m_pBuffer + nLen - nStartLen;
    }

    return true;
}

INT32 CSimpleLoopBufferEx::GetFreeSpare()
{
    CHAR* poRead = m_pNextRead;
    if (m_pNextWrite >= poRead)
    {
        //  1、尾部指针减去写起始位置小于 nLen 
        //  2、读的起始位置减去内存首地址 小于nLen
        //  内存空间不够，不能将数据写入缓存
        /*                          == 内存模型 ==
        (empty)             m_pNextRead         m_pNextWrite       (empty)
        |----------------------------------|--------------------|---------------------|
        */
        INT32 nRight = m_pEnd - m_pNextWrite;
        INT32 nLeft = poRead - m_pBuffer;
        return nLeft + nRight;

    }
    else
    {
        /*                          == 内存模型 ==
        m_pNextWrite (empty) m_pNextRead
        |----------------------------------|--------------------|---------------------|
        */

        return poRead - m_pNextWrite;
    }
}

INT32 CSimpleLoopBufferEx::GetData(INT32 nReadOffSet, INT32 nLen, CHAR* szData)
{
    //指针偏移
    CHAR* poNextWrite = m_pNextWrite;
    if (poNextWrite == m_pNextRead)
    {
        EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-1";
        return -1;
    }

    CHAR *pReadOffSet = m_pNextRead + nReadOffSet;
    if (poNextWrite > m_pNextRead)
    {
        /*                          == 内存模型 ==
        (empty)             m_pNextRead         m_pNextWrite       (empty)
        |----------------------------------|--------------------|---------------------|
        */

        if (pReadOffSet >= m_pNextWrite)
        {
            EXLOG_ERROR << "GetData failed! ErrCode:-2";
            return -2;
        }
    }
    else
    {
        /*                          == 内存模型 ==
        m_pNextWrite (empty) m_pNextRead
        |----------------------------------|--------------------|---------------------|
        */

        if (pReadOffSet < m_pEnd)
        {

        }
        else if (pReadOffSet == m_pEnd)
        {
            pReadOffSet = m_pBuffer;
            if (pReadOffSet >= m_pNextWrite)
            {
                EXLOG_ERROR << "GetData failed! ErrCode:-3";
                return -3;
            }
        }
        else {
            pReadOffSet = m_pBuffer + nReadOffSet - (m_pEnd - m_pNextRead);
            if (pReadOffSet >= m_pNextWrite)
            {
                EXLOG_ERROR << "GetData failed! ErrCode:-4";
                return -4;
            }
        }
    }

    //拷贝数据

    if (poNextWrite > pReadOffSet)
    {
        /*                          == 内存模型 ==
        (empty)             m_pNextRead         m_pNextWrite       (empty)
        |----------------------------------|--------------------|---------------------|
        */
        if (poNextWrite - pReadOffSet < nLen)
        {
            EXLOG_ERROR << "PopFront failed! ErrCode:-5";
            return -5;
        }
    }
    else
    {
        /*                          == 内存模型 ==
        m_pNextWrite (empty) m_pNextRead
        |----------------------------------|--------------------|---------------------|
        */
        INT32 nRight = m_pEnd - pReadOffSet;
        INT32 nLeft = poNextWrite - m_pBuffer;
        if (nLeft + nRight < nLen)
        {
            EXLOG_ERROR << "[%s:%d]:PopFront failed! ErrCode:-6";
            return -6;
        }
    }
    if (m_pEnd - pReadOffSet > nLen)
    {
        memcpy(szData, pReadOffSet, nLen);
        //pReadOffSet += nLen;
    }
    else if (m_pEnd - pReadOffSet == nLen)
    {
        memcpy(szData, pReadOffSet, nLen);
        //pReadOffSet = m_pBuffer;
    }
    else
    {
        INT32 nStartLen = m_pEnd - pReadOffSet;
        memcpy(szData, pReadOffSet, nStartLen);
        memcpy(szData + nStartLen, m_pBuffer, nLen - nStartLen);
        //m_pNextRead = m_pBuffer + nLen - nStartLen;
    }


    return nLen;

}

```