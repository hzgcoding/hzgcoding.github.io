<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->
<title>Timer 定时器技术分享 - Genge 随笔</title>

<!-- Icon -->
<link rel="icon" href="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg">

<!-- Fonts -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>



<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->





    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


    <meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Genge 随笔" type="application/atom+xml">
</head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Genge 随笔
        </div>
    </a>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                <div class="nav-item">
                    <a href="/" class="menu gt-a-link" target="_self">首页</a>
                </div>
            
                <div class="nav-item">
                    <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                </div>
            
                <div class="nav-item">
                    <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                </div>
            
                <div class="nav-item">
                    <a href="/timeline/" class="menu gt-a-link" target="_self">时间线</a>
                </div>
            
                <div class="nav-item">
                    <a href="/about/" class="menu gt-a-link" target="_self">关于</a>
                </div>
            
                <div class="nav-item">
                    <a href="/friends/" class="menu gt-a-link" target="_self">友链</a>
                </div>
            
                <div class="nav-item">
                    <a href="/atom.xml" class="menu gt-a-link" target="_self">rss</a>
                </div>
            
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }
</script>

                <div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">Timer 定时器技术分享</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    · 2020-01-23 ·</time>
                
                    
                        <a href="/tags/timer/" class="post-tag">
                            #timer</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <h2 id="说点废话"><a href="#说点废话" class="headerlink" title="说点废话"></a>说点废话</h2><blockquote>
<p>不管是客户端<code>Client</code>还是服务器<code>Server</code>，不论你是从事游戏行业还是互联网行业，在技术上总会涉及到定时器。虽然有的框架系统已经帮你实现，并且提供完美API供你使用，但你真的了解定时器吗？我们不仅要知道如何使用正确的Timer，还得明白定时器的实现原理，要知其所以然。  </p>
</blockquote>
<h2 id="理解定时器"><a href="#理解定时器" class="headerlink" title="理解定时器"></a>理解定时器</h2><p>使用者角度分类：</p>
<ol>
<li><p>周期性定时器</p>
<ol>
<li>使用 <code>TCP</code> 长连接时，客户端需要定时向服务端发送心跳请求</li>
<li>游戏内系统每日重置功能</li>
<li>体力回复</li>
<li>….</li>
</ol>
</li>
<li><p>非周期性定时器</p>
<ol>
<li>玩法活动定时开启、关闭</li>
<li>…</li>
</ol>
</li>
</ol>
<p><strong>当然，大部分非周期性定时器都可以使用周期性定时器实现，即执行一次后立即调用Remove接口即可</strong></p>
<p>定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：<strong>存储一系列的任务集合，并且 <code>Deadline</code> 越接近的任务，拥有越高的执行优先级</strong></p>
<p>支持以下几种操作：</p>
<ol>
<li><code>Add New TimerTask</code> 添加新的定时器</li>
<li><code>Kill Or Remove TimerTask</code> 取消或者移除既有定时器任务</li>
<li><code>Run</code> 执行</li>
</ol>
<p>判断一个<code>TimerTask</code>是否到期，基本会采用轮询的方式，每隔一个<strong>时间片</strong><code>tickDuration</code>去检查最近的任务是否到期。</p>
<blockquote>
<p><strong>说到底，定时器还是靠线程轮询实现的。</strong></p>
</blockquote>
<p>现在知道<code>Timer</code>是靠轮询来实现的，那么中间应该采用那种数据结构呢？采用不同的数据结构实现，其性能也大不一样！<br>现在主要有如下几种：<code>List</code>链表、<code>Heap</code>最小堆、时间轮、分级时间轮，其中时间轮的实质为Hash表。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="双向有序链表"><a href="#双向有序链表" class="headerlink" title="双向有序链表"></a>双向有序链表</h3><p><code>AddTimer O(N) </code>很容易理解，按照 <code>expireTime</code> 查找合适的位置即可；<code>KillTimer O(1)</code> ，任务在 <code>Kill</code> 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除;<code>RunTimer O(1)</code>，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。</p>
<h3 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h3><p>最小堆指的是满足除了根节点以外的每个节点都不小于其父节点的堆。这样，堆中的最小值就存放在根节点中，并且在以某个结点为根的子树中，各节点的值都不小于该子树根节点的值。一个最小堆的例子如下图：<br><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image002.jpg" alt="最小堆"></p>
<p>明显的，最小堆添加新元素或者删除节点效率为<code>O(lgn)</code>, <code>root</code>节点<code>expireTime</code>最小，执行优先级最高，因此复杂度为O(1)</p>
<p><strong>如果程序中的定时器数量比较少，基于最小堆的定时器一般可以满足需求，且实现简单。</strong></p>
<h3 id="时间轮"><a href="#时间轮" class="headerlink" title="时间轮"></a>时间轮</h3><p>时间轮的实质为哈希环<code>HashTable</code>,每个定时器任务根据对其<code>expireTime</code>哈希，得到对应的位置<code>index</code>，复杂度为<code>O(1)</code><br><img src="http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png" alt="时间轮"></p>
<p><strong>性能比较：</strong></p>
<table>
<thead>
<tr>
<th>实现方式</th>
<th>AddTimer</th>
<th>KillTimer</th>
<th>RunTimer</th>
</tr>
</thead>
<tbody><tr>
<td>基于链表</td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>基于排序链表</td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>基于最小堆</td>
<td>O(lgn)</td>
<td>O(lgn)</td>
<td>O(1)</td>
</tr>
<tr>
<td>基于时间轮</td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p><em>现在看起来我们选择时间轮来实现就行了，是否这样就完事了？</em></p>
<h2 id="着重分析时间轮"><a href="#着重分析时间轮" class="headerlink" title="着重分析时间轮"></a>着重分析时间轮</h2><p>如果需要支持的定时器范围非常的大，上面的实现方式则不能满足这样的需求。因为这样将消耗非常可观的内存，假设需要表示的定时器范围为：0 – 2^3-1ticks，则简单时间轮需要 2^32 个元素空间，这对于内存空间的使用将非常的庞大。也许可以降低定时器的精度，使得每个 Tick 表示的时间更长一些，但这样的代价是定时器的精度将大打折扣。</p>
<p>现在的问题是，度量定时器的粒度，只能使用唯一粒度吗？想想日常生活中常遇到的水表，如下图：<br><img src="https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image004.jpg" alt="水表"></p>
<p>钟表：<br><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556440651&di=0c604969bfdf6b335dd78462f862743e&imgtype=jpg&er=1&src=http://amuseum.cdstm.cn/AMuseum/time/01gzsj/images/0102_b.jpg" alt="水表"></p>
<p>分级时间轮同样如此，每级时间轮所代表的粒度精度都不一样，这样结合起来，既能够保证定时器的精度，也能以较小内存代价表示范围更大更多的定时器。</p>
<p><strong>简单时间轮</strong>： 一个齿轮，每个齿轮保存一个超时的node链表。一个齿轮表示一个时间刻度，比如钟表里面一小格代表一秒，钟表的秒针每次跳一格。假设一个刻度代表10ms，则2^32 个格子可表示1.36年，2^16个格子可表示10.9分钟。当要表示的时间范围较大时，空间复杂度会大幅增加。</p>
<p><strong>分级时间轮</strong>： 类似于水表，当小轮子里的指针转动满一圈后，上一级轮子的指针进一格。  采用五个轮子每个轮子为一个简单时间轮，大小分别为 2^8， 2^6， 2^6， 2^6， 2^6，所需空间：2^8 + 2^6 + 2^6 + 2^6 + 2^6 &#x3D; 512， 可表示的范围为 0  –  2^8 * 2^6 * 2^6* 2^6* 2^6 &#x3D; 2^32 。</p>
<p><strong>分级时间轮简洁图</strong>：<br><img src="http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png" alt="分级时间轮"></p>
<p><em>熟知的Linux系统内核，定时器实现方式就是分级时间轮</em><br><img src="https://images0.cnblogs.com/i/205989/201405/281755599318276.jpg" alt="Linux内核"></p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>wheel_timer_mgr.h</p>
<pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CWheelTimerModule</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ITimerMgr</span>;
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CWheelTimer</span>;

<span class="hljs-keyword">typedef</span> std::list&lt;CWheelTimer*&gt; TListTimer;

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">ETimerType</span> 
&#123; 
    ETIMER_ONCE, 
    ETIMER_CIRCLE 
&#125;;

<span class="hljs-comment">///定时器最小精度 1/10秒 （100毫秒）</span>
<span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span>  WHEEL_TIMER_MIN_PRECISION = <span class="hljs-number">100</span>;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">* @brief 基于分级的时间轮定时器, 精度约定为十分之一秒</span>
<span class="hljs-comment">* 注意，注册的Timer精度必须为约定的精度倍数</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CWheelTimer</span>
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">CWheelTimer</span>();
    <span class="hljs-built_in">CWheelTimer</span>(CWheelTimerModule&amp; oModule);
    ~<span class="hljs-built_in">CWheelTimer</span>();

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * @brief 启动定时器</span>
<span class="hljs-comment">    * @param nInterval: 传入的是毫秒, 约定必须是十分之一秒（100ms）的倍数</span>
<span class="hljs-comment">    * @return </span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Start</span><span class="hljs-params">(ITimerMgr* pITimer, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId, <span class="hljs-type">unsigned</span> nInterval, <span class="hljs-type">int</span> nDelay, ETimerType eTimerType = ETIMER_CIRCLE)</span></span>;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * @brief 停止定时器</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stop</span><span class="hljs-params">()</span></span>;
<span class="hljs-keyword">private</span>:
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * @brief 定时器被触发</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">OnTrigger</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT64 nNow)</span></span>;

<span class="hljs-keyword">private</span>:
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CWheelTimerModule</span>;

    CWheelTimerModule&amp;		m_oModule;
    ITimerMgr*				m_pTimerMgr = <span class="hljs-literal">nullptr</span>;
    ETimerType				m_eTimerType;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>			m_nTimerId = <span class="hljs-number">0</span>;
    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>			m_nInterval = <span class="hljs-number">-1</span>;    <span class="hljs-comment">//ms</span>
    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>		m_llExpireTime = <span class="hljs-number">0</span>;  <span class="hljs-comment">//ms</span>
    <span class="hljs-type">int</span>						m_nVecIndex = <span class="hljs-number">0</span>;
    TListTimer::iterator	m_listIter;
&#125;;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">* @brief 定时器管理器接口， 派生类继承使用</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ITimerMgr</span>
&#123;
<span class="hljs-keyword">public</span>:
    <span class="hljs-keyword">virtual</span>		  ~<span class="hljs-built_in">ITimerMgr</span>();
    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>  <span class="hljs-title">OnTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span> </span>= <span class="hljs-number">0</span>;
    <span class="hljs-comment">//interval 时间精度 ms</span>
    <span class="hljs-function"><span class="hljs-type">void</span>		  <span class="hljs-title">SetTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId, <span class="hljs-type">int</span> nInterval, <span class="hljs-type">int</span> nDelay = <span class="hljs-number">0</span>, ETimerType eTimeType = ETIMER_CIRCLE)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span>		  <span class="hljs-title">KillTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span></span>;
    <span class="hljs-function"><span class="hljs-type">bool</span>		  <span class="hljs-title">IsTimerExist</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span></span>;;

<span class="hljs-keyword">protected</span>:
    std::unordered_map&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, CWheelTimer*&gt; m_mapTimer;
&#125;;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">* @brief 全局定时器管理模块， 负责管理所有的定时器</span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CWheelTimerModule</span> : <span class="hljs-keyword">public</span> Storm::TSingleton&lt;CWheelTimerModule&gt;
&#123;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Storm</span>::TSingleton&lt;CWheelTimerModule&gt;;
    <span class="hljs-built_in">CWheelTimerModule</span>();
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">void</span>			<span class="hljs-title">AddTimer</span><span class="hljs-params">(CWheelTimer* pTimer)</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span>			<span class="hljs-title">RemoveTimer</span><span class="hljs-params">(CWheelTimer* pTimer)</span></span>;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * @brief 驱动所有的定时器</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function"><span class="hljs-type">void</span>			<span class="hljs-title">Run</span><span class="hljs-params">()</span></span>;

    <span class="hljs-function"><span class="hljs-type">static</span> UINT64	<span class="hljs-title">GetCurMillisecs</span><span class="hljs-params">()</span></span>;
    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * @brief 修正精度 </span>
<span class="hljs-comment">    * @param nSrcTime </span>
<span class="hljs-comment">    * @return 传入的时间除以当前约定最小定时器精度</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function"><span class="hljs-type">static</span> UINT64	<span class="hljs-title">HandlePrecision</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT64 nSrcTime)</span></span>;

<span class="hljs-keyword">private</span>:
    <span class="hljs-type">int</span>				_Cascade(<span class="hljs-type">int</span> nOffset, <span class="hljs-type">int</span> nIndex);

<span class="hljs-keyword">private</span>:
    std::vector&lt;TListTimer&gt;		m_vecTimerList;

    <span class="hljs-comment">//notice: precision=100ms not 1ms</span>
    UINT64						m_llCheckTime;
&#125;;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">* @brief 定时器工厂 </span>
<span class="hljs-comment">*/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CTimerFactory</span>: <span class="hljs-keyword">public</span> Storm::TSingleton&lt;CTimerFactory&gt;, <span class="hljs-keyword">public</span> CNoncopy
&#123;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Storm</span>::TSingleton&lt;CTimerFactory&gt;;
    <span class="hljs-built_in">CTimerFactory</span>();
    <span class="hljs-keyword">virtual</span>			~<span class="hljs-built_in">CTimerFactory</span>();
<span class="hljs-keyword">public</span>: 
    <span class="hljs-function">CWheelTimer*	<span class="hljs-title">CreateCTimer</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-type">void</span>			<span class="hljs-title">ReleaseCTimer</span><span class="hljs-params">(CWheelTimer* pTimer)</span></span>;
<span class="hljs-keyword">private</span>:

    CSTObjectPool&lt;CWheelTimer&gt;    m_oCTimerPool;
&#125;</code></pre>

<p>wheel_timer_mgr.cpp</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0 </span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TVN_BITS 6</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TVR_BITS 8</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TVN_SIZE (1 &lt;&lt; TVN_BITS)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TVR_SIZE (1 &lt;&lt; TVR_BITS)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TVN_MASK (TVN_SIZE - 1)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> TVR_MASK (TVR_SIZE - 1)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> OFFSET(N) (TVR_SIZE + (N) *TVN_SIZE)</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> INDEX(V, N) ((V &gt;&gt; (TVR_BITS + (N) *TVN_BITS)) &amp; TVN_MASK)</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span> </span>
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> TVN_BITS = <span class="hljs-number">6</span>;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> TVR_BITS = <span class="hljs-number">8</span>;
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> TVN_SIZE = (<span class="hljs-number">1</span> &lt;&lt; TVN_BITS);
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> TVR_SIZE = (<span class="hljs-number">1</span> &lt;&lt; TVR_BITS);
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> TVN_MASK = (TVN_SIZE - <span class="hljs-number">1</span>);
    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> TVR_MASK = (TVR_SIZE - <span class="hljs-number">1</span>);
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">OFFSET</span><span class="hljs-params">(<span class="hljs-type">int</span> N)</span> </span>&#123; <span class="hljs-keyword">return</span> (TVR_SIZE + (N)*TVN_SIZE); &#125;
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">INDEX</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> V, <span class="hljs-type">int</span> N)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> ((V &gt;&gt; (TVR_BITS + (N)*TVN_BITS)) &amp; TVN_MASK);
    &#125;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>



CWheelTimer::<span class="hljs-built_in">CWheelTimer</span>()
    :<span class="hljs-built_in">m_oModule</span>(CWheelTimerModule::<span class="hljs-built_in">GetInstance</span>())
    , <span class="hljs-built_in">m_nVecIndex</span>(<span class="hljs-number">-1</span>)
&#123;
&#125;

CWheelTimer::<span class="hljs-built_in">CWheelTimer</span>(CWheelTimerModule&amp; oModule)
    : <span class="hljs-built_in">m_oModule</span>(oModule)
    , <span class="hljs-built_in">m_nVecIndex</span>(<span class="hljs-number">-1</span>)
&#123;
&#125;

CWheelTimer::~<span class="hljs-built_in">CWheelTimer</span>()
&#123;
    <span class="hljs-built_in">Stop</span>();
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CWheelTimer::Start</span><span class="hljs-params">(ITimerMgr* pTimerMgr, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId, <span class="hljs-type">unsigned</span> nInterval, <span class="hljs-type">int</span> nDelay, ETimerType eTimerType)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">Stop</span>();

    <span class="hljs-comment">//时间都修正为最小精度</span>
    <span class="hljs-keyword">if</span> (nInterval &lt; WHEEL_TIMER_MIN_PRECISION)
    &#123;
        nInterval = WHEEL_TIMER_MIN_PRECISION;
    &#125;

    m_nInterval = CWheelTimerModule::<span class="hljs-built_in">HandlePrecision</span>(nInterval);
    m_eTimerType = eTimerType;
    m_pTimerMgr = pTimerMgr;
    m_nTimerId = nId;
    m_llExpireTime = CWheelTimerModule::<span class="hljs-built_in">HandlePrecision</span>(nDelay + CWheelTimerModule::<span class="hljs-built_in">GetCurMillisecs</span>());
    m_oModule.<span class="hljs-built_in">AddTimer</span>(<span class="hljs-keyword">this</span>);
&#125;


<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CWheelTimer::Stop</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (m_nVecIndex != <span class="hljs-number">-1</span>)
    &#123;
        m_oModule.<span class="hljs-built_in">RemoveTimer</span>(<span class="hljs-keyword">this</span>);
        m_nVecIndex = <span class="hljs-number">-1</span>;
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CWheelTimer::OnTrigger</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT64 nNow)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (m_eTimerType == ETIMER_CIRCLE)
    &#123;
        m_llExpireTime = m_nInterval + nNow;
        m_oModule.<span class="hljs-built_in">AddTimer</span>(<span class="hljs-keyword">this</span>);
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        m_nVecIndex = <span class="hljs-number">-1</span>;
    &#125;

    <span class="hljs-keyword">if</span> (m_pTimerMgr != <span class="hljs-literal">nullptr</span>)
    &#123;
        m_pTimerMgr-&gt;<span class="hljs-built_in">OnTimer</span>(m_nTimerId);
    &#125;
&#125;

<span class="hljs-comment">//--------------------------------------------------------------------------------------------------------</span>

CWheelTimerModule::<span class="hljs-built_in">CWheelTimerModule</span>()
&#123;
    m_vecTimerList.<span class="hljs-built_in">resize</span>(TVR_SIZE + <span class="hljs-number">4</span> * TVN_SIZE);
    m_llCheckTime = <span class="hljs-built_in">HandlePrecision</span>(<span class="hljs-built_in">GetCurMillisecs</span>());
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CWheelTimerModule::AddTimer</span><span class="hljs-params">(CWheelTimer* pTimer)</span></span>
<span class="hljs-function"></span>&#123;
    UINT64 llExpireTime = pTimer-&gt;m_llExpireTime;
    INT64 llTimeDiff = pTimer-&gt;m_llExpireTime - m_llCheckTime;

    <span class="hljs-keyword">if</span> (llTimeDiff &lt; <span class="hljs-number">0</span>)
    &#123;
        pTimer-&gt;m_nVecIndex = m_llCheckTime &amp; TVR_MASK;
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (llTimeDiff &lt; TVR_SIZE)
    &#123;
        pTimer-&gt;m_nVecIndex = llExpireTime &amp; TVR_MASK;
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (llTimeDiff &lt; <span class="hljs-number">1</span> &lt;&lt; (TVR_BITS + TVN_BITS))
    &#123;
        pTimer-&gt;m_nVecIndex = <span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">0</span>) + <span class="hljs-built_in">INDEX</span>(llExpireTime, <span class="hljs-number">0</span>);
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (llTimeDiff &lt; <span class="hljs-number">1</span> &lt;&lt; (TVR_BITS + <span class="hljs-number">2</span> * TVN_BITS))
    &#123;
        pTimer-&gt;m_nVecIndex = <span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">1</span>) + <span class="hljs-built_in">INDEX</span>(llExpireTime, <span class="hljs-number">1</span>);
    &#125;
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (llTimeDiff &lt; <span class="hljs-number">1</span> &lt;&lt; (TVR_BITS + <span class="hljs-number">3</span> * TVN_BITS))
    &#123;
        pTimer-&gt;m_nVecIndex = <span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">2</span>) + <span class="hljs-built_in">INDEX</span>(llExpireTime, <span class="hljs-number">2</span>);
    &#125;
    <span class="hljs-keyword">else</span>
    &#123;
        <span class="hljs-keyword">if</span> (llTimeDiff &gt; <span class="hljs-number">0xffffffff</span>UL)
        &#123;
            llTimeDiff = <span class="hljs-number">0xffffffff</span>UL;
            llExpireTime = llTimeDiff + m_llCheckTime;
        &#125;
        pTimer-&gt;m_nVecIndex = <span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">3</span>) + <span class="hljs-built_in">INDEX</span>(llExpireTime, <span class="hljs-number">3</span>);
    &#125;

    TListTimer&amp; listTimer = m_vecTimerList[pTimer-&gt;m_nVecIndex];
    listTimer.<span class="hljs-built_in">push_back</span>(pTimer);
    pTimer-&gt;m_listIter = listTimer.<span class="hljs-built_in">end</span>();
    --pTimer-&gt;m_listIter;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CWheelTimerModule::RemoveTimer</span><span class="hljs-params">(CWheelTimer* pTimer)</span></span>
<span class="hljs-function"></span>&#123;
    TListTimer&amp; listTimer = m_vecTimerList[pTimer-&gt;m_nVecIndex];
    listTimer.<span class="hljs-built_in">erase</span>(pTimer-&gt;m_listIter);
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CWheelTimerModule::Run</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    UINT64 nNow = <span class="hljs-built_in">HandlePrecision</span>(<span class="hljs-built_in">GetCurMillisecs</span>());
    <span class="hljs-keyword">while</span> (m_llCheckTime &lt;= nNow)
    &#123;
        <span class="hljs-comment">//for every tick</span>
        <span class="hljs-type">int</span> index = m_llCheckTime &amp; TVR_MASK;
        <span class="hljs-keyword">if</span> (!index &amp;&amp;
            !_Cascade(<span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">INDEX</span>(m_llCheckTime, <span class="hljs-number">0</span>)) &amp;&amp;
            !_Cascade(<span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">1</span>), <span class="hljs-built_in">INDEX</span>(m_llCheckTime, <span class="hljs-number">1</span>)) &amp;&amp;
            !_Cascade(<span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">2</span>), <span class="hljs-built_in">INDEX</span>(m_llCheckTime, <span class="hljs-number">2</span>)))
        &#123;
            _Cascade(<span class="hljs-built_in">OFFSET</span>(<span class="hljs-number">3</span>), <span class="hljs-built_in">INDEX</span>(m_llCheckTime, <span class="hljs-number">3</span>));
        &#125;

        
        ++m_llCheckTime;

        TListTimer&amp; listTimer = m_vecTimerList[index];
        TListTimer listTmp;
        listTmp.<span class="hljs-built_in">splice</span>(listTmp.<span class="hljs-built_in">end</span>(), listTimer);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = listTmp.<span class="hljs-built_in">begin</span>(); itr != listTmp.<span class="hljs-built_in">end</span>(); ++itr)
        &#123;
            <span class="hljs-keyword">auto</span>* pTimer = *itr;
            <span class="hljs-keyword">if</span> (pTimer != <span class="hljs-literal">nullptr</span>)
            &#123;
                pTimer-&gt;<span class="hljs-built_in">OnTrigger</span>(nNow);
            &#125;
        &#125;
    &#125;
&#125;

<span class="hljs-type">int</span> CWheelTimerModule::_Cascade(<span class="hljs-type">int</span> nOffset, <span class="hljs-type">int</span> nIndex)
&#123;
    TListTimer&amp; listTimer = m_vecTimerList[nOffset + nIndex];
    TListTimer listTemp;
    listTemp.<span class="hljs-built_in">splice</span>(listTemp.<span class="hljs-built_in">end</span>(), listTimer);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> itr = listTemp.<span class="hljs-built_in">begin</span>(); itr != listTemp.<span class="hljs-built_in">end</span>(); ++itr)
    &#123;
        <span class="hljs-keyword">auto</span>* pTimer = *itr;
        <span class="hljs-keyword">if</span> (pTimer != <span class="hljs-literal">nullptr</span>)
        &#123;
            <span class="hljs-built_in">AddTimer</span>(pTimer);
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> nIndex;
&#125;

<span class="hljs-function">UINT64 <span class="hljs-title">CWheelTimerModule::HandlePrecision</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT64 nSrcTime)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">return</span> nSrcTime / WHEEL_TIMER_MIN_PRECISION;
&#125;

<span class="hljs-function">UINT64 <span class="hljs-title">CWheelTimerModule::GetCurMillisecs</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">auto</span> llCurTime = CSysTime::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">GetNowMliTime</span>();
    <span class="hljs-keyword">return</span> llCurTime;
&#125;

ITimerMgr::~<span class="hljs-built_in">ITimerMgr</span>()
&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : m_mapTimer)
    &#123;
        <span class="hljs-keyword">if</span> (it.second != <span class="hljs-literal">nullptr</span>)
        &#123;
            it.second-&gt;<span class="hljs-built_in">Stop</span>();
            CTimerFactory::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">ReleaseCTimer</span>(it.second);
        &#125;
    &#125;
    m_mapTimer.<span class="hljs-built_in">clear</span>();
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ITimerMgr::SetTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId, <span class="hljs-type">int</span> nInterval, <span class="hljs-type">int</span> nDelay ,ETimerType eTimeType)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsTimerExist</span>(nId))
    &#123;
        EXLOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;[RyzTimer]Timer Has Existed, Not Repeat Add, nId:&quot;</span> &lt;&lt; nId;
        <span class="hljs-keyword">return</span>;
    &#125;

    CWheelTimer* pTimer = CTimerFactory::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">CreateCTimer</span>();
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> == pTimer)
    &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    m_mapTimer[nId] = pTimer;
    pTimer-&gt;<span class="hljs-built_in">Start</span>(<span class="hljs-keyword">this</span>, nId, nInterval, nDelay, eTimeType);
    EXLOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;[RyzTimer]Add Timer nId:&quot;</span> &lt;&lt; nId &lt;&lt; <span class="hljs-string">&quot;,nInterval:&quot;</span> &lt;&lt; nInterval &lt;&lt; <span class="hljs-string">&quot;,nDelay:&quot;</span> &lt;&lt; nDelay &lt;&lt; <span class="hljs-string">&quot;,eTimeType:&quot;</span> &lt;&lt; eTimeType;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ITimerMgr::KillTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">auto</span> it = m_mapTimer.<span class="hljs-built_in">find</span>(nId);
    <span class="hljs-keyword">if</span> (it != m_mapTimer.<span class="hljs-built_in">end</span>())
    &#123;
        <span class="hljs-comment">// 释放后 在TimerManager中 不会再执行 不需要做其他的操作</span>
        it-&gt;second-&gt;<span class="hljs-built_in">Stop</span>();
        CTimerFactory::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">ReleaseCTimer</span>(it-&gt;second);
        m_mapTimer.<span class="hljs-built_in">erase</span>(it);
    &#125;
&#125;

<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ITimerMgr::IsTimerExist</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span> </span>
<span class="hljs-function"></span>&#123; 
    <span class="hljs-keyword">return</span> m_mapTimer.<span class="hljs-built_in">find</span>(nId) != m_mapTimer.<span class="hljs-built_in">end</span>(); 
&#125;

CTimerFactory::<span class="hljs-built_in">CTimerFactory</span>()
&#123;
    m_oCTimerPool.<span class="hljs-built_in">Init</span>(<span class="hljs-number">32</span>, <span class="hljs-number">8</span>);
&#125;

CTimerFactory::~<span class="hljs-built_in">CTimerFactory</span>()
&#123;
&#125;

<span class="hljs-function">CWheelTimer * <span class="hljs-title">CTimerFactory::CreateCTimer</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    CWheelTimer* pTimer = m_oCTimerPool.<span class="hljs-built_in">FetchObj</span>();
    <span class="hljs-keyword">return</span> pTimer;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CTimerFactory::ReleaseCTimer</span><span class="hljs-params">(CWheelTimer* pTimer)</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span> != pTimer)
    &#123;
        m_oCTimerPool.<span class="hljs-built_in">ReleaseObj</span>(pTimer);
    &#125;
&#125;

</code></pre>
            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
                <div class="prev-post">
                    <div class="prev gt-c-content-color-first">
                        上一篇：<a href="/2020/01/23/%E5%90%84%E7%B1%BBAPP%E6%8E%92%E8%A1%8C%E6%A6%9C%E5%AE%9E%E7%8E%B0/" 
                            class="post-title gt-a-link">各类APP排行榜实现</a>
                    </div>
                </div>
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/2020/01/23/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80ID%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/" 
                            class="post-title gt-a-link">全局唯一ID生成算法优化</a>
                    </div>
                </div>
            
        </div>
    
    

    

    
</div>

                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <span style="text-align: right; float: right;">Theme <a 
            href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a> | Powered by <a 
            href="https://hexo.io" target="_blank">Hexo</a></span>
        <span style="text-align: left;">Footer HTML
</span>
    </div>
</div>

            </div>
        </div>
    </body>
</html>