<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->
<title>各类APP排行榜实现 - Genge 随笔</title>

<!-- Icon -->
<link rel="icon" href="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg">

<!-- Fonts -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>



<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->





    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


    <meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Genge 随笔" type="application/atom+xml">
</head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Genge 随笔
        </div>
    </a>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                <div class="nav-item">
                    <a href="/" class="menu gt-a-link" target="_self">首页</a>
                </div>
            
                <div class="nav-item">
                    <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                </div>
            
                <div class="nav-item">
                    <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                </div>
            
                <div class="nav-item">
                    <a href="/timeline/" class="menu gt-a-link" target="_self">时间线</a>
                </div>
            
                <div class="nav-item">
                    <a href="/about/" class="menu gt-a-link" target="_self">关于</a>
                </div>
            
                <div class="nav-item">
                    <a href="/friends/" class="menu gt-a-link" target="_self">友链</a>
                </div>
            
                <div class="nav-item">
                    <a href="/atom.xml" class="menu gt-a-link" target="_self">rss</a>
                </div>
            
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }
</script>

                <div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">各类APP排行榜实现</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    · 2020-01-23 ·</time>
                
                    
                        <a href="/tags/rank/" class="post-tag">
                            #rank</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><ol>
<li>查看TopN的用户排名</li>
<li>查看自己的排名</li>
<li>用户积分变更后，排名及时更新</li>
</ol>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><h3 id="方案一-利用MYSQL-排序"><a href="#方案一-利用MYSQL-排序" class="headerlink" title="方案一 利用MYSQL 排序"></a>方案一 利用MYSQL 排序</h3><p>利用MySQL来实现，存放一张用户积分表user_score<br>取前top N，自己的排名都可以通过简单的sql语句搞定。<br>算法简单，利用sql的功能，不需要其他复杂逻辑，对于数据量比较少、性能要求不高，可以使用。但是对于海量数据，性能是无法接受的。可能会导致全局锁表之类的问题。</p>
<h3 id="方案二-内存数组排序"><a href="#方案二-内存数组排序" class="headerlink" title="方案二 内存数组排序"></a>方案二 内存数组排序</h3><p>在内存中预分配所要排名用户大小的数组，所有的积分排名变更基于此移动元素，成熟排序算法有最小&#x2F;大堆、快速排序等，这种方案优点是当数据量小的时候，简单快捷，容易实现，不需要其他任何组件支持，但是当面对海量数据的时候数组空间占用可能不太现实</p>
<h3 id="方案三-利用GCC库支持"><a href="#方案三-利用GCC库支持" class="headerlink" title="方案三 利用GCC库支持"></a>方案三 利用GCC库支持</h3><p>具体的，用GCC的pb_ds库中有assoc_container来进行实现。<br>参考<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/llvmgcc42/llvmgcc42-2336.9/libstdc++-v3/testsuite/ext/pb_ds/example/tree_order_statistics.cc">tree_order_statistics.cc</a>：</p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cassert&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span>

<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> pb_ds;
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> pb_ds;

<span class="hljs-comment">// A red-black tree table storing ints and their order</span>
<span class="hljs-comment">// statistics. Note that since the tree uses</span>
<span class="hljs-comment">// tree_order_statistics_node_update as its update policy, then it</span>
<span class="hljs-comment">// includes its methods by_order and order_of_key.</span>
<span class="hljs-keyword">typedef</span>
tree&lt;
  <span class="hljs-type">int</span>,
  null_mapped_type,
  less&lt;<span class="hljs-type">int</span>&gt;,
  rb_tree_tag,
  <span class="hljs-comment">// This policy updates nodes&#x27; metadata for order statistics.</span>
  tree_order_statistics_node_update&gt;
<span class="hljs-type">set_t</span>;

<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
  <span class="hljs-comment">// Insert some entries into s.</span>
  <span class="hljs-type">set_t</span> s;
  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">12</span>);
  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">505</span>);
  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">30</span>);
  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">1000</span>);
  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">10000</span>);
  s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">100</span>);

  <span class="hljs-comment">// The order of the keys should be: 12, 30, 100, 505, 1000, 10000.</span>
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">0</span>) == <span class="hljs-number">12</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">30</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">100</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">505</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">4</span>) == <span class="hljs-number">1000</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">5</span>) == <span class="hljs-number">10000</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">6</span>) == s.<span class="hljs-built_in">end</span>());

  <span class="hljs-comment">// The order of the keys should be: 12, 30, 100, 505, 1000, 10000.</span>
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">10</span>) == <span class="hljs-number">0</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">12</span>) == <span class="hljs-number">0</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">15</span>) == <span class="hljs-number">1</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">30</span>) == <span class="hljs-number">1</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">99</span>) == <span class="hljs-number">2</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">100</span>) == <span class="hljs-number">2</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">505</span>) == <span class="hljs-number">3</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">1000</span>) == <span class="hljs-number">4</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">10000</span>) == <span class="hljs-number">5</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">9999999</span>) == <span class="hljs-number">6</span>);

  <span class="hljs-comment">// Erase an entry.</span>
  s.<span class="hljs-built_in">erase</span>(<span class="hljs-number">30</span>);

  <span class="hljs-comment">// The order of the keys should be: 12, 100, 505, 1000, 10000.</span>
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">0</span>) == <span class="hljs-number">12</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">1</span>) == <span class="hljs-number">100</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">2</span>) == <span class="hljs-number">505</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">3</span>) == <span class="hljs-number">1000</span>);
  <span class="hljs-built_in">assert</span>(*s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">4</span>) == <span class="hljs-number">10000</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">find_by_order</span>(<span class="hljs-number">5</span>) == s.<span class="hljs-built_in">end</span>());

  <span class="hljs-comment">// The order of the keys should be: 12, 100, 505, 1000, 10000.</span>
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">10</span>) == <span class="hljs-number">0</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">12</span>) == <span class="hljs-number">0</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">100</span>) == <span class="hljs-number">1</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">505</span>) == <span class="hljs-number">2</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">707</span>) == <span class="hljs-number">3</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">1000</span>) == <span class="hljs-number">3</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">1001</span>) == <span class="hljs-number">4</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">10000</span>) == <span class="hljs-number">4</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">100000</span>) == <span class="hljs-number">5</span>);
  <span class="hljs-built_in">assert</span>(s.<span class="hljs-built_in">order_of_key</span>(<span class="hljs-number">9999999</span>) == <span class="hljs-number">5</span>);

  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>
<p>存取效率都可以达到O(log(n))，不足就是程序重启后数据会丢失。还是对所有的用户积分，没必要。<br>而且是有依赖，不方便扩展，实现不了复杂的需求，</p>
<h3 id="方案四-实现排序树"><a href="#方案四-实现排序树" class="headerlink" title="方案四 实现排序树"></a>方案四 实现排序树</h3><p>大致实现思路如下：</p>
<p>　　我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量，非叶子结点的count值总是等于其左右子结点的count值之和。</p>
<p>　　以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！</p>
<p>　　虽然，本算法的更新和查询都涉及到若干个操作，但如果我们为区间的from_score和to_score建立索引，这些操作都是基于键的查询和更新，不会产生表扫描，因此效率更高。另外，本算法并不依赖于关系数据模型和SQL运算，可以轻易地改造为NoSQL等其他存储方式，而基于键的操作也很容易引入缓存机制进一步优化性能。进一步，我们可以估算一下树形区间的数目大约为2,000,000，考虑每个结点的大小，整个结构只占用几十M空间。所以，我们完全可以在内存建立区间树结构，并通过user_score表在O(n)的时间内初始化区间树，然后排名的查询和更新操作都可以在内存进行。一般来讲，同样的算法，从数据库到内存算法的性能提升常常可以达到10^5以上；因此，本算法可以达到非常高的性能。</p>
<p>　　算法特点</p>
<p>　　优点：结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；不依赖于SQL，容易改造为NoSQL或内存数据结构。</p>
<p>　　缺点：算法相对更复杂。</p>
<h3 id="方案五-实现跳表排序"><a href="#方案五-实现跳表排序" class="headerlink" title="方案五 实现跳表排序"></a>方案五 实现跳表排序</h3><p>skip list是链表的一种特殊形式，对链表的一种优化；保证INSERT和REMOVE操作是O(logn)，而通用链表的复杂度为O(n);<br>优点：实现较简单，效率基本上O(log(N))<br>缺点：当达到亿级别时的数据时，性能会急剧下降</p>
<h3 id="方案六-利用redis特新实现"><a href="#方案六-利用redis特新实现" class="headerlink" title="方案六 利用redis特新实现"></a>方案六 利用redis特新实现</h3><p>其实redis底层还是使用跳表实现排序的，只是将接口都封装好了，使用接口也比较完善，稳定。</p>
<p>redis的zset天生是用来做排行榜的、好友列表, 去重, 历史记录等业务需求。接口使用非常简单。接口非常丰富，基本上需要的实现都能满足，说明如下：</p>
<p>ZAdd&#x2F;ZRem是O(log(N))，ZRangeByScore&#x2F;ZRemRangeByScore是O(log(N)+M)，N是Set大小，M是结果&#x2F;操作元素的个数。</p>
<p>ZSET的实现用到了两个数据结构：hash table 和 skip list(跳跃表)，其中hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) ，而skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。</p>
<p>优点：基于redis开发，速度快；使用redis相关特性</p>
<p>缺点：当达到亿级别时的数据时，性能会急剧下降</p>
<p>来实现排行榜的方法很多，可以根据自己的具体需求，参考选用。</p>
<h2 id="方案七-其实只需要TopN的排名，大于N的排名并不需要精确排名计算"><a href="#方案七-其实只需要TopN的排名，大于N的排名并不需要精确排名计算" class="headerlink" title="方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算"></a>方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算</h2><p>基于此，假设我们游戏内只需要排前100名，这里我们只需要维护一个100大小的数组</p>
<ol>
<li>当元素A需要参与排序的时候，与数组中最小的积分进行比较，如果能进100名，那么将第100剔除，将A加入，并记录最小元素，这样就完成了积分上涨的情况</li>
<li>还有一种就是已经在前100名中元素的积分发生变化下降，那么需要在前100名后找出可以进排行榜的元素，这种情况比较麻烦，可以使用最大堆保存剩下所有用户的数据，当需要找出能替换进入排行榜的元素就非常快logn，选择特定数据结构非常重要</li>
<li>既然大于N的用户不需要精确排名，那么怎么样估算大概排名呢？一般做法是按照数值区间建立所若干个桶，比如我们预计要排名的那一个数据的最大值能到1W。我建立0-10， 10-100，100-1000， 1000-2000， 2000-5000， 5000-10000 这样6个桶，每个桶里面记录分值在这个桶对应的区间内，有多少个玩家。 比如<br>0-10， 10人<br>10-100，20人<br>100-1000，30人<br>1000-2000， 40人<br>2000-5000， 50人<br>5000-10000， 60人<br>那么如果一个玩家 是 1234分，那么他的排名就超过了 （10 + 20 + 30）&#x2F; （10 + 20 + 30 + 40 + 50 + 60）这个百分比的玩家（所以桶分的越细，后面的排名越精确）<br>实质就是按照分区间记录区间内元素个数，从而估算大概排名，因此数值区间越小，估算约精确。</li>
</ol>

            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
                <div class="prev-post">
                    <div class="prev gt-c-content-color-first">
                        上一篇：<a href="/2020/01/23/linux%20fork%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/" 
                            class="post-title gt-a-link">linux fork函数详解</a>
                    </div>
                </div>
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/2020/01/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%97%B6%E9%97%B4%E8%BD%AETimer%E5%AE%9A%E6%97%B6%E5%99%A8/" 
                            class="post-title gt-a-link">Timer 定时器技术分享</a>
                    </div>
                </div>
            
        </div>
    
    

    

    
</div>

                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <span style="text-align: right; float: right;">Theme <a 
            href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a> | Powered by <a 
            href="https://hexo.io" target="_blank">Hexo</a></span>
        <span style="text-align: left;">Footer HTML
</span>
    </div>
</div>

            </div>
        </div>
    </body>
</html>