<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">

<!-- Title -->
<title>全局唯一ID生成算法优化 - Genge 随笔</title>

<!-- Icon -->
<link rel="icon" href="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg">

<!-- Fonts -->
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap" as="style" onload="this.onload=null, this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital@0;1&family=Open+Sans:ital,wght@0,400;0,700;1,400;1,700&display=swap"></noscript>



<!-- Style -->

<link rel="stylesheet" href="/styles/main.css">

<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-theme-pure@1.0.1/dist/main.css"> -->





    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">


    <meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Genge 随笔" type="application/atom+xml">
</head>
    <body>
        <div class="main gt-bg-theme-color-first">
            <div class="main-content">
                <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Genge 随笔
        </div>
    </a>
    <button aria-label="Navbar Toggler" class="navbar-toggler" type="button" id="changeNavbar">
        <i class="gt-c-content-color-first" style="font-size: 18px;">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" height="18px" fill="currentColor">
                <path d="M16 132h416c8.837 0 16-7.163 16-16V76c0-8.837-7.163-16-16-16H16C7.163 60 0 67.163 0 76v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16zm0 160h416c8.837 0 16-7.163 16-16v-40c0-8.837-7.163-16-16-16H16c-8.837 0-16 7.163-16 16v40c0 8.837 7.163 16 16 16z" />
            </svg>
        </i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center; ">
            
                <div class="nav-item">
                    <a href="/" class="menu gt-a-link" target="_self">首页</a>
                </div>
            
                <div class="nav-item">
                    <a href="/archives/" class="menu gt-a-link" target="_self">归档</a>
                </div>
            
                <div class="nav-item">
                    <a href="/tags/" class="menu gt-a-link" target="_self">标签</a>
                </div>
            
                <div class="nav-item">
                    <a href="/timeline/" class="menu gt-a-link" target="_self">时间线</a>
                </div>
            
                <div class="nav-item">
                    <a href="/about/" class="menu gt-a-link" target="_self">关于</a>
                </div>
            
                <div class="nav-item">
                    <a href="/friends/" class="menu gt-a-link" target="_self">友链</a>
                </div>
            
                <div class="nav-item">
                    <a href="/atom.xml" class="menu gt-a-link" target="_self">rss</a>
                </div>
            
        </div>
    </div>
</nav>

<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = function() {
        let element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else { 
            element.style.display = 'none';
        }
    }
</script>

                <div class="post-container">
    <div class="post-detail gt-bg-theme-color-second gt-c-content-color-first">
        <article class="gt-post-content">
            <h1 class="post-title">全局唯一ID生成算法优化</h1>
            <div class="post-info">
                <time class="post-time gt-c-content-color-first">
                    · 2020-01-23 ·</time>
                
                    
                        <a href="/tags/uuid/" class="post-tag">
                            #uuid</a>
                    
                
            </div>
            <hr>
            <div class="post-content gt-c-content-color-first">
                <!-- toc -->

<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#Snowflake%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D">Snowflake算法介绍</a></li>
<li><a href="#SnowFlake%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96">SnowFlake算法优化</a><ul>
<li><a href="#%E7%9B%AE%E5%89%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7">目前算法设计缺陷</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96">设计优化</a></li>
</ul>
</li>
<li><a href="#%E6%98%AF%E5%90%A6%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%AE%8C%E7%BE%8E%E4%BA%86%E5%91%A2%EF%BC%9F">是否这样就完美了呢？</a></li>
<li><a href="#Talk-is-cheap-show-you-the-code">Talk is cheap, show you the code</a></li>
<li><a href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0">参考文章</a></li>
</ul>
<!-- tocstop -->

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进程启动前，一般会给每个进程静态分配一个唯一标识ID(ServerID或者PipeID)</p>
<pre><code class="hljs abnf">struct SServerID
&#123;
    UINT16 wPlatform <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;	 ///&lt; Platform   平台id </span>
    UINT16 wArea <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;        ///&lt; Area       区服id</span>
    UINT16 wType <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;        ///&lt; Type       服务器App类型</span>
    UINT16 wIndex <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;       ///&lt; Index      服务器App编号索引</span>
&#125;<span class="hljs-comment">;</span></code></pre>

<p>每个Role&#x2F;Item&#x2F;Hero&#x2F;Mail 等创建的时候都会创建一个UUID来唯一标识，其中Mail_Uuid还有趋势递增的需求</p>
<h2 id="Snowflake算法介绍"><a href="#Snowflake算法介绍" class="headerlink" title="Snowflake算法介绍"></a>Snowflake算法介绍</h2><p><em>SnowFlake分布式生成Id算法由Twitter开源</em></p>
<p>SnowFlake算法生成id的结果是一个64bit大小的UINT64整数，它的结构如下图：<br><img src="/:storage%5C1a51b319-5d9b-40f9-a828-cfc88309cea2%5C4dbfceed.png" alt="snowflake uuid-64bit"></p>
<p>SnowFlake的优点:<br>    - 整体上按照时间自增排序<br>    - 整个分布式系统内不会产生ID碰撞(时间戳和自增序列以外的字段作区分), 并且效率较高(位运算),</p>
<p>SnowFlake每秒能够产生6.4万ID左右.(和5段位的配置位数有关)<br>UUID从高位到低位依次排列：</p>
<ul>
<li>第一段：39位, 当对于某一个时间点的时间戳差值（至少10年可用）</li>
<li>第二段：3 位, 平台platform或大区id，比如QQ Android&#x2F;QQ IOS&#x2F;Wechat IOS 等（8）</li>
<li>第三段：11位, 区服area id，对应的就是服务器小区的ID（2048）</li>
<li>第四段：5 位, 服务器APP实例id index（32), Notice：appid需要在area范围内唯一</li>
<li>第五段：6 位, 自增长id，也就是说在一个完整的毫秒时间内最多可以生成64个UUID</li>
</ul>
<h2 id="SnowFlake算法优化"><a href="#SnowFlake算法优化" class="headerlink" title="SnowFlake算法优化"></a>SnowFlake算法优化</h2><h3 id="目前算法设计缺陷"><a href="#目前算法设计缺陷" class="headerlink" title="目前算法设计缺陷"></a>目前算法设计缺陷</h3><p>在实际服务器运行过程中，尤其在游戏服务器开发期间，大量用户注册，会有瞬间生成大量UUID的需求</p>
<p>之前服务器的做法是：</p>
<pre><code class="hljs cpp"><span class="hljs-comment">//遍历了一圈64个，等下一个毫秒生成</span>
<span class="hljs-keyword">if</span> (m_nGlobalSeq == m_nMliSeq)
&#123;
    <span class="hljs-comment">// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳</span>
    nCurTimestamp = <span class="hljs-built_in">WaitForNextMilli</span>(m_nLastTimestamp);
&#125;

<span class="hljs-comment">/**</span>
<span class="hljs-comment">* 阻塞到下一个毫秒，直到获得新的时间戳</span>
<span class="hljs-comment">*</span>
<span class="hljs-comment">* @param lastTimestamp 上次生成ID的时间截</span>
<span class="hljs-comment">* @return 当前时间戳</span>
<span class="hljs-comment">*/</span>
<span class="hljs-function">UINT64 <span class="hljs-title">WaitForNextMilli</span><span class="hljs-params">(UINT64 lastTimestamp)</span> <span class="hljs-type">const</span></span>
<span class="hljs-function"></span>&#123;
    UINT64 nTimestamp = _GetNowMliTime();
    <span class="hljs-keyword">while</span> (nTimestamp &lt;= lastTimestamp)
    &#123;
        nTimestamp = _GetNowMliTime();
    &#125;
    <span class="hljs-keyword">return</span> nTimestamp;
&#125;
</code></pre>
<p>这里使用while强行等待到下一毫秒，相当于阻塞当前线程，从而成为热点函数，需要去优化</p>
<h3 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h3><ul>
<li>合理分配各字段占用bit（图中已经是调整过的）</li>
<li>将生成uuid单独出一个独立全局Server组件，提供全局唯一UUID服务，这样除去高位39bit外理论上其他bit都可以当作自增位，而且可以提前生成很多uuid放在pool当中，有需要的进程从当中取，可以满足需求，Baidu在github上开源的UUID生成算法就是这样处理的</li>
<li>我们取一个折中方案，只是在server中加一个Pool，存放提前生成好的UUIDs，每次业务端需要UUID的时候首先从Pool中取，如果取不到就走原来的流程</li>
</ul>
<pre><code class="hljs cpp"><span class="hljs-function">UINT64 <span class="hljs-title">GenId</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsEmpty</span>())
    &#123;
        <span class="hljs-comment">//从Pool中取</span>
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">PopFrontElement</span>();
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">NextId</span>();
&#125;</code></pre>

<p>既然存在Pool，那么就需要设计Pool中元素填充方案<br>首先将Pool设定一个合适的固定最大值 const UINT32 UUID_POOL_MAX_SIZE &#x3D; 1 &lt;&lt; 13;   &#x2F;&#x2F;		uuid pool 最大数 8192<br>然后根据当前Pool的状态，来定时填充，每次填充的数量为当前毫秒内所有可以生成的UUID数<br><img src="/:storage%5C1a51b319-5d9b-40f9-a828-cfc88309cea2%5C928daf4a.png" alt="Fill_Pool.png"></p>
<pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uuid_pool_mgr.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uuid_generator.h&quot;</span></span>


<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CUUIDPool::Init</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">FillUuidPool</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CUUIDPool::OnTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span></span>
<span class="hljs-function"></span>&#123;
    EXLOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : &quot;</span> &lt;&lt; nId;
    CUUIDMaker::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">FillPoolWithInMli</span>();
    <span class="hljs-built_in">FillUuidPool</span>();
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CUUIDPool::FillUuidPool</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    EUuidPoolState eUuidDequeState = CUUIDMaker::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">GetUuidDequeState</span>();
    uint32 nUpdateInterval = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">switch</span> (eUuidDequeState)
    &#123;
    <span class="hljs-keyword">case</span> EUuidPoolState_Empty:
        nUpdateInterval = <span class="hljs-number">1</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Not_Full_0_30_Per:
        nUpdateInterval = <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Not_Full_30_70_Per:
        nUpdateInterval = <span class="hljs-number">3</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Not_Full_70_100_Per:
        nUpdateInterval = <span class="hljs-number">4</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Full:
        nUpdateInterval = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        nUpdateInterval = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    &#125;

    EXLOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : &quot;</span> &lt;&lt; eUuidDequeState;
    <span class="hljs-built_in">SetTimer</span>(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);
&#125;


<span class="hljs-keyword">enum</span> <span class="hljs-title class_">EUuidPoolState</span>
&#123;
    EUuidPoolState_Empty				= <span class="hljs-number">1</span>,
    EUuidPoolState_Not_Full_0_30_Per	= <span class="hljs-number">2</span>,
    EUuidPoolState_Not_Full_30_70_Per	= <span class="hljs-number">3</span>,
    EUuidPoolState_Not_Full_70_100_Per	= <span class="hljs-number">4</span>,
    EUuidPoolState_Full					= <span class="hljs-number">5</span>,
&#125;;

<span class="hljs-comment">//uuid_generator.h</span>
<span class="hljs-comment">//将当前毫秒内的UUID全部生成并存到Pool中</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FillPoolWithInMli</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    EUuidPoolState nCurState = <span class="hljs-built_in">GetUuidDequeState</span>();
    AtomicUInt64 nCurTimestamp = _GetNowMliTime();
    <span class="hljs-keyword">while</span> (nCurState != EUuidPoolState_Full)
    &#123;
        UINT64 nNextUUId = <span class="hljs-built_in">NextId</span>(<span class="hljs-literal">false</span>);
        <span class="hljs-keyword">if</span> (nNextUUId == <span class="hljs-number">0</span>)
        &#123;
            <span class="hljs-keyword">break</span>;
        &#125;

        <span class="hljs-built_in">PushBackElement</span>(nNextUUId);

        <span class="hljs-keyword">if</span> (nCurTimestamp != _GetNowMliTime())
        &#123;
            <span class="hljs-keyword">break</span>;
        &#125;
    &#125;
&#125;
</code></pre>

<h2 id="是否这样就完美了呢？"><a href="#是否这样就完美了呢？" class="headerlink" title="是否这样就完美了呢？"></a>是否这样就完美了呢？</h2><p>并没有呢！！！<br>这个算法强制依赖时间递增，如果时间回拨怎么办？<br>目前的做法是直接throw new exception<br>分析时间回拨产生原因<br>第一：人物操作，在真实环境一般不会有那个傻逼干这种事情，所以基本可以排除。<br>第二：由于有些业务等需要，机器需要同步时间服务器（在这个过程中可能会存在时间回拨，查了下我们服务器一般在10ms以内（2小时同步一次））。 Ntp过程可能产生时间回拨。<br>第三：QA和策划测试过程中有需求怎么办？<br>解决办法：</p>
<ol>
<li>将uuid_generation独立出来给其他server提供服务</li>
<li>当回拨时间小于XXms，就等时间追上来之后继续生成。 (XXms对业务没有什么影响)</li>
<li>当时间大于XXms时间我们通过更换AppId位来来解决回拨问题。</li>
</ol>
<h2 id="Talk-is-cheap-show-you-the-code"><a href="#Talk-is-cheap-show-you-the-code" class="headerlink" title="Talk is cheap, show you the code"></a>Talk is cheap, show you the code</h2><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __UUID_GENERATOR_H__</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> __UUID_GENERATOR_H__</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gnsingleton.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gntype.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gnpipe.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gntime.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;noncopy.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gnserverid.h&quot;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;mutex&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;atomic&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span></span>

<span class="hljs-keyword">enum</span> <span class="hljs-title class_">EUuidPoolState</span>
&#123;
    EUuidPoolState_Empty				= <span class="hljs-number">1</span>,
    EUuidPoolState_Not_Full_0_30_Per	= <span class="hljs-number">2</span>,
    EUuidPoolState_Not_Full_30_70_Per	= <span class="hljs-number">3</span>,
    EUuidPoolState_Not_Full_70_100_Per	= <span class="hljs-number">4</span>,
    EUuidPoolState_Full					= <span class="hljs-number">5</span>,
&#125;;

<span class="hljs-comment">//#define SNOWFLAKE_ID_MAKER_NO_LOCK</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CSnowflakeIdMaker</span> : <span class="hljs-keyword">private</span> CNoncopy
&#123;
<span class="hljs-keyword">public</span>:
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>
    <span class="hljs-keyword">typedef</span> std::atomic&lt;UINT32&gt; AtomicUInt;
    <span class="hljs-keyword">typedef</span> std::atomic&lt;UINT64&gt; AtomicUInt64;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
    <span class="hljs-keyword">typedef</span> UINT32 AtomicUInt;
    <span class="hljs-keyword">typedef</span> UINT64 AtomicUInt64;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

    <span class="hljs-type">const</span> UINT32 UUID_POOL_MAX_SIZE = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;   <span class="hljs-comment">//		uuid pool 最大数 8192</span>
    <span class="hljs-type">const</span> UINT64 START_EPOCH			= <span class="hljs-number">1541001600000LL</span>;		<span class="hljs-comment">//开始时间截 (2018-11-01 00:00:00.000)，修改此时间可调整可用时长</span>
                               
    <span class="hljs-type">const</span> UINT32 A_TIMESTAMP_BITS		= <span class="hljs-number">39</span>;					<span class="hljs-comment">//时间戳所占的位数</span>
    <span class="hljs-type">const</span> UINT32 B_PLATFORM_BITS		= <span class="hljs-number">3</span>;					<span class="hljs-comment">//平台id所占的位数</span>
    <span class="hljs-type">const</span> UINT32 C_AREA_BITS			= <span class="hljs-number">11</span>;					<span class="hljs-comment">//区服id所占的位</span>
    <span class="hljs-type">const</span> UINT32 D_APP_ID_BITS			= <span class="hljs-number">5</span>;					<span class="hljs-comment">//app id所占的位数</span>
    <span class="hljs-type">const</span> UINT32 E_INCR_SEQUENCE_BITS	= <span class="hljs-number">6</span>;				    <span class="hljs-comment">//自增序列所占的位数</span>

    <span class="hljs-type">const</span> UINT32 APP_ID_SHIFT			= E_INCR_SEQUENCE_BITS;		<span class="hljs-comment">//APPID向左移位数</span>
    <span class="hljs-type">const</span> UINT32 AREA_ID_SHIFT			= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS;											<span class="hljs-comment">//小区id向左移位数</span>
    <span class="hljs-type">const</span> UINT32 PLATFORM_ID_SHIFT		= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS;						<span class="hljs-comment">//大区id向左移位数</span>
    <span class="hljs-type">const</span> UINT32 TIME_STAMP_SHIFT		= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS + B_PLATFORM_BITS;		<span class="hljs-comment">//时间戳向左移位数</span>
    <span class="hljs-type">const</span> UINT32 SEQUENCE_MASK			= (<span class="hljs-number">1</span> &lt;&lt; E_INCR_SEQUENCE_BITS) - <span class="hljs-number">1</span>;												<span class="hljs-comment">//生成序列的掩码</span>


    <span class="hljs-built_in">CSnowflakeIdMaker</span>() : <span class="hljs-built_in">m_nPlatformId</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_nAreaId</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_nGlobalSeq</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">m_nLastTimestamp</span>(<span class="hljs-number">0</span>) &#123;&#125;

    <span class="hljs-built_in">CSnowflakeIdMaker</span>(<span class="hljs-type">const</span> UINT32 nPlatId, <span class="hljs-type">const</span> UINT32 nAreaId, <span class="hljs-type">const</span> UINT32 nAppId)
    &#123;
        <span class="hljs-built_in">Init</span>(nPlatId, nAreaId, nAppId);
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT32 nPlatId, <span class="hljs-type">const</span> UINT32 nAreaId, <span class="hljs-type">const</span> UINT32 nAppId)</span></span>
<span class="hljs-function">    </span>&#123;
        m_nPlatformId = nPlatId;
        m_nAreaId = nAreaId;
        m_nAppId = nAppId;
    &#125;

    <span class="hljs-function">UINT64 <span class="hljs-title">GenId</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">IsEmpty</span>())
        &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">PopFrontElement</span>();
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">NextId</span>();
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 获得下一个ID (该方法是线程安全的)</span>
<span class="hljs-comment">    * @param  bCanBlock 参数指定当前函数是否可以阻塞, 默认为true</span>
<span class="hljs-comment">    * @return SnowflakeId</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function">UINT64 <span class="hljs-title">NextId</span><span class="hljs-params">(<span class="hljs-type">bool</span> bCanBlock = <span class="hljs-literal">true</span>)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span>  std;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>
        <span class="hljs-type">static</span> AtomicUInt64 nCurTimestamp&#123; <span class="hljs-number">0</span> &#125;;
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;
        AtomicUInt64 nCurTimestamp&#123; <span class="hljs-number">0</span> &#125;;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

        nCurTimestamp = _GetNowMliTime();

        <span class="hljs-comment">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span>
        <span class="hljs-keyword">if</span> (nCurTimestamp &lt; m_nLastTimestamp)
        &#123;
            std::ostringstream oSS;
            oSS &lt;&lt; <span class="hljs-string">&quot;clock moved backwards.  Refusing to generate id for &quot;</span> &lt;&lt; m_nLastTimestamp - nCurTimestamp &lt;&lt; <span class="hljs-string">&quot; milliseconds&quot;</span>;
            <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">exception</span>(std::<span class="hljs-built_in">runtime_error</span>(oSS.<span class="hljs-built_in">str</span>()));
        &#125;

        m_nGlobalSeq = (m_nGlobalSeq + <span class="hljs-number">1</span>) &amp; SEQUENCE_MASK;

        <span class="hljs-comment">// 为了使id递增+1均匀分布，这里seq跨毫秒也不清0</span>
        <span class="hljs-keyword">if</span> (m_nLastTimestamp == nCurTimestamp)
        &#123;
            <span class="hljs-comment">//遍历了一圈64个，等下一个毫秒生成</span>
            <span class="hljs-keyword">if</span> (m_nGlobalSeq == m_nMliSeq)
            &#123;
                <span class="hljs-keyword">if</span> (bCanBlock)
                &#123;
                    <span class="hljs-comment">// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳</span>
                    nCurTimestamp = <span class="hljs-built_in">WaitForNextMilli</span>(m_nLastTimestamp);
                &#125;
                <span class="hljs-keyword">else</span>
                &#123;
                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
                &#125;
            &#125;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;	
            m_nMliSeq = m_nGlobalSeq;
        &#125;

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>
        m_nLastTimestamp = nCurTimestamp.<span class="hljs-built_in">load</span>();
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
        m_nLastTimestamp = nCurTimestamp;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

        <span class="hljs-comment">// 移位并通过或运算拼到一起组成64位的ID</span>
        <span class="hljs-keyword">return</span> ((nCurTimestamp - START_EPOCH) &lt;&lt; TIME_STAMP_SHIFT)
            | (m_nPlatformId &lt;&lt; PLATFORM_ID_SHIFT)
            | (m_nAreaId &lt;&lt; AREA_ID_SHIFT)
            | (m_nAppId &lt;&lt; APP_ID_SHIFT)
            | (m_nGlobalSeq);
    &#125;

    <span class="hljs-function">EUuidPoolState <span class="hljs-title">GetUuidDequeState</span><span class="hljs-params">()</span> </span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">if</span> (m_deUuidPool.<span class="hljs-built_in">empty</span>())
        &#123;
            <span class="hljs-keyword">return</span> EUuidPoolState_Empty;
        &#125;

        <span class="hljs-type">size_t</span> nCurPoolSize = m_deUuidPool.<span class="hljs-built_in">size</span>();
        <span class="hljs-keyword">if</span> (nCurPoolSize &gt;= UUID_POOL_MAX_SIZE)
        &#123;
            <span class="hljs-keyword">return</span> EUuidPoolState_Full;
        &#125;

        uint32 nCurPercent = nCurPoolSize * <span class="hljs-number">100</span> / UUID_POOL_MAX_SIZE;
        <span class="hljs-keyword">if</span> (nCurPercent &lt; <span class="hljs-number">30</span>)
        &#123;
            <span class="hljs-keyword">return</span> EUuidPoolState_Not_Full_0_30_Per;
        &#125;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nCurPercent &lt; <span class="hljs-number">70</span>)
        &#123;
            <span class="hljs-keyword">return</span> EUuidPoolState_Not_Full_30_70_Per;
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-keyword">return</span> EUuidPoolState_Not_Full_70_100_Per;
        &#125;

        <span class="hljs-keyword">return</span> EUuidPoolState_Full;
    &#125; 

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FillPoolWithInMli</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        EUuidPoolState nCurState = <span class="hljs-built_in">GetUuidDequeState</span>();
        AtomicUInt64 nCurTimestamp = _GetNowMliTime();
        <span class="hljs-keyword">while</span> (nCurState != EUuidPoolState_Full)
        &#123;
            UINT64 nNextUUId = <span class="hljs-built_in">NextId</span>(<span class="hljs-literal">false</span>);
            <span class="hljs-keyword">if</span> (nNextUUId == <span class="hljs-number">0</span>)
            &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
            
            <span class="hljs-built_in">PushBackElement</span>(nNextUUId);

            <span class="hljs-keyword">if</span> (nCurTimestamp != _GetNowMliTime())
            &#123;
                <span class="hljs-keyword">break</span>;
            &#125;
        &#125;
    &#125;

<span class="hljs-keyword">protected</span>:

    <span class="hljs-comment">//判断pool是否为空</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">IsEmpty</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> m_deUuidPool.<span class="hljs-built_in">empty</span>();
    &#125;

    <span class="hljs-comment">//返回pool队列中front 元素</span>
    <span class="hljs-function">UINT64 <span class="hljs-title">PopFrontElement</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>
        
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

        UINT64 nFrontElement = m_deUuidPool.<span class="hljs-built_in">front</span>();
        m_deUuidPool.<span class="hljs-built_in">pop_front</span>();
        <span class="hljs-keyword">return</span> nFrontElement;
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PushBackElement</span><span class="hljs-params">(UINT64 nNextUUId)</span></span>
<span class="hljs-function">    </span>&#123;
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
        m_deUuidPool.<span class="hljs-built_in">push_back</span>(nNextUUId);
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 返回以毫秒为单位的当前时间</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * @return 当前时间(毫秒)</span>
<span class="hljs-comment">    */</span>
    UINT64 _GetNowMliTime() <span class="hljs-type">const</span>
    &#123;
        <span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>)
        &#123;
            Storm::CSTDateTime oDateTime;
            oDateTime.<span class="hljs-built_in">Now</span>();
            <span class="hljs-keyword">return</span> oDateTime.<span class="hljs-built_in">EpochMilliSecs</span>();
        &#125;
        <span class="hljs-keyword">else</span>
        &#123;
            <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;
            <span class="hljs-keyword">auto</span> nTimeNow = chrono::system_clock::<span class="hljs-built_in">now</span>();
            <span class="hljs-keyword">auto</span> nDurationInMs = chrono::<span class="hljs-built_in">duration_cast</span>&lt;chrono::milliseconds&gt;(nTimeNow.<span class="hljs-built_in">time_since_epoch</span>());
            <span class="hljs-keyword">return</span> nDurationInMs.<span class="hljs-built_in">count</span>();
        &#125;
    &#125;

    <span class="hljs-comment">/**</span>
<span class="hljs-comment">    * 阻塞到下一个毫秒，直到获得新的时间戳</span>
<span class="hljs-comment">    *</span>
<span class="hljs-comment">    * @param lastTimestamp 上次生成ID的时间截</span>
<span class="hljs-comment">    * @return 当前时间戳</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-function">UINT64 <span class="hljs-title">WaitForNextMilli</span><span class="hljs-params">(UINT64 lastTimestamp)</span> <span class="hljs-type">const</span></span>
<span class="hljs-function">    </span>&#123;
        UINT64 nTimestamp = _GetNowMliTime();
        <span class="hljs-keyword">while</span> (nTimestamp &lt;= lastTimestamp)
        &#123;
            nTimestamp = _GetNowMliTime();
        &#125;
        <span class="hljs-keyword">return</span> nTimestamp;
    &#125;

<span class="hljs-keyword">private</span>:

<span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>
    std::mutex		m_oMutex;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

    UINT32			m_nPlatformId = <span class="hljs-number">0</span>;		<span class="hljs-comment">//平台id</span>
    UINT32			m_nAreaId = <span class="hljs-number">0</span>;			<span class="hljs-comment">//区服id</span>
    UINT32			m_nAppId = <span class="hljs-number">0</span>;			<span class="hljs-comment">//Appid</span>
    AtomicUInt		m_nGlobalSeq&#123; <span class="hljs-number">0</span> &#125;;		<span class="hljs-comment">//全局序列</span>
    AtomicUInt		m_nMliSeq&#123; <span class="hljs-number">0</span> &#125;;			<span class="hljs-comment">//每毫秒序列</span>
    AtomicUInt64	m_nLastTimestamp&#123; <span class="hljs-number">0</span> &#125;;	<span class="hljs-comment">//上次生成ID的时间截</span>
    std::deque&lt;UINT64&gt; m_deUuidPool;			<span class="hljs-comment">//uuid池 用于存放预生成uuids</span>
&#125;;



<span class="hljs-comment">/************************************************************************/</span>
<span class="hljs-comment">/* 负责生成全局唯一id                                                */</span>
<span class="hljs-comment">/************************************************************************/</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">CUUIDMaker</span> : <span class="hljs-keyword">public</span> Storm::TSingleton&lt;CUUIDMaker&gt;
&#123;
    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Storm</span>::TSingleton&lt;CUUIDMaker&gt;;
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT32 nParaA, <span class="hljs-type">const</span> UINT32 nParaB, <span class="hljs-type">const</span> UINT32 nParaC)</span></span>
<span class="hljs-function">    </span>&#123;
        m_oIdMaker.<span class="hljs-built_in">Init</span>(nParaA, nParaB, nParaC);
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;
    
    <span class="hljs-comment">/// init with pipeid</span>
    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Init</span><span class="hljs-params">(<span class="hljs-type">const</span> UINT64 nPipeId)</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> Storm;
        <span class="hljs-function">CServerID <span class="hljs-title">oServID</span><span class="hljs-params">(nPipeId)</span></span>;
        m_oIdMaker.<span class="hljs-built_in">Init</span>(oServID.<span class="hljs-built_in">GetPlat</span>(), oServID.<span class="hljs-built_in">GetArea</span>(), oServID.<span class="hljs-built_in">GetIndex</span>());
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    &#125;

    <span class="hljs-function">UINT64 <span class="hljs-title">GenId</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> m_oIdMaker.<span class="hljs-built_in">GenId</span>();
    &#125;

    <span class="hljs-function">EUuidPoolState <span class="hljs-title">GetUuidDequeState</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        <span class="hljs-keyword">return</span> m_oIdMaker.<span class="hljs-built_in">GetUuidDequeState</span>();
    &#125;

    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">FillPoolWithInMli</span><span class="hljs-params">()</span></span>
<span class="hljs-function">    </span>&#123;
        m_oIdMaker.<span class="hljs-built_in">FillPoolWithInMli</span>();
    &#125;

    <span class="hljs-function">UINT64 <span class="hljs-title">GetCompareIdFromTime</span><span class="hljs-params">(UINT32 nTimeVal)</span></span>;

    <span class="hljs-function">UINT64 <span class="hljs-title">GetTimeAddVal</span><span class="hljs-params">(UINT32 nTimeVal)</span></span>;

    <span class="hljs-function">UINT32 <span class="hljs-title">GetTimeValFromUuid</span><span class="hljs-params">(UINT64 nUuid)</span></span>;

<span class="hljs-keyword">private</span>:
    CSnowflakeIdMaker	m_oIdMaker;
&#125;;

<span class="hljs-meta">#<span class="hljs-keyword">define</span>  GEN_GLOBAL_UUID()  CUUIDMaker::Instance()-&gt;GenId()</span>


<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>


<span class="hljs-comment">//gameserver </span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uuid_pool_mgr.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;uuid_generator.h&quot;</span></span>


<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">CUUIDPool::Init</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    <span class="hljs-built_in">FillUuidPool</span>();
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CUUIDPool::OnTimer</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> nId)</span></span>
<span class="hljs-function"></span>&#123;
    EXLOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : &quot;</span> &lt;&lt; nId;
    CUUIDMaker::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">FillPoolWithInMli</span>();
    <span class="hljs-built_in">FillUuidPool</span>();
&#125;

<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CUUIDPool::FillUuidPool</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
    EUuidPoolState eUuidDequeState = CUUIDMaker::<span class="hljs-built_in">Instance</span>()-&gt;<span class="hljs-built_in">GetUuidDequeState</span>();
    uint32 nUpdateInterval = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
    <span class="hljs-keyword">switch</span> (eUuidDequeState)
    &#123;
    <span class="hljs-keyword">case</span> EUuidPoolState_Empty:
        nUpdateInterval = <span class="hljs-number">1</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Not_Full_0_30_Per:
        nUpdateInterval = <span class="hljs-number">2</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Not_Full_30_70_Per:
        nUpdateInterval = <span class="hljs-number">3</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Not_Full_70_100_Per:
        nUpdateInterval = <span class="hljs-number">4</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">case</span> EUuidPoolState_Full:
        nUpdateInterval = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    <span class="hljs-keyword">default</span>:
        nUpdateInterval = <span class="hljs-number">5</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;
        <span class="hljs-keyword">break</span>;
    &#125;

    EXLOG_DEBUG &lt;&lt; <span class="hljs-string">&quot;[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : &quot;</span> &lt;&lt; eUuidDequeState;
    <span class="hljs-built_in">SetTimer</span>(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);
&#125;
</code></pre>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://juejin.im/post/5a7f9176f265da4e721c73a8">分布式唯一id：snowflake算法思考 - 掘金</a><br><a target="_blank" rel="noopener" href="https://tech.meituan.com/MT_Leaf.html">https://tech.meituan.com/2017/04/21/mt-leaf.html</a><br><a target="_blank" rel="noopener" href="https://github.com/baidu/uid-generator">GitHub - baidu&#x2F;uid-generator: UniqueID generator</a></p>

            </div>
        </article>
    </div>
    <br>
    
        <div class="next-prev-post">
            
                <div class="prev-post">
                    <div class="prev gt-c-content-color-first">
                        上一篇：<a href="/2020/01/23/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%97%B6%E9%97%B4%E8%BD%AETimer%E5%AE%9A%E6%97%B6%E5%99%A8/" 
                            class="post-title gt-a-link">Timer 定时器技术分享</a>
                    </div>
                </div>
            
            
                <div class="next-post">
                    <div class="next gt-c-content-color-first">
                        下一篇：<a href="/2020/01/23/linux%20%E7%B3%BB%E7%BB%9F%E4%BF%A1%E5%8F%B7%E5%92%8C%E4%B8%AD%E6%96%AD%E5%B8%B8%E8%AF%86/" 
                            class="post-title gt-a-link">linux 系统信号和中断常识</a>
                    </div>
                </div>
            
        </div>
    
    

    

    
</div>

                <div class="site-footer gt-c-content-color-first">
    <div class="footer-main">
        <!-- 建议保留版权信息或者添加主题信息到友链，感谢您的理解 -->
        <!-- 文件位置：layout/_includes/footer.ejs -->
        <span style="text-align: right; float: right;">Theme <a 
            href="https://github.com/renbaoshuo/hexo-theme-pure" target="_blank">Pure</a> | Powered by <a 
            href="https://hexo.io" target="_blank">Hexo</a></span>
        <span style="text-align: left;">Footer HTML
</span>
    </div>
</div>

            </div>
        </div>
    </body>
</html>