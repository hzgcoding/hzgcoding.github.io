{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/pure/source/styles/main.less","path":"styles/main.less","modified":0,"renderable":1}],"Cache":[{"_id":"source/README.md","hash":"8ad2600a1c7eeb326e3ed6f3bdd278a7620aea56","modified":1679919470712},{"_id":"source/_posts/Flag.md","hash":"ecb5073d27f1f9e6fab01aef9b120d1d15bc1408","modified":1679918530278},{"_id":"source/_posts/Linux shell语言——dash和bash.md","hash":"5d94e560b81716d096a23b3872025e8dc7f73f82","modified":1679918536293},{"_id":"source/_posts/Redis-Guide.md","hash":"97f5d31da990069aa9f723b585aee6c929ab5269","modified":1679918547965},{"_id":"source/_posts/linux fork函数详解.md","hash":"481d70fb1b0541d0e2dd45b78b5296f79bc16306","modified":1679918533214},{"_id":"source/_posts/TCP 三次握手和四次挥手.md","hash":"f9cd5d90a61295141f79cd98211438cb0263ed15","modified":1679918550598},{"_id":"source/_posts/linux 内核RingBuffer实现.md","hash":"72ed14f13f1f4b59c64872a3893d09ef8a8e154f","modified":1679918539308},{"_id":"source/_posts/linux 安装指定版本MySql.md","hash":"1bf12052cc079ff4023b22cebebfd9cee5a96e43","modified":1679918542316},{"_id":"source/_posts/linux 系统信号和中断常识.md","hash":"e596d1589fbf6cf0c4056c4dc6b127b240276571","modified":1679918545198},{"_id":"source/_posts/全局唯一ID生成算法优化.md","hash":"39011fa77265f9efc975259b082cd6a457e1289a","modified":1679918553453},{"_id":"source/_posts/单生产者单消费者环形缓冲.md","hash":"0a51917d49ac977e1530b077acc65ee754566972","modified":1679918556030},{"_id":"source/_posts/批量换行符转换CRLF到LF.md","hash":"28292b28b775a6d0d30d146376b0c91cda2cbba7","modified":1679918561750},{"_id":"source/_posts/各类APP排行榜实现.md","hash":"7bced3b33cc24ce6a530a9cfa7653d7b8d0c046f","modified":1679918559051},{"_id":"source/_posts/深入浅出时间轮Timer定时器.md","hash":"589b4771ee7c909a387992c330e3ad94db75a143","modified":1679918564256},{"_id":"source/_posts/网易互娱面试总结.md","hash":"bdede83ab9208c315cdc07e6652a44f6ce0d0424","modified":1679918567509},{"_id":"source/friends/index.md","hash":"88df9e3b90dccbbfe4bb2a163ff8c04eddaa1830","modified":1679916890517},{"_id":"source/about/index.md","hash":"bb74288a72cbfc401ef74fb82fd194ae6764553a","modified":1679917473408},{"_id":"source/tags/index.md","hash":"c8c5ba939e8cede9a95d3e7e634d45d8dc77feb2","modified":1679916928529},{"_id":"source/timeline/index.md","hash":"c5f5d6b3c44c2d1f706840273e4ea46e6dc75356","modified":1679918625906},{"_id":"themes/pure/scripts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1679921607068},{"_id":"themes/pure/source/scripts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1679921607069},{"_id":"themes/pure/source/styles/_includes/about.less","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1679921607069},{"_id":"themes/pure/.gitignore","hash":"0b85528e0070cf60cc5fb203d991e32dd1510115","modified":1679921607059},{"_id":"themes/pure/LICENSE","hash":"a2f9ffbf32eeb6284afa81bc4fb4c27b80d044e9","modified":1679921607060},{"_id":"themes/pure/README.md","hash":"9c41389c2083b277531f33f1f6450f0223a787e5","modified":1679921607060},{"_id":"themes/pure/README.zh_CN.md","hash":"029bb0af13ff37346a37d4891f507d7d5b9525cd","modified":1679921607061},{"_id":"themes/pure/_config.example.yml","hash":"65a0612b8f4dedd05499604a7c0fde5b941decbc","modified":1679921607061},{"_id":"themes/pure/package-lock.json","hash":"66b33c2041fce8dcf99871eb106cb15ef776fef2","modified":1679921607067},{"_id":"themes/pure/package.json","hash":"5eeff44b0525c8d3ae0bb570f452b8ff31f61571","modified":1679921607068},{"_id":"themes/pure/layout/about.ejs","hash":"eae118ff9527881e57828df2e411c93c8c49194f","modified":1679921607064},{"_id":"themes/pure/layout/archive.ejs","hash":"d7463cb3ca32cee213f1ef2222ac6e49dc368874","modified":1679921607064},{"_id":"themes/pure/layout/index.ejs","hash":"a5f55ba35ea4cff44af00e0845961ceec537cf75","modified":1679921607065},{"_id":"themes/pure/layout/friends.ejs","hash":"102e233c3c5688e85b112c23cf9219b6060c5686","modified":1679921607065},{"_id":"themes/pure/layout/layout.ejs","hash":"49f12a7563ef7319cd22fd926e50c0d5a35e9e90","modified":1679921607065},{"_id":"themes/pure/layout/tags.ejs","hash":"e95d23f0f12af1942c964b51eb8cc5445966477a","modified":1679921607066},{"_id":"themes/pure/layout/post.ejs","hash":"4ef592e49f916fd22ff38848829fb043694dfb3b","modified":1679921607066},{"_id":"themes/pure/layout/tag.ejs","hash":"276f5864004ffb094c4c06c0de5e7f561f857d6e","modified":1679921607066},{"_id":"themes/pure/scripts/check-updates.js","hash":"4862aa047e81be93eeef4dbe3581f8c611eefeb6","modified":1679921607068},{"_id":"themes/pure/source/.nojekyll","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1679921607069},{"_id":"themes/pure/layout/_includes/disqus.ejs","hash":"2906c183e30fd857f93bd37d2ca941bb0e474da9","modified":1679921607063},{"_id":"themes/pure/layout/_includes/footer.ejs","hash":"bd630dc80b6a8ba93daaca8f72e5590e440081b6","modified":1679921607063},{"_id":"themes/pure/layout/_includes/header.ejs","hash":"1cfd76504504ad86abee25997cf867a91fc0df69","modified":1679921607064},{"_id":"themes/pure/layout/_includes/gitalk.ejs","hash":"8e650eee7896566b3f58e4f935f0abe00557b52a","modified":1679921607063},{"_id":"themes/pure/layout/_includes/valine.ejs","hash":"e763c32d2f7e0038b79dec36acc2ec4b1451d57f","modified":1679921607064},{"_id":"themes/pure/layout/_includes/head.ejs","hash":"43d07de90a67661870777b8a02596327a32be8a8","modified":1679921607063},{"_id":"themes/pure/source/styles/main.less","hash":"7fe0ccb8d0afe7ea562d972d425ee29128b48a88","modified":1679921607073},{"_id":"themes/pure/source/styles/_includes/archive.less","hash":"4c4c5b2a932205ab28989ea52e7bea93e79409dc","modified":1679921607070},{"_id":"themes/pure/source/styles/_includes/disqus.less","hash":"109a52e05bb4ab8326ea6efad28e480a34f548d1","modified":1679921607070},{"_id":"themes/pure/source/styles/_includes/footer.less","hash":"a90301e223b5963a305ce053390c264648268b01","modified":1679921607070},{"_id":"themes/pure/source/styles/_includes/friends.less","hash":"5626f42a8585e59bcfcbb7915342e6344a06f28d","modified":1679921607070},{"_id":"themes/pure/source/styles/_includes/header.less","hash":"1902e743c4d8c89d465e0ba67b79f44dd18dabf8","modified":1679921607071},{"_id":"themes/pure/source/styles/_includes/gitalk.less","hash":"1a34e5688ed6f92aa9053891b2607dafb391f037","modified":1679921607071},{"_id":"themes/pure/source/styles/_includes/highlight.less","hash":"d3731838d2a58b6dbdd5e2cd5b6c817ada0470a9","modified":1679921607071},{"_id":"themes/pure/source/styles/_includes/pagination.less","hash":"fc0bfc2ba8615fe03d337dc7413916edb4a706ac","modified":1679921607072},{"_id":"themes/pure/source/styles/_includes/post-list.less","hash":"1ab04a76be067f7f81aaaa55c3f3f5bb05a3bc3a","modified":1679921607072},{"_id":"themes/pure/source/styles/_includes/post.less","hash":"067fa5bc46f0ad29132e333f1a1c2f8bea3e3d96","modified":1679921607072},{"_id":"themes/pure/source/styles/_includes/tag.less","hash":"85181c010ddfa0111394af2517e5e7c6973dc934","modified":1679921607072},{"_id":"themes/pure/source/styles/_includes/tags.less","hash":"3fa503a78e95d78c6272ec4e4595763217bebb8a","modified":1679921607073},{"_id":"themes/pure/source/styles/_includes/valine.less","hash":"c73272a2b3d8e04d6741eed9989eeb0204e36667","modified":1679921607073},{"_id":"themes/pure/_config.yml","hash":"926fb8f3134049b2766a7cb18ae301906170c6db","modified":1679970713334},{"_id":"public/atom.xml","hash":"1702650001660655ed65f95caf083e7ce138ea7f","modified":1679970957217},{"_id":"public/friends/index.html","hash":"f8d79f018001560319670a37f6ebbfdbf4df9579","modified":1679970957217},{"_id":"public/about/index.html","hash":"c4ef1de28f7b65cd3b0e922588ca4f26bad28c2e","modified":1679970957217},{"_id":"public/README.html","hash":"8e1259138240a5f8778125a89aae8ea96fafb6f0","modified":1679970957217},{"_id":"public/tags/index.html","hash":"133c503f465810e7f20cc73ad72cc018d9922a0d","modified":1679970957217},{"_id":"public/timeline/index.html","hash":"3734535d6888dc70f601b5cc489d7da7ce9a8475","modified":1679970957217},{"_id":"public/2020/07/10/Redis-Guide/index.html","hash":"4d09756d63dcab0e1f211b60f5b5d499e0c3095e","modified":1679970957217},{"_id":"public/2020/02/12/批量换行符转换CRLF到LF/index.html","hash":"7be8f786e64683673f087b6b496f8e35c106a4bd","modified":1679970957217},{"_id":"public/2020/02/05/Flag/index.html","hash":"d91b33ae3c93b6ee08193c3b9ce0b08fc00f36f6","modified":1679970957217},{"_id":"public/2020/01/23/Linux shell语言——dash和bash/index.html","hash":"6a176d339452ae3fac273df15c959ae743eaf269","modified":1679970957217},{"_id":"public/2020/01/23/单生产者单消费者环形缓冲/index.html","hash":"0886ceaaea395756d9f9ac5a620134c3c52d5b55","modified":1679970957217},{"_id":"public/2020/01/23/linux fork函数详解/index.html","hash":"4eaabeb5df869127fbf3b1784877b956bd00f73e","modified":1679970957217},{"_id":"public/2020/01/23/各类APP排行榜实现/index.html","hash":"84ff2f5ad24c8aded72ffb871230baa963d2e92c","modified":1679970957217},{"_id":"public/2020/01/23/深入浅出时间轮Timer定时器/index.html","hash":"3000e3fc235c13956a03a6e81181fabd5c04c04a","modified":1679970957217},{"_id":"public/2020/01/23/全局唯一ID生成算法优化/index.html","hash":"7e05de701b6ee1c8702bce93929f838827402f62","modified":1679970957217},{"_id":"public/2020/01/23/linux 系统信号和中断常识/index.html","hash":"138ff13a0ae6094480065c7a48c25047f6d16a7a","modified":1679970957217},{"_id":"public/2020/01/23/linux 安装指定版本MySql/index.html","hash":"17528d300463e9559da541b7d0263c75a44b8046","modified":1679970957217},{"_id":"public/2020/01/23/TCP 三次握手和四次挥手/index.html","hash":"e999ed1b2d1dd6bde47485402e94f26b26d44df8","modified":1679970957217},{"_id":"public/2020/01/23/网易互娱面试总结/index.html","hash":"647fae979075478e2e1fa9f9fc61a0c0d84fa462","modified":1679970957217},{"_id":"public/2020/01/22/linux 内核RingBuffer实现/index.html","hash":"cb9024e432842334174926e0b5ea2a44f333fff5","modified":1679970957217},{"_id":"public/archives/index.html","hash":"6afbf8b8e16a57ff29a9bece1cc8466b963dc4fa","modified":1679970957217},{"_id":"public/archives/page/2/index.html","hash":"c575035ca3645a74e542c8a4639e2faddd4f4836","modified":1679970957217},{"_id":"public/archives/2020/index.html","hash":"da1ca6b28c8e5307582af2f769c9ae798a54dda1","modified":1679970957217},{"_id":"public/archives/2020/page/2/index.html","hash":"097d7e280c58be170756b504415a70c9cc30da1c","modified":1679970957217},{"_id":"public/archives/2020/01/index.html","hash":"6bbb3cfd8774a22399aa8b133117567f54ce0b8b","modified":1679970957217},{"_id":"public/archives/2020/01/page/2/index.html","hash":"eefc858d032847659e5306fd14801c389c3a139a","modified":1679970957217},{"_id":"public/archives/2020/02/index.html","hash":"cebf1e7a653c6e5de36e0ce0543f09d6a59a73e6","modified":1679970957217},{"_id":"public/archives/2020/07/index.html","hash":"52703403c3719c329c57e8af02e41b016eb900fb","modified":1679970957217},{"_id":"public/categories/emotion/index.html","hash":"630a9131260d81eeb3e91c89fc4a8e450324e08b","modified":1679970957217},{"_id":"public/categories/Shell/index.html","hash":"43d65c536441b802da4bc19b3afc7a732d62723c","modified":1679970957217},{"_id":"public/categories/C-C/index.html","hash":"a1cf847ded844f1ac6cf2670a362f434cc6b20f6","modified":1679970957217},{"_id":"public/categories/网络/index.html","hash":"c3c6d66f135aecc097b071bcba23c2c1feb68957","modified":1679970957217},{"_id":"public/categories/Mysql/index.html","hash":"3fe9b1910e7e3f5b6bcda649d4f17fec45dc88fb","modified":1679970957217},{"_id":"public/categories/Game/index.html","hash":"9f2610f836214126783efe3d564067ec113e47b2","modified":1679970957217},{"_id":"public/categories/Linux/index.html","hash":"e3306e9bb6012db7389b6f7b6c25dea9522b5996","modified":1679970957217},{"_id":"public/categories/Redis/index.html","hash":"157d04e2b176304f713d8d9e19459c7a3af497ff","modified":1679970957217},{"_id":"public/index.html","hash":"7cfbd6feba22adcbad777ad07cf8383bd8365405","modified":1679970957217},{"_id":"public/page/2/index.html","hash":"39d1c5cf9a931412d08dc1ed6844263d69842294","modified":1679970957217},{"_id":"public/tags/flag/index.html","hash":"b3a75c41b406411d8748c665e913d9c63f088294","modified":1679970957217},{"_id":"public/tags/linux/index.html","hash":"94b99007da6b61d15efbec290ef6c229af15c2c3","modified":1679970957217},{"_id":"public/tags/网络/index.html","hash":"5779767488743eaa37a96527584ae6d7362eb243","modified":1679970957217},{"_id":"public/tags/uuid/index.html","hash":"de9024214a51574a3e78537bac7a179ea66ceff7","modified":1679970957217},{"_id":"public/tags/ringbuff/index.html","hash":"617a0d802f9d4ad07491560bddc08a01d67482d1","modified":1679970957217},{"_id":"public/tags/rank/index.html","hash":"ad071f6c80c1f73adc58ca6f3030a6899275d9fa","modified":1679970957217},{"_id":"public/tags/git/index.html","hash":"79251099466ed9c033b6925b50a23976cc876876","modified":1679970957217},{"_id":"public/tags/timer/index.html","hash":"28ce23461c7ffebf87156a9cf37298dee87fa09d","modified":1679970957217},{"_id":"public/tags/面试/index.html","hash":"b56b7b24343f00b5a229803ff2979a91678f3074","modified":1679970957217},{"_id":"public/tags/Redis/index.html","hash":"5a1d97da85a0992a0d1cae3909bdfbb35d8b2de0","modified":1679970957217},{"_id":"public/styles/main.css","hash":"05eaa36af727e83acb65cb91348692c486f26714","modified":1679970957217}],"Category":[{"name":"emotion","_id":"clfrnbzft0004okecf6evg6g8"},{"name":"Shell","_id":"clfrnbzfy000cokec7ju4ack4"},{"name":"C/C++","_id":"clfrnbzg1000iokecfbwnfxs3"},{"name":"网络","_id":"clfrnbzg4000qokec50k23gla"},{"name":"Mysql","_id":"clfrnbzg80011okecdhzm13al"},{"name":"Game","_id":"clfrnbzga0018okecdy9m1v95"},{"name":"Linux","_id":"clfrnbzga001dokec506d8tbu"},{"name":"Redis","_id":"clfrnbzgh001pokecf82f0wsz"}],"Data":[],"Page":[{"title":"friends","date":"2023-03-27T11:34:33.000Z","type":"friends","layout":"friends","_content":"","source":"friends/index.md","raw":"---\ntitle: friends\ndate: 2023-03-27 19:34:33\ntype: \"friends\"\nlayout: \"friends\"\n---\n","updated":"2023-03-27T11:34:33.000Z","path":"friends/index.html","comments":1,"_id":"clfrnbzfn0000okecbvtp0tw0","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"关于","date":"2020-01-23T08:09:55.000Z","_content":"\nHello World, 字节跳动搬砖五年多!","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2020-01-23 16:09:55\n---\n\nHello World, 字节跳动搬砖五年多!","updated":"2020-01-23T08:09:55.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"clfrnbzfv0006okechvbydrac","content":"<p>Hello World, 字节跳动搬砖五年多!</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Hello World, 字节跳动搬砖五年多!</p>\n"},{"title":"tags","date":"2023-03-27T11:35:18.000Z","type":"tags","layout":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-03-27 19:35:18\ntype: \"tags\"\nlayout: \"tags\"\n---\n","updated":"2023-03-27T11:35:18.000Z","path":"tags/index.html","comments":1,"_id":"clfrnbzfw0008okec1o51app6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"胡说八道","date":"2020-01-31T09:42:02.000Z","layout":"timeline","_content":"","source":"timeline/index.md","raw":"---\ntitle: 胡说八道\ndate: 2020-01-31 17:42:02\nlayout: timeline\n---","updated":"2020-01-31T09:42:02.000Z","path":"timeline/index.html","comments":1,"_id":"clfrnbzfx000aokecegs891iz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Flag","date":"2020-02-05T06:54:05.000Z","_content":"\n## **重要的事情说三遍**\n\n- 做完功能要自测！！！\n- 做完功能要自测！！！\n- 做完功能要自测！！！","source":"_posts/Flag.md","raw":"---\ntitle: Flag\ndate: 2020-02-05 14:54:05\ntags: flag\ncategories: emotion\n---\n\n## **重要的事情说三遍**\n\n- 做完功能要自测！！！\n- 做完功能要自测！！！\n- 做完功能要自测！！！","slug":"Flag","published":1,"updated":"2020-02-05T06:54:05.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzfp0001okec4v6ueh1f","content":"<h2 id=\"重要的事情说三遍\"><a href=\"#重要的事情说三遍\" class=\"headerlink\" title=\"重要的事情说三遍\"></a><strong>重要的事情说三遍</strong></h2><ul>\n<li>做完功能要自测！！！</li>\n<li>做完功能要自测！！！</li>\n<li>做完功能要自测！！！</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"重要的事情说三遍\"><a href=\"#重要的事情说三遍\" class=\"headerlink\" title=\"重要的事情说三遍\"></a><strong>重要的事情说三遍</strong></h2><ul>\n<li>做完功能要自测！！！</li>\n<li>做完功能要自测！！！</li>\n<li>做完功能要自测！！！</li>\n</ul>\n"},{"title":"Linux shell语言——dash和bash","date":"2020-01-23T07:13:45.000Z","_content":"\n什么是bash ？\n\nBash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。\n\nGNU/Linux 操作系统中的 /bin/sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。\n\nDebian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。\n\n就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。\n\n要知道自己的/bin/sh指向何种解释器，可以用 ls /bin/sh -al 命令查看：\n```\n$ ls /bin/sh -al\nlrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -> bash\t\n```\n\n以上结果就表示当前系统用的是dash解释器。\n\n切换到bash的方式其实挺简单的，关键是一直没找出这个原因……\n\n修改默认的sh，可以采用命令`sudo dpkg-reconfigure dash`\n\n会出现一个图片状的配置菜单，选no就可以了\n\n再次检查一下， ls /bin/sh -al 发现软链接指向/bin/bash\n\n         lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -> bash\n\n\n\n注：dash 和 bash 语法上的主要的区别有:\n\n1. 定义函数\n\nbash: function在bash中为关键字\n\ndash: dash中没有function这个关键字\n\n2. select var in list; do command; done\n\nbash:支持\n\ndash:不支持, 替代方法:采用while+read+case来实现\n\n3. echo {0..10}\n\nbash:支持{n..m}展开\n\ndash:不支持，替代方法, 采用seq外部命令\n\n4. here string\n\nbash:支持here string\n\ndash:不支持, 替代方法:可采用here documents\n\n5. >&word重定向标准输出和标准错误\n\nbash: 当word为非数字时，>&word变成重定向标准错误和标准输出到文件word\n\ndash: >&word, word不支持非数字, 替代方法: >word 2>&1; 常见用法 >/dev/null 2>&1\n\n6. 数组\n\nbash: 支持数组, bash4支持关联数组\n\ndash: 不支持数组，替代方法, 采用变量名+序号来实现类似的效果\n\n7. 子字符串扩展\n\nbash: 支持${parameter:offset:length},${parameter:offset}\n\ndash: 不支持， 替代方法:采用expr或cut外部命令代替\n\n8. 大小写转换\n\nbash: 支持${parameter^pattern},${parameter^^pattern},${parameter,pattern},${parameter,,pattern}\n\ndash: 不支持，替代方法:采用tr/sed/awk等外部命令转换\n\n9. 进程替换<(command), >(command)\n\nbash: 支持进程替换\n\ndash: 不支持, 替代方法, 通过临时文件中转\n\n10. [ string1 = string2 ] 和 [ string1 == string2 ]\n\nbash: 支持两者\n\ndash: 只支持=\n\n11. [[ 加强版test\n\nbash: 支持[[ ]], 可实现正则匹配等强大功能\n\ndash: 不支持[[ ]], 替代方法，采用外部命令\n\n12. for (( expr1 ; expr2 ; expr3 )) ; do list ; done\n\nbash: 支持C语言格式的for循环\n\ndash: 不支持该格式的for, 替代方法，用while+$((expression))实现\n\n13. let命令和((expression))\n\nbash: 有内置命令let, 也支持((expression))方式\n\ndash: 不支持，替代方法，采用$((expression))或者外部命令做计算\n\n14. $((expression))\n\nbash: 支持id++,id--,++id,--id这样到表达式\n\ndash: 不支持++,--, 替代方法:id+=1,id-=1, id=id+1,id=id-1\n","source":"_posts/Linux shell语言——dash和bash.md","raw":"---\ntitle: Linux shell语言——dash和bash\ndate: 2020-01-23 15:13:45\ntags: linux\ncategories: Shell\n---\n\n什么是bash ？\n\nBash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。\n\nGNU/Linux 操作系统中的 /bin/sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 /bin/sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。\n\nDebian和Ubuntu中，/bin/sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。\n\n就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。\n\n要知道自己的/bin/sh指向何种解释器，可以用 ls /bin/sh -al 命令查看：\n```\n$ ls /bin/sh -al\nlrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -> bash\t\n```\n\n以上结果就表示当前系统用的是dash解释器。\n\n切换到bash的方式其实挺简单的，关键是一直没找出这个原因……\n\n修改默认的sh，可以采用命令`sudo dpkg-reconfigure dash`\n\n会出现一个图片状的配置菜单，选no就可以了\n\n再次检查一下， ls /bin/sh -al 发现软链接指向/bin/bash\n\n         lrwxrwxrwx 1 root root 4 11月 16 15:33 /bin/sh -> bash\n\n\n\n注：dash 和 bash 语法上的主要的区别有:\n\n1. 定义函数\n\nbash: function在bash中为关键字\n\ndash: dash中没有function这个关键字\n\n2. select var in list; do command; done\n\nbash:支持\n\ndash:不支持, 替代方法:采用while+read+case来实现\n\n3. echo {0..10}\n\nbash:支持{n..m}展开\n\ndash:不支持，替代方法, 采用seq外部命令\n\n4. here string\n\nbash:支持here string\n\ndash:不支持, 替代方法:可采用here documents\n\n5. >&word重定向标准输出和标准错误\n\nbash: 当word为非数字时，>&word变成重定向标准错误和标准输出到文件word\n\ndash: >&word, word不支持非数字, 替代方法: >word 2>&1; 常见用法 >/dev/null 2>&1\n\n6. 数组\n\nbash: 支持数组, bash4支持关联数组\n\ndash: 不支持数组，替代方法, 采用变量名+序号来实现类似的效果\n\n7. 子字符串扩展\n\nbash: 支持${parameter:offset:length},${parameter:offset}\n\ndash: 不支持， 替代方法:采用expr或cut外部命令代替\n\n8. 大小写转换\n\nbash: 支持${parameter^pattern},${parameter^^pattern},${parameter,pattern},${parameter,,pattern}\n\ndash: 不支持，替代方法:采用tr/sed/awk等外部命令转换\n\n9. 进程替换<(command), >(command)\n\nbash: 支持进程替换\n\ndash: 不支持, 替代方法, 通过临时文件中转\n\n10. [ string1 = string2 ] 和 [ string1 == string2 ]\n\nbash: 支持两者\n\ndash: 只支持=\n\n11. [[ 加强版test\n\nbash: 支持[[ ]], 可实现正则匹配等强大功能\n\ndash: 不支持[[ ]], 替代方法，采用外部命令\n\n12. for (( expr1 ; expr2 ; expr3 )) ; do list ; done\n\nbash: 支持C语言格式的for循环\n\ndash: 不支持该格式的for, 替代方法，用while+$((expression))实现\n\n13. let命令和((expression))\n\nbash: 有内置命令let, 也支持((expression))方式\n\ndash: 不支持，替代方法，采用$((expression))或者外部命令做计算\n\n14. $((expression))\n\nbash: 支持id++,id--,++id,--id这样到表达式\n\ndash: 不支持++,--, 替代方法:id+=1,id-=1, id=id+1,id=id-1\n","slug":"Linux shell语言——dash和bash","published":1,"updated":"2020-01-23T07:13:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzfs0003okecgrdagmsz","content":"<p>什么是bash ？</p>\n<p>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。</p>\n<p>GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 &#x2F;bin&#x2F;sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。</p>\n<p>Debian和Ubuntu中，&#x2F;bin&#x2F;sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。</p>\n<p>就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。</p>\n<p>要知道自己的&#x2F;bin&#x2F;sh指向何种解释器，可以用 ls &#x2F;bin&#x2F;sh -al 命令查看：</p>\n<pre><code class=\"hljs awk\">$ ls <span class=\"hljs-regexp\">/bin/</span>sh -al\nlrwxrwxrwx <span class=\"hljs-number\">1</span> root root <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">11</span>月 <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">15</span>:<span class=\"hljs-number\">33</span> <span class=\"hljs-regexp\">/bin/</span>sh -&gt; bash</code></pre>\n\n<p>以上结果就表示当前系统用的是dash解释器。</p>\n<p>切换到bash的方式其实挺简单的，关键是一直没找出这个原因……</p>\n<p>修改默认的sh，可以采用命令<code>sudo dpkg-reconfigure dash</code></p>\n<p>会出现一个图片状的配置菜单，选no就可以了</p>\n<p>再次检查一下， ls &#x2F;bin&#x2F;sh -al 发现软链接指向&#x2F;bin&#x2F;bash</p>\n<p>         lrwxrwxrwx 1 root root 4 11月 16 15:33 &#x2F;bin&#x2F;sh -&gt; bash</p>\n<p>注：dash 和 bash 语法上的主要的区别有:</p>\n<ol>\n<li>定义函数</li>\n</ol>\n<p>bash: function在bash中为关键字</p>\n<p>dash: dash中没有function这个关键字</p>\n<ol start=\"2\">\n<li>select var in list; do command; done</li>\n</ol>\n<p>bash:支持</p>\n<p>dash:不支持, 替代方法:采用while+read+case来实现</p>\n<ol start=\"3\">\n<li>echo {0..10}</li>\n</ol>\n<p>bash:支持{n..m}展开</p>\n<p>dash:不支持，替代方法, 采用seq外部命令</p>\n<ol start=\"4\">\n<li>here string</li>\n</ol>\n<p>bash:支持here string</p>\n<p>dash:不支持, 替代方法:可采用here documents</p>\n<ol start=\"5\">\n<li><blockquote>\n<p>&amp;word重定向标准输出和标准错误</p>\n</blockquote>\n</li>\n</ol>\n<p>bash: 当word为非数字时，&gt;&amp;word变成重定向标准错误和标准输出到文件word</p>\n<p>dash: &gt;&amp;word, word不支持非数字, 替代方法: &gt;word 2&gt;&amp;1; 常见用法 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</p>\n<ol start=\"6\">\n<li>数组</li>\n</ol>\n<p>bash: 支持数组, bash4支持关联数组</p>\n<p>dash: 不支持数组，替代方法, 采用变量名+序号来实现类似的效果</p>\n<ol start=\"7\">\n<li>子字符串扩展</li>\n</ol>\n<p>bash: 支持${parameter:offset:length},${parameter:offset}</p>\n<p>dash: 不支持， 替代方法:采用expr或cut外部命令代替</p>\n<ol start=\"8\">\n<li>大小写转换</li>\n</ol>\n<p>bash: 支持${parameter^pattern},${parameter^^pattern},${parameter,pattern},${parameter,,pattern}</p>\n<p>dash: 不支持，替代方法:采用tr&#x2F;sed&#x2F;awk等外部命令转换</p>\n<ol start=\"9\">\n<li>进程替换&lt;(command), &gt;(command)</li>\n</ol>\n<p>bash: 支持进程替换</p>\n<p>dash: 不支持, 替代方法, 通过临时文件中转</p>\n<ol start=\"10\">\n<li>[ string1 &#x3D; string2 ] 和 [ string1 &#x3D;&#x3D; string2 ]</li>\n</ol>\n<p>bash: 支持两者</p>\n<p>dash: 只支持&#x3D;</p>\n<ol start=\"11\">\n<li>[[ 加强版test</li>\n</ol>\n<p>bash: 支持[[ ]], 可实现正则匹配等强大功能</p>\n<p>dash: 不支持[[ ]], 替代方法，采用外部命令</p>\n<ol start=\"12\">\n<li>for (( expr1 ; expr2 ; expr3 )) ; do list ; done</li>\n</ol>\n<p>bash: 支持C语言格式的for循环</p>\n<p>dash: 不支持该格式的for, 替代方法，用while+$((expression))实现</p>\n<ol start=\"13\">\n<li>let命令和((expression))</li>\n</ol>\n<p>bash: 有内置命令let, 也支持((expression))方式</p>\n<p>dash: 不支持，替代方法，采用$((expression))或者外部命令做计算</p>\n<ol start=\"14\">\n<li>$((expression))</li>\n</ol>\n<p>bash: 支持id++,id–,++id,–id这样到表达式</p>\n<p>dash: 不支持++,–, 替代方法:id+&#x3D;1,id-&#x3D;1, id&#x3D;id+1,id&#x3D;id-1</p>\n","site":{"data":{}},"excerpt":"","more":"<p>什么是bash ？</p>\n<p>Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等。</p>\n<p>GNU&#x2F;Linux 操作系统中的 &#x2F;bin&#x2F;sh 本是 bash (Bourne-Again Shell) 的符号链接，但鉴于 bash 过于复杂，有人把 bash 从 NetBSD 移植到 Linux 并更名为 dash (Debian Almquist Shell)，并建议将 &#x2F;bin&#x2F;sh 指向它，以获得更快的脚本执行速度。Dash Shell 比 Bash Shell 小的多，符合POSIX标准。</p>\n<p>Debian和Ubuntu中，&#x2F;bin&#x2F;sh默认已经指向dash，这是一个不同于bash的shell，它主要是为了执行脚本而出现，而不是交互，它速度更快，但功能相比bash要少很多，语法严格遵守POSIX标准。</p>\n<p>就是这个倒霉的dash解释器使得我按照bash语法写的shell 脚本不能运行。</p>\n<p>要知道自己的&#x2F;bin&#x2F;sh指向何种解释器，可以用 ls &#x2F;bin&#x2F;sh -al 命令查看：</p>\n<pre><code class=\"hljs awk\">$ ls <span class=\"hljs-regexp\">/bin/</span>sh -al\nlrwxrwxrwx <span class=\"hljs-number\">1</span> root root <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">11</span>月 <span class=\"hljs-number\">16</span> <span class=\"hljs-number\">15</span>:<span class=\"hljs-number\">33</span> <span class=\"hljs-regexp\">/bin/</span>sh -&gt; bash</code></pre>\n\n<p>以上结果就表示当前系统用的是dash解释器。</p>\n<p>切换到bash的方式其实挺简单的，关键是一直没找出这个原因……</p>\n<p>修改默认的sh，可以采用命令<code>sudo dpkg-reconfigure dash</code></p>\n<p>会出现一个图片状的配置菜单，选no就可以了</p>\n<p>再次检查一下， ls &#x2F;bin&#x2F;sh -al 发现软链接指向&#x2F;bin&#x2F;bash</p>\n<p>         lrwxrwxrwx 1 root root 4 11月 16 15:33 &#x2F;bin&#x2F;sh -&gt; bash</p>\n<p>注：dash 和 bash 语法上的主要的区别有:</p>\n<ol>\n<li>定义函数</li>\n</ol>\n<p>bash: function在bash中为关键字</p>\n<p>dash: dash中没有function这个关键字</p>\n<ol start=\"2\">\n<li>select var in list; do command; done</li>\n</ol>\n<p>bash:支持</p>\n<p>dash:不支持, 替代方法:采用while+read+case来实现</p>\n<ol start=\"3\">\n<li>echo {0..10}</li>\n</ol>\n<p>bash:支持{n..m}展开</p>\n<p>dash:不支持，替代方法, 采用seq外部命令</p>\n<ol start=\"4\">\n<li>here string</li>\n</ol>\n<p>bash:支持here string</p>\n<p>dash:不支持, 替代方法:可采用here documents</p>\n<ol start=\"5\">\n<li><blockquote>\n<p>&amp;word重定向标准输出和标准错误</p>\n</blockquote>\n</li>\n</ol>\n<p>bash: 当word为非数字时，&gt;&amp;word变成重定向标准错误和标准输出到文件word</p>\n<p>dash: &gt;&amp;word, word不支持非数字, 替代方法: &gt;word 2&gt;&amp;1; 常见用法 &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1</p>\n<ol start=\"6\">\n<li>数组</li>\n</ol>\n<p>bash: 支持数组, bash4支持关联数组</p>\n<p>dash: 不支持数组，替代方法, 采用变量名+序号来实现类似的效果</p>\n<ol start=\"7\">\n<li>子字符串扩展</li>\n</ol>\n<p>bash: 支持${parameter:offset:length},${parameter:offset}</p>\n<p>dash: 不支持， 替代方法:采用expr或cut外部命令代替</p>\n<ol start=\"8\">\n<li>大小写转换</li>\n</ol>\n<p>bash: 支持${parameter^pattern},${parameter^^pattern},${parameter,pattern},${parameter,,pattern}</p>\n<p>dash: 不支持，替代方法:采用tr&#x2F;sed&#x2F;awk等外部命令转换</p>\n<ol start=\"9\">\n<li>进程替换&lt;(command), &gt;(command)</li>\n</ol>\n<p>bash: 支持进程替换</p>\n<p>dash: 不支持, 替代方法, 通过临时文件中转</p>\n<ol start=\"10\">\n<li>[ string1 &#x3D; string2 ] 和 [ string1 &#x3D;&#x3D; string2 ]</li>\n</ol>\n<p>bash: 支持两者</p>\n<p>dash: 只支持&#x3D;</p>\n<ol start=\"11\">\n<li>[[ 加强版test</li>\n</ol>\n<p>bash: 支持[[ ]], 可实现正则匹配等强大功能</p>\n<p>dash: 不支持[[ ]], 替代方法，采用外部命令</p>\n<ol start=\"12\">\n<li>for (( expr1 ; expr2 ; expr3 )) ; do list ; done</li>\n</ol>\n<p>bash: 支持C语言格式的for循环</p>\n<p>dash: 不支持该格式的for, 替代方法，用while+$((expression))实现</p>\n<ol start=\"13\">\n<li>let命令和((expression))</li>\n</ol>\n<p>bash: 有内置命令let, 也支持((expression))方式</p>\n<p>dash: 不支持，替代方法，采用$((expression))或者外部命令做计算</p>\n<ol start=\"14\">\n<li>$((expression))</li>\n</ol>\n<p>bash: 支持id++,id–,++id,–id这样到表达式</p>\n<p>dash: 不支持++,–, 替代方法:id+&#x3D;1,id-&#x3D;1, id&#x3D;id+1,id&#x3D;id-1</p>\n"},{"title":"linux fork函数详解","date":"2020-01-23T07:12:45.000Z","toc":true,"_content":"\n### 函数原型： ` pid_t\tfork(void) ` \n1. 参数：不需要参数\n2. 需要的头文件` <sys/types.h>` 和 `<unistd.h>`\n3. 返回值分两种情况：\n\t- 返回0表示成功创建子进程，并且接下来进入子进程执行流程\n\t- 返回PID（>0），成功创建子进程，并且继续执行父进程流程代码\n\t- 返回非正数（<0），创建子进程失败，失败原因主要有：\n\t\t- 进程数超过系统所能创建的上限，errno会被设置为EAGAIN\n\t\t- 系统内存不足，errno会被设置为ENOMEM\n\n### 地址空间\n> 使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。**子进程所独有的只有它的进程号，计时器等（只有小量信息）**。因此，使用 fork() 函数的代价是很大的。\n\n### 共享方式\n> 实际上，更准确来说，Linux 的 fork() 使用是通过**写时拷贝** (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。 \n\n### 执行顺序\n>  创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。\n\n> linux有个类似的函数vfork()：函数表面看起来都一样，但是它保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）， vfork() 创建的子进程会执行完后，才到父进程执行。\n\n### 区别\n子进程与父进程的区别在于：\n1.  除了文件锁以外,其他的锁都会被继承\n2. 各自的进程ID和父进程ID不同\n3. 子进程的未决告警被清除；\n4. 子进程的未决信号集设置为空集。\n\n### 孤儿进程、僵尸进程\n> fork系统调用之后，父子进程将交替执行，执行顺序不定。如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程（托孤给了init进程）。（注：任何一个进程都必须有父进程）如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）\n\n### 多线程进程的Fork调用\n坑大，面试可能会问道，工作中也要小心使用\n[云风 BLOG: 极不和谐的 fork 多线程程序](https://blog.codingnow.com/2011/01/fork_multi_thread.html)\n讲的主要是当前的进程processA (thread a/b/c)的当前子线程thread a调用fork后，会创建子进程，但是只是复制了thread a，总结一句就是所有父进程中别的线程，到了子进程中都是突然蒸发掉的。这样会导致各种死锁问题，以及各种数据不一致等问题。最好的办法是在多线程进程里不是用fork。如果非使用不可，尽量fork完毕后直接exec，不调用任何其他除了fork之外的函数。exec可以覆盖内存空间，可以解决所有关于锁的问题。\n还有一些文章可以看看：\n1. [谨防fork与锁之间的深坑 - CSDN博客](https://blog.csdn.net/Move_now/article/details/73537535) \n2. [子进程继承父进程中互斥锁的讨论 - CSDN博客](https://blog.csdn.net/lyh__521/article/details/45921515)  \n3. [在多线程中使用fork函数导致死锁，以及解决方案 - CSDN博客](https://blog.csdn.net/u011878172/article/details/79438584)","source":"_posts/linux fork函数详解.md","raw":"---\ntitle: linux fork函数详解\ndate: 2020-01-23 15:12:45\ntags: linux\ncategories: C/C++\ntoc: true\n---\n\n### 函数原型： ` pid_t\tfork(void) ` \n1. 参数：不需要参数\n2. 需要的头文件` <sys/types.h>` 和 `<unistd.h>`\n3. 返回值分两种情况：\n\t- 返回0表示成功创建子进程，并且接下来进入子进程执行流程\n\t- 返回PID（>0），成功创建子进程，并且继续执行父进程流程代码\n\t- 返回非正数（<0），创建子进程失败，失败原因主要有：\n\t\t- 进程数超过系统所能创建的上限，errno会被设置为EAGAIN\n\t\t- 系统内存不足，errno会被设置为ENOMEM\n\n### 地址空间\n> 使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。**子进程所独有的只有它的进程号，计时器等（只有小量信息）**。因此，使用 fork() 函数的代价是很大的。\n\n### 共享方式\n> 实际上，更准确来说，Linux 的 fork() 使用是通过**写时拷贝** (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。 \n\n### 执行顺序\n>  创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。\n\n> linux有个类似的函数vfork()：函数表面看起来都一样，但是它保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）， vfork() 创建的子进程会执行完后，才到父进程执行。\n\n### 区别\n子进程与父进程的区别在于：\n1.  除了文件锁以外,其他的锁都会被继承\n2. 各自的进程ID和父进程ID不同\n3. 子进程的未决告警被清除；\n4. 子进程的未决信号集设置为空集。\n\n### 孤儿进程、僵尸进程\n> fork系统调用之后，父子进程将交替执行，执行顺序不定。如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程（托孤给了init进程）。（注：任何一个进程都必须有父进程）如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）\n\n### 多线程进程的Fork调用\n坑大，面试可能会问道，工作中也要小心使用\n[云风 BLOG: 极不和谐的 fork 多线程程序](https://blog.codingnow.com/2011/01/fork_multi_thread.html)\n讲的主要是当前的进程processA (thread a/b/c)的当前子线程thread a调用fork后，会创建子进程，但是只是复制了thread a，总结一句就是所有父进程中别的线程，到了子进程中都是突然蒸发掉的。这样会导致各种死锁问题，以及各种数据不一致等问题。最好的办法是在多线程进程里不是用fork。如果非使用不可，尽量fork完毕后直接exec，不调用任何其他除了fork之外的函数。exec可以覆盖内存空间，可以解决所有关于锁的问题。\n还有一些文章可以看看：\n1. [谨防fork与锁之间的深坑 - CSDN博客](https://blog.csdn.net/Move_now/article/details/73537535) \n2. [子进程继承父进程中互斥锁的讨论 - CSDN博客](https://blog.csdn.net/lyh__521/article/details/45921515)  \n3. [在多线程中使用fork函数导致死锁，以及解决方案 - CSDN博客](https://blog.csdn.net/u011878172/article/details/79438584)","slug":"linux fork函数详解","published":1,"updated":"2020-01-23T07:12:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzfv0007okechnoz37jh","content":"<h3 id=\"函数原型：-pid-tfork-void\"><a href=\"#函数原型：-pid-tfork-void\" class=\"headerlink\" title=\"函数原型： pid_t\tfork(void)\"></a>函数原型： <code>pid_t\tfork(void)</code></h3><ol>\n<li>参数：不需要参数</li>\n<li>需要的头文件<code> &lt;sys/types.h&gt;</code> 和 <code>&lt;unistd.h&gt;</code></li>\n<li>返回值分两种情况：<ul>\n<li>返回0表示成功创建子进程，并且接下来进入子进程执行流程</li>\n<li>返回PID（&gt;0），成功创建子进程，并且继续执行父进程流程代码</li>\n<li>返回非正数（&lt;0），创建子进程失败，失败原因主要有：<ul>\n<li>进程数超过系统所能创建的上限，errno会被设置为EAGAIN</li>\n<li>系统内存不足，errno会被设置为ENOMEM</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h3><blockquote>\n<p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。<strong>子进程所独有的只有它的进程号，计时器等（只有小量信息）</strong>。因此，使用 fork() 函数的代价是很大的。</p>\n</blockquote>\n<h3 id=\"共享方式\"><a href=\"#共享方式\" class=\"headerlink\" title=\"共享方式\"></a>共享方式</h3><blockquote>\n<p>实际上，更准确来说，Linux 的 fork() 使用是通过<strong>写时拷贝</strong> (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。 </p>\n</blockquote>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><blockquote>\n<p> 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p>\n</blockquote>\n<blockquote>\n<p>linux有个类似的函数vfork()：函数表面看起来都一样，但是它保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）， vfork() 创建的子进程会执行完后，才到父进程执行。</p>\n</blockquote>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>子进程与父进程的区别在于：</p>\n<ol>\n<li>除了文件锁以外,其他的锁都会被继承</li>\n<li>各自的进程ID和父进程ID不同</li>\n<li>子进程的未决告警被清除；</li>\n<li>子进程的未决信号集设置为空集。</li>\n</ol>\n<h3 id=\"孤儿进程、僵尸进程\"><a href=\"#孤儿进程、僵尸进程\" class=\"headerlink\" title=\"孤儿进程、僵尸进程\"></a>孤儿进程、僵尸进程</h3><blockquote>\n<p>fork系统调用之后，父子进程将交替执行，执行顺序不定。如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程（托孤给了init进程）。（注：任何一个进程都必须有父进程）如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）</p>\n</blockquote>\n<h3 id=\"多线程进程的Fork调用\"><a href=\"#多线程进程的Fork调用\" class=\"headerlink\" title=\"多线程进程的Fork调用\"></a>多线程进程的Fork调用</h3><p>坑大，面试可能会问道，工作中也要小心使用<br><a href=\"https://blog.codingnow.com/2011/01/fork_multi_thread.html\">云风 BLOG: 极不和谐的 fork 多线程程序</a><br>讲的主要是当前的进程processA (thread a&#x2F;b&#x2F;c)的当前子线程thread a调用fork后，会创建子进程，但是只是复制了thread a，总结一句就是所有父进程中别的线程，到了子进程中都是突然蒸发掉的。这样会导致各种死锁问题，以及各种数据不一致等问题。最好的办法是在多线程进程里不是用fork。如果非使用不可，尽量fork完毕后直接exec，不调用任何其他除了fork之外的函数。exec可以覆盖内存空间，可以解决所有关于锁的问题。<br>还有一些文章可以看看：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/Move_now/article/details/73537535\">谨防fork与锁之间的深坑 - CSDN博客</a> </li>\n<li><a href=\"https://blog.csdn.net/lyh__521/article/details/45921515\">子进程继承父进程中互斥锁的讨论 - CSDN博客</a>  </li>\n<li><a href=\"https://blog.csdn.net/u011878172/article/details/79438584\">在多线程中使用fork函数导致死锁，以及解决方案 - CSDN博客</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"函数原型：-pid-tfork-void\"><a href=\"#函数原型：-pid-tfork-void\" class=\"headerlink\" title=\"函数原型： pid_t\tfork(void)\"></a>函数原型： <code>pid_t\tfork(void)</code></h3><ol>\n<li>参数：不需要参数</li>\n<li>需要的头文件<code> &lt;sys/types.h&gt;</code> 和 <code>&lt;unistd.h&gt;</code></li>\n<li>返回值分两种情况：<ul>\n<li>返回0表示成功创建子进程，并且接下来进入子进程执行流程</li>\n<li>返回PID（&gt;0），成功创建子进程，并且继续执行父进程流程代码</li>\n<li>返回非正数（&lt;0），创建子进程失败，失败原因主要有：<ul>\n<li>进程数超过系统所能创建的上限，errno会被设置为EAGAIN</li>\n<li>系统内存不足，errno会被设置为ENOMEM</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"地址空间\"><a href=\"#地址空间\" class=\"headerlink\" title=\"地址空间\"></a>地址空间</h3><blockquote>\n<p>使用 fork() 函数得到的子进程是父进程的一个复制品，它从父进程处继承了整个进程的地址空间：包括进程上下文（进程执行活动全过程的静态描述）、进程堆栈、打开的文件描述符、信号控制设定、进程优先级、进程组号等。<strong>子进程所独有的只有它的进程号，计时器等（只有小量信息）</strong>。因此，使用 fork() 函数的代价是很大的。</p>\n</blockquote>\n<h3 id=\"共享方式\"><a href=\"#共享方式\" class=\"headerlink\" title=\"共享方式\"></a>共享方式</h3><blockquote>\n<p>实际上，更准确来说，Linux 的 fork() 使用是通过<strong>写时拷贝</strong> (copy- on-write) 实现。写时拷贝是一种可以推迟甚至避免拷贝数据的技术。内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。 </p>\n</blockquote>\n<h3 id=\"执行顺序\"><a href=\"#执行顺序\" class=\"headerlink\" title=\"执行顺序\"></a>执行顺序</h3><blockquote>\n<p> 创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。</p>\n</blockquote>\n<blockquote>\n<p>linux有个类似的函数vfork()：函数表面看起来都一样，但是它保证子进程先运行,在它调用 exec（进程替换） 或 exit（退出进程）之后父进程才可能被调度运行。子进程共享父进程的地址空间（准确来说，在调用 exec（进程替换） 或 exit（退出进程） 之前与父进程数据是共享的）， vfork() 创建的子进程会执行完后，才到父进程执行。</p>\n</blockquote>\n<h3 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h3><p>子进程与父进程的区别在于：</p>\n<ol>\n<li>除了文件锁以外,其他的锁都会被继承</li>\n<li>各自的进程ID和父进程ID不同</li>\n<li>子进程的未决告警被清除；</li>\n<li>子进程的未决信号集设置为空集。</li>\n</ol>\n<h3 id=\"孤儿进程、僵尸进程\"><a href=\"#孤儿进程、僵尸进程\" class=\"headerlink\" title=\"孤儿进程、僵尸进程\"></a>孤儿进程、僵尸进程</h3><blockquote>\n<p>fork系统调用之后，父子进程将交替执行，执行顺序不定。如果父进程先退出，子进程还没退出那么子进程的父进程将变为init进程（托孤给了init进程）。（注：任何一个进程都必须有父进程）如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵进程（僵尸进程：只保留一些退出信息供父进程查询）</p>\n</blockquote>\n<h3 id=\"多线程进程的Fork调用\"><a href=\"#多线程进程的Fork调用\" class=\"headerlink\" title=\"多线程进程的Fork调用\"></a>多线程进程的Fork调用</h3><p>坑大，面试可能会问道，工作中也要小心使用<br><a href=\"https://blog.codingnow.com/2011/01/fork_multi_thread.html\">云风 BLOG: 极不和谐的 fork 多线程程序</a><br>讲的主要是当前的进程processA (thread a&#x2F;b&#x2F;c)的当前子线程thread a调用fork后，会创建子进程，但是只是复制了thread a，总结一句就是所有父进程中别的线程，到了子进程中都是突然蒸发掉的。这样会导致各种死锁问题，以及各种数据不一致等问题。最好的办法是在多线程进程里不是用fork。如果非使用不可，尽量fork完毕后直接exec，不调用任何其他除了fork之外的函数。exec可以覆盖内存空间，可以解决所有关于锁的问题。<br>还有一些文章可以看看：</p>\n<ol>\n<li><a href=\"https://blog.csdn.net/Move_now/article/details/73537535\">谨防fork与锁之间的深坑 - CSDN博客</a> </li>\n<li><a href=\"https://blog.csdn.net/lyh__521/article/details/45921515\">子进程继承父进程中互斥锁的讨论 - CSDN博客</a>  </li>\n<li><a href=\"https://blog.csdn.net/u011878172/article/details/79438584\">在多线程中使用fork函数导致死锁，以及解决方案 - CSDN博客</a></li>\n</ol>\n"},{"title":"TCP 三次握手和四次挥手","date":"2020-01-23T00:12:45.000Z","_content":"\n### 首先需要了解的知识\n- TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。\n- 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。\n- 注意上图中的四个非常重要的东西：\n\t- Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。（seq）\n\t- Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。\n\t- Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。\n\t- TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。主要有SYN、FIN、ACK等\n\n### TCP的状态机\n其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。\n如图：(用excel画图的难受，又早不到其他好工具，能推荐个吗？)\n![TCP连接、通讯、断开流程图](http://genge.cc/wp-content/uploads/2018/09/tcp连接.png)\n图中Client 、Server并不是严格区分的，TCP是全双工的，双方都可以充当Server、Client\n\n1. 三次握手\n\t1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n\t2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n\t3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。\n\n2. 四次挥手\n当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。\n\t1.  第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1(client)没有数据要发送给主机2(server)了\n\t2.  第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；\n\t3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n\t4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\n至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。\n\n3. 三次握手和四次挥手意义\n对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。\n对于四次挥手，其实仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。\n\n**为什么要三次握手**\n> 在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。\n\n在谢希仁著《计算机网络》书中同时举了一个例子，如下：\n> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”\n![计算机网络三次握手](http://genge.cc/wp-content/uploads/2018/09/计算机网络三次握手.jpg)\n\n一句话总结就是：**防止了服务器端的一直等待而浪费资源。**\n\n**为什么要四次挥手**\nTCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\n\n为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSED状态？\n虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSED状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。\n\n### 状态机状态解释\n- CLOSED: 这个没什么好说的了，表示初始状态，也是最后状态。\n- LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。\n- SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。\n- SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。\n- ESTABLISHED：这个容易理解了，表示连接已经建立了。\n- FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。\n- FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。\n- TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。\n- CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。\n- CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。\n- LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。\n\n### 参考文献\n[TCP 的那些事儿（上） | | 酷 壳 - CoolShell](https://coolshell.cn/articles/11564.html)\n[通俗大白话来理解TCP协议的三次握手和四次分手 · Issue #14 · jawil/blog · GitHub](https://github.com/jawil/blog/issues/14)\n[面试常考题-TCP三次握手与四次握手 - CSDN博客](https://blog.csdn.net/zxygww/article/details/45009613)\n[TCP协议中的三次握手和四次挥手(图解) - CSDN博客](https://blog.csdn.net/whuslei/article/details/6667471)\n[Linux Socket 网络编程](http://www.cnblogs.com/MyLove-Summer/p/5215287.html)\n","source":"_posts/TCP 三次握手和四次挥手.md","raw":"---\ntitle: TCP 三次握手和四次挥手\ndate: 2020-01-23 8:12:45\ntags: 网络\ncategories: 网络\n---\n\n### 首先需要了解的知识\n- TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。\n- 一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。\n- 注意上图中的四个非常重要的东西：\n\t- Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。（seq）\n\t- Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。\n\t- Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。\n\t- TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。主要有SYN、FIN、ACK等\n\n### TCP的状态机\n其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。\n如图：(用excel画图的难受，又早不到其他好工具，能推荐个吗？)\n![TCP连接、通讯、断开流程图](http://genge.cc/wp-content/uploads/2018/09/tcp连接.png)\n图中Client 、Server并不是严格区分的，TCP是全双工的，双方都可以充当Server、Client\n\n1. 三次握手\n\t1. 第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；\n\t2. 第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；\n\t3. 第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。\n完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。\n\n2. 四次挥手\n当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。\n\t1.  第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1(client)没有数据要发送给主机2(server)了\n\t2.  第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；\n\t3. 第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；\n\t4. 第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。\n\n至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。\n\n3. 三次握手和四次挥手意义\n对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。\n对于四次挥手，其实仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。\n\n**为什么要三次握手**\n> 在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。\n\n在谢希仁著《计算机网络》书中同时举了一个例子，如下：\n> “已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”\n![计算机网络三次握手](http://genge.cc/wp-content/uploads/2018/09/计算机网络三次握手.jpg)\n\n一句话总结就是：**防止了服务器端的一直等待而浪费资源。**\n\n**为什么要四次挥手**\nTCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\n\n为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSED状态？\n虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSED状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。\n\n### 状态机状态解释\n- CLOSED: 这个没什么好说的了，表示初始状态，也是最后状态。\n- LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。\n- SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。\n- SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。\n- ESTABLISHED：这个容易理解了，表示连接已经建立了。\n- FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。\n- FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。\n- TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。\n- CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。\n- CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。\n- LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。\n\n### 参考文献\n[TCP 的那些事儿（上） | | 酷 壳 - CoolShell](https://coolshell.cn/articles/11564.html)\n[通俗大白话来理解TCP协议的三次握手和四次分手 · Issue #14 · jawil/blog · GitHub](https://github.com/jawil/blog/issues/14)\n[面试常考题-TCP三次握手与四次握手 - CSDN博客](https://blog.csdn.net/zxygww/article/details/45009613)\n[TCP协议中的三次握手和四次挥手(图解) - CSDN博客](https://blog.csdn.net/whuslei/article/details/6667471)\n[Linux Socket 网络编程](http://www.cnblogs.com/MyLove-Summer/p/5215287.html)\n","slug":"TCP 三次握手和四次挥手","published":1,"updated":"2020-01-23T00:12:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzfw0009okec12yk5nsq","content":"<h3 id=\"首先需要了解的知识\"><a href=\"#首先需要了解的知识\" class=\"headerlink\" title=\"首先需要了解的知识\"></a>首先需要了解的知识</h3><ul>\n<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>\n<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>\n<li>注意上图中的四个非常重要的东西：<ul>\n<li>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。（seq）</li>\n<li>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</li>\n<li>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li>\n<li>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。主要有SYN、FIN、ACK等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP的状态机\"><a href=\"#TCP的状态机\" class=\"headerlink\" title=\"TCP的状态机\"></a>TCP的状态机</h3><p>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。<br>如图：(用excel画图的难受，又早不到其他好工具，能推荐个吗？)<br><img src=\"http://genge.cc/wp-content/uploads/2018/09/tcp%E8%BF%9E%E6%8E%A5.png\" alt=\"TCP连接、通讯、断开流程图\"><br>图中Client 、Server并不是严格区分的，TCP是全双工的，双方都可以充当Server、Client</p>\n<ol>\n<li><p>三次握手</p>\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li>\n<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li>\n</ol>\n</li>\n<li><p>四次挥手<br>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>\n<ol>\n<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1(client)没有数据要发送给主机2(server)了</li>\n<li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li>\n<li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>\n</ol>\n</li>\n</ol>\n<p>至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。</p>\n<ol start=\"3\">\n<li>三次握手和四次挥手意义<br>对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。<br>对于四次挥手，其实仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。</li>\n</ol>\n<p><strong>为什么要三次握手</strong></p>\n<blockquote>\n<p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。</p>\n</blockquote>\n<p>在谢希仁著《计算机网络》书中同时举了一个例子，如下：</p>\n<blockquote>\n<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”<br><img src=\"http://genge.cc/wp-content/uploads/2018/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg\" alt=\"计算机网络三次握手\"></p>\n</blockquote>\n<p>一句话总结就是：<strong>防止了服务器端的一直等待而浪费资源。</strong></p>\n<p><strong>为什么要四次挥手</strong><br>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>\n<p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSED状态？<br>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSED状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>\n<h3 id=\"状态机状态解释\"><a href=\"#状态机状态解释\" class=\"headerlink\" title=\"状态机状态解释\"></a>状态机状态解释</h3><ul>\n<li>CLOSED: 这个没什么好说的了，表示初始状态，也是最后状态。</li>\n<li>LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</li>\n<li>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</li>\n<li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>\n<li>ESTABLISHED：这个容易理解了，表示连接已经建立了。</li>\n<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</li>\n<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li>\n<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>\n<li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>\n<li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</li>\n<li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li>\n</ul>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://coolshell.cn/articles/11564.html\">TCP 的那些事儿（上） | | 酷 壳 - CoolShell</a><br><a href=\"https://github.com/jawil/blog/issues/14\">通俗大白话来理解TCP协议的三次握手和四次分手 · Issue #14 · jawil&#x2F;blog · GitHub</a><br><a href=\"https://blog.csdn.net/zxygww/article/details/45009613\">面试常考题-TCP三次握手与四次握手 - CSDN博客</a><br><a href=\"https://blog.csdn.net/whuslei/article/details/6667471\">TCP协议中的三次握手和四次挥手(图解) - CSDN博客</a><br><a href=\"http://www.cnblogs.com/MyLove-Summer/p/5215287.html\">Linux Socket 网络编程</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"首先需要了解的知识\"><a href=\"#首先需要了解的知识\" class=\"headerlink\" title=\"首先需要了解的知识\"></a>首先需要了解的知识</h3><ul>\n<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>\n<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>\n<li>注意上图中的四个非常重要的东西：<ul>\n<li>Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。（seq）</li>\n<li>Acknowledgement Number就是ACK——用于确认收到，用来解决不丢包的问题。</li>\n<li>Window又叫Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。</li>\n<li>TCP Flag ，也就是包的类型，主要是用于操控TCP的状态机的。主要有SYN、FIN、ACK等</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"TCP的状态机\"><a href=\"#TCP的状态机\" class=\"headerlink\" title=\"TCP的状态机\"></a>TCP的状态机</h3><p>其实，网络上的传输是没有连接的，包括TCP也是一样的。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。<br>如图：(用excel画图的难受，又早不到其他好工具，能推荐个吗？)<br><img src=\"http://genge.cc/wp-content/uploads/2018/09/tcp%E8%BF%9E%E6%8E%A5.png\" alt=\"TCP连接、通讯、断开流程图\"><br>图中Client 、Server并不是严格区分的，TCP是全双工的，双方都可以充当Server、Client</p>\n<ol>\n<li><p>三次握手</p>\n<ol>\n<li>第一次握手：建立连接。客户端发送连接请求报文段，将SYN位置为1，Sequence Number为x；然后，客户端进入SYN_SEND状态，等待服务器的确认；</li>\n<li>第二次握手：服务器收到SYN报文段。服务器收到客户端的SYN报文段，需要对这个SYN报文段进行确认，设置Acknowledgment Number为x+1(Sequence Number+1)；同时，自己自己还要发送SYN请求信息，将SYN位置为1，Sequence Number为y；服务器端将上述所有信息放到一个报文段（即SYN+ACK报文段）中，一并发送给客户端，此时服务器进入SYN_RECV状态；</li>\n<li>第三次握手：客户端收到服务器的SYN+ACK报文段。然后将Acknowledgment Number设置为y+1，向服务器发送ACK报文段，这个报文段发送完毕以后，客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。<br>完成了三次握手，客户端和服务器端就可以开始传送数据。以上就是TCP三次握手的总体介绍。</li>\n</ol>\n</li>\n<li><p>四次挥手<br>当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次分手”。</p>\n<ol>\n<li>第一次分手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1(client)没有数据要发送给主机2(server)了</li>\n<li>第二次分手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我“同意”你的关闭请求；</li>\n<li>第三次分手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入LAST_ACK状态；</li>\n<li>第四次分手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</li>\n</ol>\n</li>\n</ol>\n<p>至此，TCP的四次分手就这么愉快的完成了。当你看到这里，你的脑子里会有很多的疑问，很多的不懂，感觉很凌乱；没事，我们继续总结。</p>\n<ol start=\"3\">\n<li>三次握手和四次挥手意义<br>对于建链接的3次握手，主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。<br>对于四次挥手，其实仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。</li>\n</ol>\n<p><strong>为什么要三次握手</strong></p>\n<blockquote>\n<p>在谢希仁著《计算机网络》第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”。在另一部经典的《计算机网络》一书中讲“三次握手”的目的是为了解决“网络中存在延迟的重复分组”的问题。</p>\n</blockquote>\n<p>在谢希仁著《计算机网络》书中同时举了一个例子，如下：</p>\n<blockquote>\n<p>“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”<br><img src=\"http://genge.cc/wp-content/uploads/2018/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.jpg\" alt=\"计算机网络三次握手\"></p>\n</blockquote>\n<p>一句话总结就是：<strong>防止了服务器端的一直等待而浪费资源。</strong></p>\n<p><strong>为什么要四次挥手</strong><br>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP是全双工模式，这就意味着，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了，主机1告诉主机2，它的数据已经全部发送完毕了；但是，这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2还是可以发送数据到主机1的；当主机2也发送了FIN报文段时，这个时候就表示主机2也没有数据要发送了，就会告诉主机1，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>\n<p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSED状态？<br>虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSED状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>\n<h3 id=\"状态机状态解释\"><a href=\"#状态机状态解释\" class=\"headerlink\" title=\"状态机状态解释\"></a>状态机状态解释</h3><ul>\n<li>CLOSED: 这个没什么好说的了，表示初始状态，也是最后状态。</li>\n<li>LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。</li>\n<li>SYN_RCVD: 这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。</li>\n<li>SYN_SENT: 这个状态与SYN_RCVD遥想呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。</li>\n<li>ESTABLISHED：这个容易理解了，表示连接已经建立了。</li>\n<li>FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。</li>\n<li>FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你，稍后再关闭连接。</li>\n<li>TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</li>\n<li>CLOSING: 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。</li>\n<li>CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢？当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。</li>\n<li>LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。</li>\n</ul>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://coolshell.cn/articles/11564.html\">TCP 的那些事儿（上） | | 酷 壳 - CoolShell</a><br><a href=\"https://github.com/jawil/blog/issues/14\">通俗大白话来理解TCP协议的三次握手和四次分手 · Issue #14 · jawil&#x2F;blog · GitHub</a><br><a href=\"https://blog.csdn.net/zxygww/article/details/45009613\">面试常考题-TCP三次握手与四次握手 - CSDN博客</a><br><a href=\"https://blog.csdn.net/whuslei/article/details/6667471\">TCP协议中的三次握手和四次挥手(图解) - CSDN博客</a><br><a href=\"http://www.cnblogs.com/MyLove-Summer/p/5215287.html\">Linux Socket 网络编程</a></p>\n"},{"title":"linux 内核RingBuffer实现","date":"2020-01-22T07:12:45.000Z","_content":"\n实现方式非常巧妙，刚开始看的有点奇怪，当发现实现原理后惊讶了一番..\n\n```c++\n/**@brief 仿照linux kfifo写的ring buffer\n* ring_buffer.h\n * */\n \n#ifndef KFIFO_HEADER_H \n#define KFIFO_HEADER_H\n \n#include <inttypes.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n \n//判断x是否是2的次方\n#define is_power_of_2(x) ((x) != 0 && (((x) & ((x) - 1)) == 0))\n//取a和b中最小值\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n \nstruct ring_buffer\n{\n    void         *buffer;     //缓冲区\n    uint32_t     size;       //大小\n    uint32_t     in;         //入口位置\n    uint32_t       out;        //出口位置\n    pthread_mutex_t *f_lock;    //互斥锁\n};\n//初始化缓冲区\nstruct ring_buffer* ring_buffer_init(void *buffer, uint32_t size, pthread_mutex_t *f_lock)\n{\n    assert(buffer);\n    struct ring_buffer *ring_buf = NULL;\n    if (!is_power_of_2(size))\n    {\n    fprintf(stderr,\"size must be power of 2.\\n\");\n        return ring_buf;\n    }\n    ring_buf = (struct ring_buffer *)malloc(sizeof(struct ring_buffer));\n    if (!ring_buf)\n    {\n        fprintf(stderr,\"Failed to malloc memory,errno:%u,reason:%s\",\n            errno, strerror(errno));\n        return ring_buf;\n    }\n    memset(ring_buf, 0, sizeof(struct ring_buffer));\n    ring_buf->buffer = buffer;\n    ring_buf->size = size;\n    ring_buf->in = 0;\n    ring_buf->out = 0;\n        ring_buf->f_lock = f_lock;\n    return ring_buf;\n}\n//释放缓冲区\nvoid ring_buffer_free(struct ring_buffer *ring_buf)\n{\n    if (ring_buf)\n    {\n    if (ring_buf->buffer)\n    {\n        free(ring_buf->buffer);\n        ring_buf->buffer = NULL;\n    }\n    free(ring_buf);\n    ring_buf = NULL;\n    }\n}\n \n//缓冲区的长度\nuint32_t __ring_buffer_len(const struct ring_buffer *ring_buf)\n{\n    return (ring_buf->in - ring_buf->out);\n}\n \n//从缓冲区中取数据\nuint32_t __ring_buffer_get(struct ring_buffer *ring_buf, void * buffer, uint32_t size)\n{\n    assert(ring_buf || buffer);\n    uint32_t len = 0;\n    size  = min(size, ring_buf->in - ring_buf->out);        \n    /* first get the data from fifo->out until the end of the buffer */\n    len = min(size, ring_buf->size - (ring_buf->out & (ring_buf->size - 1)));\n    memcpy(buffer, ring_buf->buffer + (ring_buf->out & (ring_buf->size - 1)), len);\n    /* then get the rest (if any) from the beginning of the buffer */\n    memcpy(buffer + len, ring_buf->buffer, size - len);\n    ring_buf->out += size;\n    return size;\n}\n//向缓冲区中存放数据\nuint32_t __ring_buffer_put(struct ring_buffer *ring_buf, void *buffer, uint32_t size)\n{\n    assert(ring_buf || buffer);\n    uint32_t len = 0;\n    size = min(size, ring_buf->size - ring_buf->in + ring_buf->out);\n    /* first put the data starting from fifo->in to buffer end */\n    len  = min(size, ring_buf->size - (ring_buf->in & (ring_buf->size - 1)));\n    memcpy(ring_buf->buffer + (ring_buf->in & (ring_buf->size - 1)), buffer, len);\n    /* then put the rest (if any) at the beginning of the buffer */\n    memcpy(ring_buf->buffer, buffer + len, size - len);\n    ring_buf->in += size;\n    return size;\n}\n \nuint32_t ring_buffer_len(const struct ring_buffer *ring_buf)\n{\n    uint32_t len = 0;\n    pthread_mutex_lock(ring_buf->f_lock);\n    len = __ring_buffer_len(ring_buf);\n    pthread_mutex_unlock(ring_buf->f_lock);\n    return len;\n}\n \nuint32_t ring_buffer_get(struct ring_buffer *ring_buf, void *buffer, uint32_t size)\n{\n    uint32_t ret;\n    pthread_mutex_lock(ring_buf->f_lock);\n    ret = __ring_buffer_get(ring_buf, buffer, size);\n    //buffer中没有数据\n    if (ring_buf->in == ring_buf->out)\n    ring_buf->in = ring_buf->out = 0;\n    pthread_mutex_unlock(ring_buf->f_lock);\n    return ret;\n}\n \nuint32_t ring_buffer_put(struct ring_buffer *ring_buf, void *buffer, uint32_t size)\n{\n    uint32_t ret;\n    pthread_mutex_lock(ring_buf->f_lock);\n    ret = __ring_buffer_put(ring_buf, buffer, size);\n    pthread_mutex_unlock(ring_buf->f_lock);\n    return ret;\n}\n#endif\n\n```\n\n使用栗子，采用多线程模拟生产者和消费者编写测试程序，如下所示：\n```c\n/**@brief ring buffer测试程序，创建两个线程，一个生产者，一个消费者。\n * 生产者每隔1秒向buffer中投入数据，消费者每隔2秒去取数据。\n * */\n#include \"ring_buffer.h\"\n#include <pthread.h>\n#include <time.h>\n \n#define BUFFER_SIZE  1024 * 1024\n \ntypedef struct student_info\n{\n    uint64_t stu_id;\n    uint32_t age;\n    uint32_t score;\n}student_info;\n \n \nvoid print_student_info(const student_info *stu_info)\n{\n    assert(stu_info);\n    printf(\"id:%lu\\t\",stu_info->stu_id);\n    printf(\"age:%u\\t\",stu_info->age);\n    printf(\"score:%u\\n\",stu_info->score);\n}\n \nstudent_info * get_student_info(time_t timer)\n{\n    student_info *stu_info = (student_info *)malloc(sizeof(student_info));\n    if (!stu_info)\n    {\n    fprintf(stderr, \"Failed to malloc memory.\\n\");\n    return NULL;\n    }\n    srand(timer);\n    stu_info->stu_id = 10000 + rand() % 9999;\n    stu_info->age = rand() % 30;\n    stu_info->score = rand() % 101;\n    print_student_info(stu_info);\n    return stu_info;\n}\n \nvoid * consumer_proc(void *arg)\n{\n    struct ring_buffer *ring_buf = (struct ring_buffer *)arg;\n    student_info stu_info; \n    while(1)\n    {\n    sleep(2);\n    printf(\"------------------------------------------\\n\");\n    printf(\"get a student info from ring buffer.\\n\");\n    ring_buffer_get(ring_buf, (void *)&stu_info, sizeof(student_info));\n    printf(\"ring buffer length: %u\\n\", ring_buffer_len(ring_buf));\n    print_student_info(&stu_info);\n    printf(\"------------------------------------------\\n\");\n    }\n    return (void *)ring_buf;\n}\n \nvoid * producer_proc(void *arg)\n{\n    time_t cur_time;\n    struct ring_buffer *ring_buf = (struct ring_buffer *)arg;\n    while(1)\n    {\n    time(&cur_time);\n    srand(cur_time);\n    int seed = rand() % 11111;\n    printf(\"******************************************\\n\");\n    student_info *stu_info = get_student_info(cur_time + seed);\n    printf(\"put a student info to ring buffer.\\n\");\n    ring_buffer_put(ring_buf, (void *)stu_info, sizeof(student_info));\n    printf(\"ring buffer length: %u\\n\", ring_buffer_len(ring_buf));\n    printf(\"******************************************\\n\");\n    sleep(1);\n    }\n    return (void *)ring_buf;\n}\n \nint consumer_thread(void *arg)\n{\n    int err;\n    pthread_t tid;\n    err = pthread_create(&tid, NULL, consumer_proc, arg);\n    if (err != 0)\n    {\n    fprintf(stderr, \"Failed to create consumer thread.errno:%u, reason:%s\\n\",\n        errno, strerror(errno));\n    return -1;\n    }\n    return tid;\n}\nint producer_thread(void *arg)\n{\n    int err;\n    pthread_t tid;\n    err = pthread_create(&tid, NULL, producer_proc, arg);\n    if (err != 0)\n    {\n    fprintf(stderr, \"Failed to create consumer thread.errno:%u, reason:%s\\n\",\n        errno, strerror(errno));\n    return -1;\n    }\n    return tid;\n}\n \n \nint main()\n{\n    void * buffer = NULL;\n    uint32_t size = 0;\n    struct ring_buffer *ring_buf = NULL;\n    pthread_t consume_pid, produce_pid;\n \n    pthread_mutex_t *f_lock = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));\n    if (pthread_mutex_init(f_lock, NULL) != 0)\n    {\n    fprintf(stderr, \"Failed init mutex,errno:%u,reason:%s\\n\",\n        errno, strerror(errno));\n    return -1;\n    }\n    buffer = (void *)malloc(BUFFER_SIZE);\n    if (!buffer)\n    {\n    fprintf(stderr, \"Failed to malloc memory.\\n\");\n    return -1;\n    }\n    size = BUFFER_SIZE;\n    ring_buf = ring_buffer_init(buffer, size, f_lock);\n    if (!ring_buf)\n    {\n    fprintf(stderr, \"Failed to init ring buffer.\\n\");\n    return -1;\n    }\n#if 0\n    student_info *stu_info = get_student_info(638946124);\n    ring_buffer_put(ring_buf, (void *)stu_info, sizeof(student_info));\n    stu_info = get_student_info(976686464);\n    ring_buffer_put(ring_buf, (void *)stu_info, sizeof(student_info));\n    ring_buffer_get(ring_buf, (void *)stu_info, sizeof(student_info));\n    print_student_info(stu_info);\n#endif\n    printf(\"multi thread test.......\\n\");\n    produce_pid  = producer_thread((void*)ring_buf);\n    consume_pid  = consumer_thread((void*)ring_buf);\n    pthread_join(produce_pid, NULL);\n    pthread_join(consume_pid, NULL);\n    ring_buffer_free(ring_buf);\n    free(f_lock);\n    return 0;\n}\n\n```\n\n## 参考文献\n[linux内核数据结构之kfifo - Daleshi的技术随笔 - 博客园](https://www.cnblogs.com/Anker/p/3481373.html)\n\n","source":"_posts/linux 内核RingBuffer实现.md","raw":"---\ntitle: linux 内核RingBuffer实现\ndate: 2020-01-22 15:12:45\ntags: linux\ncategories: C/C++\n---\n\n实现方式非常巧妙，刚开始看的有点奇怪，当发现实现原理后惊讶了一番..\n\n```c++\n/**@brief 仿照linux kfifo写的ring buffer\n* ring_buffer.h\n * */\n \n#ifndef KFIFO_HEADER_H \n#define KFIFO_HEADER_H\n \n#include <inttypes.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#include <assert.h>\n \n//判断x是否是2的次方\n#define is_power_of_2(x) ((x) != 0 && (((x) & ((x) - 1)) == 0))\n//取a和b中最小值\n#define min(a, b) (((a) < (b)) ? (a) : (b))\n \nstruct ring_buffer\n{\n    void         *buffer;     //缓冲区\n    uint32_t     size;       //大小\n    uint32_t     in;         //入口位置\n    uint32_t       out;        //出口位置\n    pthread_mutex_t *f_lock;    //互斥锁\n};\n//初始化缓冲区\nstruct ring_buffer* ring_buffer_init(void *buffer, uint32_t size, pthread_mutex_t *f_lock)\n{\n    assert(buffer);\n    struct ring_buffer *ring_buf = NULL;\n    if (!is_power_of_2(size))\n    {\n    fprintf(stderr,\"size must be power of 2.\\n\");\n        return ring_buf;\n    }\n    ring_buf = (struct ring_buffer *)malloc(sizeof(struct ring_buffer));\n    if (!ring_buf)\n    {\n        fprintf(stderr,\"Failed to malloc memory,errno:%u,reason:%s\",\n            errno, strerror(errno));\n        return ring_buf;\n    }\n    memset(ring_buf, 0, sizeof(struct ring_buffer));\n    ring_buf->buffer = buffer;\n    ring_buf->size = size;\n    ring_buf->in = 0;\n    ring_buf->out = 0;\n        ring_buf->f_lock = f_lock;\n    return ring_buf;\n}\n//释放缓冲区\nvoid ring_buffer_free(struct ring_buffer *ring_buf)\n{\n    if (ring_buf)\n    {\n    if (ring_buf->buffer)\n    {\n        free(ring_buf->buffer);\n        ring_buf->buffer = NULL;\n    }\n    free(ring_buf);\n    ring_buf = NULL;\n    }\n}\n \n//缓冲区的长度\nuint32_t __ring_buffer_len(const struct ring_buffer *ring_buf)\n{\n    return (ring_buf->in - ring_buf->out);\n}\n \n//从缓冲区中取数据\nuint32_t __ring_buffer_get(struct ring_buffer *ring_buf, void * buffer, uint32_t size)\n{\n    assert(ring_buf || buffer);\n    uint32_t len = 0;\n    size  = min(size, ring_buf->in - ring_buf->out);        \n    /* first get the data from fifo->out until the end of the buffer */\n    len = min(size, ring_buf->size - (ring_buf->out & (ring_buf->size - 1)));\n    memcpy(buffer, ring_buf->buffer + (ring_buf->out & (ring_buf->size - 1)), len);\n    /* then get the rest (if any) from the beginning of the buffer */\n    memcpy(buffer + len, ring_buf->buffer, size - len);\n    ring_buf->out += size;\n    return size;\n}\n//向缓冲区中存放数据\nuint32_t __ring_buffer_put(struct ring_buffer *ring_buf, void *buffer, uint32_t size)\n{\n    assert(ring_buf || buffer);\n    uint32_t len = 0;\n    size = min(size, ring_buf->size - ring_buf->in + ring_buf->out);\n    /* first put the data starting from fifo->in to buffer end */\n    len  = min(size, ring_buf->size - (ring_buf->in & (ring_buf->size - 1)));\n    memcpy(ring_buf->buffer + (ring_buf->in & (ring_buf->size - 1)), buffer, len);\n    /* then put the rest (if any) at the beginning of the buffer */\n    memcpy(ring_buf->buffer, buffer + len, size - len);\n    ring_buf->in += size;\n    return size;\n}\n \nuint32_t ring_buffer_len(const struct ring_buffer *ring_buf)\n{\n    uint32_t len = 0;\n    pthread_mutex_lock(ring_buf->f_lock);\n    len = __ring_buffer_len(ring_buf);\n    pthread_mutex_unlock(ring_buf->f_lock);\n    return len;\n}\n \nuint32_t ring_buffer_get(struct ring_buffer *ring_buf, void *buffer, uint32_t size)\n{\n    uint32_t ret;\n    pthread_mutex_lock(ring_buf->f_lock);\n    ret = __ring_buffer_get(ring_buf, buffer, size);\n    //buffer中没有数据\n    if (ring_buf->in == ring_buf->out)\n    ring_buf->in = ring_buf->out = 0;\n    pthread_mutex_unlock(ring_buf->f_lock);\n    return ret;\n}\n \nuint32_t ring_buffer_put(struct ring_buffer *ring_buf, void *buffer, uint32_t size)\n{\n    uint32_t ret;\n    pthread_mutex_lock(ring_buf->f_lock);\n    ret = __ring_buffer_put(ring_buf, buffer, size);\n    pthread_mutex_unlock(ring_buf->f_lock);\n    return ret;\n}\n#endif\n\n```\n\n使用栗子，采用多线程模拟生产者和消费者编写测试程序，如下所示：\n```c\n/**@brief ring buffer测试程序，创建两个线程，一个生产者，一个消费者。\n * 生产者每隔1秒向buffer中投入数据，消费者每隔2秒去取数据。\n * */\n#include \"ring_buffer.h\"\n#include <pthread.h>\n#include <time.h>\n \n#define BUFFER_SIZE  1024 * 1024\n \ntypedef struct student_info\n{\n    uint64_t stu_id;\n    uint32_t age;\n    uint32_t score;\n}student_info;\n \n \nvoid print_student_info(const student_info *stu_info)\n{\n    assert(stu_info);\n    printf(\"id:%lu\\t\",stu_info->stu_id);\n    printf(\"age:%u\\t\",stu_info->age);\n    printf(\"score:%u\\n\",stu_info->score);\n}\n \nstudent_info * get_student_info(time_t timer)\n{\n    student_info *stu_info = (student_info *)malloc(sizeof(student_info));\n    if (!stu_info)\n    {\n    fprintf(stderr, \"Failed to malloc memory.\\n\");\n    return NULL;\n    }\n    srand(timer);\n    stu_info->stu_id = 10000 + rand() % 9999;\n    stu_info->age = rand() % 30;\n    stu_info->score = rand() % 101;\n    print_student_info(stu_info);\n    return stu_info;\n}\n \nvoid * consumer_proc(void *arg)\n{\n    struct ring_buffer *ring_buf = (struct ring_buffer *)arg;\n    student_info stu_info; \n    while(1)\n    {\n    sleep(2);\n    printf(\"------------------------------------------\\n\");\n    printf(\"get a student info from ring buffer.\\n\");\n    ring_buffer_get(ring_buf, (void *)&stu_info, sizeof(student_info));\n    printf(\"ring buffer length: %u\\n\", ring_buffer_len(ring_buf));\n    print_student_info(&stu_info);\n    printf(\"------------------------------------------\\n\");\n    }\n    return (void *)ring_buf;\n}\n \nvoid * producer_proc(void *arg)\n{\n    time_t cur_time;\n    struct ring_buffer *ring_buf = (struct ring_buffer *)arg;\n    while(1)\n    {\n    time(&cur_time);\n    srand(cur_time);\n    int seed = rand() % 11111;\n    printf(\"******************************************\\n\");\n    student_info *stu_info = get_student_info(cur_time + seed);\n    printf(\"put a student info to ring buffer.\\n\");\n    ring_buffer_put(ring_buf, (void *)stu_info, sizeof(student_info));\n    printf(\"ring buffer length: %u\\n\", ring_buffer_len(ring_buf));\n    printf(\"******************************************\\n\");\n    sleep(1);\n    }\n    return (void *)ring_buf;\n}\n \nint consumer_thread(void *arg)\n{\n    int err;\n    pthread_t tid;\n    err = pthread_create(&tid, NULL, consumer_proc, arg);\n    if (err != 0)\n    {\n    fprintf(stderr, \"Failed to create consumer thread.errno:%u, reason:%s\\n\",\n        errno, strerror(errno));\n    return -1;\n    }\n    return tid;\n}\nint producer_thread(void *arg)\n{\n    int err;\n    pthread_t tid;\n    err = pthread_create(&tid, NULL, producer_proc, arg);\n    if (err != 0)\n    {\n    fprintf(stderr, \"Failed to create consumer thread.errno:%u, reason:%s\\n\",\n        errno, strerror(errno));\n    return -1;\n    }\n    return tid;\n}\n \n \nint main()\n{\n    void * buffer = NULL;\n    uint32_t size = 0;\n    struct ring_buffer *ring_buf = NULL;\n    pthread_t consume_pid, produce_pid;\n \n    pthread_mutex_t *f_lock = (pthread_mutex_t *)malloc(sizeof(pthread_mutex_t));\n    if (pthread_mutex_init(f_lock, NULL) != 0)\n    {\n    fprintf(stderr, \"Failed init mutex,errno:%u,reason:%s\\n\",\n        errno, strerror(errno));\n    return -1;\n    }\n    buffer = (void *)malloc(BUFFER_SIZE);\n    if (!buffer)\n    {\n    fprintf(stderr, \"Failed to malloc memory.\\n\");\n    return -1;\n    }\n    size = BUFFER_SIZE;\n    ring_buf = ring_buffer_init(buffer, size, f_lock);\n    if (!ring_buf)\n    {\n    fprintf(stderr, \"Failed to init ring buffer.\\n\");\n    return -1;\n    }\n#if 0\n    student_info *stu_info = get_student_info(638946124);\n    ring_buffer_put(ring_buf, (void *)stu_info, sizeof(student_info));\n    stu_info = get_student_info(976686464);\n    ring_buffer_put(ring_buf, (void *)stu_info, sizeof(student_info));\n    ring_buffer_get(ring_buf, (void *)stu_info, sizeof(student_info));\n    print_student_info(stu_info);\n#endif\n    printf(\"multi thread test.......\\n\");\n    produce_pid  = producer_thread((void*)ring_buf);\n    consume_pid  = consumer_thread((void*)ring_buf);\n    pthread_join(produce_pid, NULL);\n    pthread_join(consume_pid, NULL);\n    ring_buffer_free(ring_buf);\n    free(f_lock);\n    return 0;\n}\n\n```\n\n## 参考文献\n[linux内核数据结构之kfifo - Daleshi的技术随笔 - 博客园](https://www.cnblogs.com/Anker/p/3481373.html)\n\n","slug":"linux 内核RingBuffer实现","published":1,"updated":"2020-01-22T07:12:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzfx000bokec66zw8fs3","content":"<p>实现方式非常巧妙，刚开始看的有点奇怪，当发现实现原理后惊讶了一番..</p>\n<pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**@brief 仿照linux kfifo写的ring buffer</span>\n<span class=\"hljs-comment\">* ring_buffer.h</span>\n<span class=\"hljs-comment\"> * */</span>\n \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> KFIFO_HEADER_H </span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> KFIFO_HEADER_H</span>\n \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;errno.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\n \n<span class=\"hljs-comment\">//判断x是否是2的次方</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> is_power_of_2(x) ((x) != 0 &amp;&amp; (((x) &amp; ((x) - 1)) == 0))</span>\n<span class=\"hljs-comment\">//取a和b中最小值</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span>\n \n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ring_buffer</span>\n&#123;\n    <span class=\"hljs-type\">void</span>         *buffer;     <span class=\"hljs-comment\">//缓冲区</span>\n    <span class=\"hljs-type\">uint32_t</span>     size;       <span class=\"hljs-comment\">//大小</span>\n    <span class=\"hljs-type\">uint32_t</span>     in;         <span class=\"hljs-comment\">//入口位置</span>\n    <span class=\"hljs-type\">uint32_t</span>       out;        <span class=\"hljs-comment\">//出口位置</span>\n    <span class=\"hljs-type\">pthread_mutex_t</span> *f_lock;    <span class=\"hljs-comment\">//互斥锁</span>\n&#125;;\n<span class=\"hljs-comment\">//初始化缓冲区</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ring_buffer</span>* <span class=\"hljs-built_in\">ring_buffer_init</span>(<span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size, <span class=\"hljs-type\">pthread_mutex_t</span> *f_lock)\n&#123;\n    <span class=\"hljs-built_in\">assert</span>(buffer);\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ring_buffer</span> *ring_buf = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">is_power_of_2</span>(size))\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(stderr,<span class=\"hljs-string\">&quot;size must be power of 2.\\n&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> ring_buf;\n    &#125;\n    ring_buf = (<span class=\"hljs-keyword\">struct</span> ring_buffer *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> ring_buffer));\n    <span class=\"hljs-keyword\">if</span> (!ring_buf)\n    &#123;\n        <span class=\"hljs-built_in\">fprintf</span>(stderr,<span class=\"hljs-string\">&quot;Failed to malloc memory,errno:%u,reason:%s&quot;</span>,\n            errno, <span class=\"hljs-built_in\">strerror</span>(errno));\n        <span class=\"hljs-keyword\">return</span> ring_buf;\n    &#125;\n    <span class=\"hljs-built_in\">memset</span>(ring_buf, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> ring_buffer));\n    ring_buf-&gt;buffer = buffer;\n    ring_buf-&gt;size = size;\n    ring_buf-&gt;in = <span class=\"hljs-number\">0</span>;\n    ring_buf-&gt;out = <span class=\"hljs-number\">0</span>;\n        ring_buf-&gt;f_lock = f_lock;\n    <span class=\"hljs-keyword\">return</span> ring_buf;\n&#125;\n<span class=\"hljs-comment\">//释放缓冲区</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ring_buffer_free</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (ring_buf)\n    &#123;\n    <span class=\"hljs-keyword\">if</span> (ring_buf-&gt;buffer)\n    &#123;\n        <span class=\"hljs-built_in\">free</span>(ring_buf-&gt;buffer);\n        ring_buf-&gt;buffer = <span class=\"hljs-literal\">NULL</span>;\n    &#125;\n    <span class=\"hljs-built_in\">free</span>(ring_buf);\n    ring_buf = <span class=\"hljs-literal\">NULL</span>;\n    &#125;\n&#125;\n \n<span class=\"hljs-comment\">//缓冲区的长度</span>\n<span class=\"hljs-type\">uint32_t</span> __ring_buffer_len(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf)\n&#123;\n    <span class=\"hljs-keyword\">return</span> (ring_buf-&gt;in - ring_buf-&gt;out);\n&#125;\n \n<span class=\"hljs-comment\">//从缓冲区中取数据</span>\n<span class=\"hljs-type\">uint32_t</span> __ring_buffer_get(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> * buffer, <span class=\"hljs-type\">uint32_t</span> size)\n&#123;\n    <span class=\"hljs-built_in\">assert</span>(ring_buf || buffer);\n    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;\n    size  = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;in - ring_buf-&gt;out);        \n    <span class=\"hljs-comment\">/* first get the data from fifo-&gt;out until the end of the buffer */</span>\n    len = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;size - (ring_buf-&gt;out &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)));\n    <span class=\"hljs-built_in\">memcpy</span>(buffer, ring_buf-&gt;buffer + (ring_buf-&gt;out &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)), len);\n    <span class=\"hljs-comment\">/* then get the rest (if any) from the beginning of the buffer */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(buffer + len, ring_buf-&gt;buffer, size - len);\n    ring_buf-&gt;out += size;\n    <span class=\"hljs-keyword\">return</span> size;\n&#125;\n<span class=\"hljs-comment\">//向缓冲区中存放数据</span>\n<span class=\"hljs-type\">uint32_t</span> __ring_buffer_put(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size)\n&#123;\n    <span class=\"hljs-built_in\">assert</span>(ring_buf || buffer);\n    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;\n    size = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;size - ring_buf-&gt;in + ring_buf-&gt;out);\n    <span class=\"hljs-comment\">/* first put the data starting from fifo-&gt;in to buffer end */</span>\n    len  = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;size - (ring_buf-&gt;in &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)));\n    <span class=\"hljs-built_in\">memcpy</span>(ring_buf-&gt;buffer + (ring_buf-&gt;in &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)), buffer, len);\n    <span class=\"hljs-comment\">/* then put the rest (if any) at the beginning of the buffer */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(ring_buf-&gt;buffer, buffer + len, size - len);\n    ring_buf-&gt;in += size;\n    <span class=\"hljs-keyword\">return</span> size;\n&#125;\n \n<span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">ring_buffer_len</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">pthread_mutex_lock</span>(ring_buf-&gt;f_lock);\n    len = __ring_buffer_len(ring_buf);\n    <span class=\"hljs-built_in\">pthread_mutex_unlock</span>(ring_buf-&gt;f_lock);\n    <span class=\"hljs-keyword\">return</span> len;\n&#125;\n \n<span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">ring_buffer_get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">uint32_t</span> ret;\n    <span class=\"hljs-built_in\">pthread_mutex_lock</span>(ring_buf-&gt;f_lock);\n    ret = __ring_buffer_get(ring_buf, buffer, size);\n    <span class=\"hljs-comment\">//buffer中没有数据</span>\n    <span class=\"hljs-keyword\">if</span> (ring_buf-&gt;in == ring_buf-&gt;out)\n    ring_buf-&gt;in = ring_buf-&gt;out = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">pthread_mutex_unlock</span>(ring_buf-&gt;f_lock);\n    <span class=\"hljs-keyword\">return</span> ret;\n&#125;\n \n<span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">ring_buffer_put</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">uint32_t</span> ret;\n    <span class=\"hljs-built_in\">pthread_mutex_lock</span>(ring_buf-&gt;f_lock);\n    ret = __ring_buffer_put(ring_buf, buffer, size);\n    <span class=\"hljs-built_in\">pthread_mutex_unlock</span>(ring_buf-&gt;f_lock);\n    <span class=\"hljs-keyword\">return</span> ret;\n&#125;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n</code></pre>\n\n<p>使用栗子，采用多线程模拟生产者和消费者编写测试程序，如下所示：</p>\n<pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**@brief ring buffer测试程序，创建两个线程，一个生产者，一个消费者。</span>\n<span class=\"hljs-comment\"> * 生产者每隔1秒向buffer中投入数据，消费者每隔2秒去取数据。</span>\n<span class=\"hljs-comment\"> * */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ring_buffer.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;pthread.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> BUFFER_SIZE  1024 * 1024</span>\n \n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">student_info</span></span>\n<span class=\"hljs-class\">&#123;</span>\n    <span class=\"hljs-type\">uint64_t</span> stu_id;\n    <span class=\"hljs-type\">uint32_t</span> age;\n    <span class=\"hljs-type\">uint32_t</span> score;\n&#125;student_info;\n \n \n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">print_student_info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> student_info *stu_info)</span>\n&#123;\n    assert(stu_info);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;id:%lu\\t&quot;</span>,stu_info-&gt;stu_id);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;age:%u\\t&quot;</span>,stu_info-&gt;age);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;score:%u\\n&quot;</span>,stu_info-&gt;score);\n&#125;\n \nstudent_info * <span class=\"hljs-title function_\">get_student_info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">time_t</span> timer)</span>\n&#123;\n    student_info *stu_info = (student_info *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(student_info));\n    <span class=\"hljs-keyword\">if</span> (!stu_info)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to malloc memory.\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;\n    &#125;\n    srand(timer);\n    stu_info-&gt;stu_id = <span class=\"hljs-number\">10000</span> + rand() % <span class=\"hljs-number\">9999</span>;\n    stu_info-&gt;age = rand() % <span class=\"hljs-number\">30</span>;\n    stu_info-&gt;score = rand() % <span class=\"hljs-number\">101</span>;\n    print_student_info(stu_info);\n    <span class=\"hljs-keyword\">return</span> stu_info;\n&#125;\n \n<span class=\"hljs-type\">void</span> * <span class=\"hljs-title function_\">consumer_proc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ring_buffer</span> *<span class=\"hljs-title\">ring_buf</span> =</span> (<span class=\"hljs-keyword\">struct</span> ring_buffer *)arg;\n    student_info stu_info; \n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)\n    &#123;\n    sleep(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------------------------------\\n&quot;</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get a student info from ring buffer.\\n&quot;</span>);\n    ring_buffer_get(ring_buf, (<span class=\"hljs-type\">void</span> *)&amp;stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ring buffer length: %u\\n&quot;</span>, ring_buffer_len(ring_buf));\n    print_student_info(&amp;stu_info);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------------------------------\\n&quot;</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">void</span> *)ring_buf;\n&#125;\n \n<span class=\"hljs-type\">void</span> * <span class=\"hljs-title function_\">producer_proc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-type\">time_t</span> cur_time;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ring_buffer</span> *<span class=\"hljs-title\">ring_buf</span> =</span> (<span class=\"hljs-keyword\">struct</span> ring_buffer *)arg;\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)\n    &#123;\n    time(&amp;cur_time);\n    srand(cur_time);\n    <span class=\"hljs-type\">int</span> seed = rand() % <span class=\"hljs-number\">11111</span>;\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;******************************************\\n&quot;</span>);\n    student_info *stu_info = get_student_info(cur_time + seed);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;put a student info to ring buffer.\\n&quot;</span>);\n    ring_buffer_put(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ring buffer length: %u\\n&quot;</span>, ring_buffer_len(ring_buf));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;******************************************\\n&quot;</span>);\n    sleep(<span class=\"hljs-number\">1</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">void</span> *)ring_buf;\n&#125;\n \n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">consumer_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-type\">int</span> err;\n    <span class=\"hljs-type\">pthread_t</span> tid;\n    err = pthread_create(&amp;tid, <span class=\"hljs-literal\">NULL</span>, consumer_proc, arg);\n    <span class=\"hljs-keyword\">if</span> (err != <span class=\"hljs-number\">0</span>)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to create consumer thread.errno:%u, reason:%s\\n&quot;</span>,\n        errno, strerror(errno));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> tid;\n&#125;\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">producer_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-type\">int</span> err;\n    <span class=\"hljs-type\">pthread_t</span> tid;\n    err = pthread_create(&amp;tid, <span class=\"hljs-literal\">NULL</span>, producer_proc, arg);\n    <span class=\"hljs-keyword\">if</span> (err != <span class=\"hljs-number\">0</span>)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to create consumer thread.errno:%u, reason:%s\\n&quot;</span>,\n        errno, strerror(errno));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> tid;\n&#125;\n \n \n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n&#123;\n    <span class=\"hljs-type\">void</span> * buffer = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-type\">uint32_t</span> size = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ring_buffer</span> *<span class=\"hljs-title\">ring_buf</span> =</span> <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-type\">pthread_t</span> consume_pid, produce_pid;\n \n    <span class=\"hljs-type\">pthread_mutex_t</span> *f_lock = (<span class=\"hljs-type\">pthread_mutex_t</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">pthread_mutex_t</span>));\n    <span class=\"hljs-keyword\">if</span> (pthread_mutex_init(f_lock, <span class=\"hljs-literal\">NULL</span>) != <span class=\"hljs-number\">0</span>)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed init mutex,errno:%u,reason:%s\\n&quot;</span>,\n        errno, strerror(errno));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    buffer = (<span class=\"hljs-type\">void</span> *)<span class=\"hljs-built_in\">malloc</span>(BUFFER_SIZE);\n    <span class=\"hljs-keyword\">if</span> (!buffer)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to malloc memory.\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    size = BUFFER_SIZE;\n    ring_buf = ring_buffer_init(buffer, size, f_lock);\n    <span class=\"hljs-keyword\">if</span> (!ring_buf)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to init ring buffer.\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> 0</span>\n    student_info *stu_info = get_student_info(<span class=\"hljs-number\">638946124</span>);\n    ring_buffer_put(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    stu_info = get_student_info(<span class=\"hljs-number\">976686464</span>);\n    ring_buffer_put(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    ring_buffer_get(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    print_student_info(stu_info);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;multi thread test.......\\n&quot;</span>);\n    produce_pid  = producer_thread((<span class=\"hljs-type\">void</span>*)ring_buf);\n    consume_pid  = consumer_thread((<span class=\"hljs-type\">void</span>*)ring_buf);\n    pthread_join(produce_pid, <span class=\"hljs-literal\">NULL</span>);\n    pthread_join(consume_pid, <span class=\"hljs-literal\">NULL</span>);\n    ring_buffer_free(ring_buf);\n    <span class=\"hljs-built_in\">free</span>(f_lock);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n&#125;\n</code></pre>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.cnblogs.com/Anker/p/3481373.html\">linux内核数据结构之kfifo - Daleshi的技术随笔 - 博客园</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>实现方式非常巧妙，刚开始看的有点奇怪，当发现实现原理后惊讶了一番..</p>\n<pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**@brief 仿照linux kfifo写的ring buffer</span>\n<span class=\"hljs-comment\">* ring_buffer.h</span>\n<span class=\"hljs-comment\"> * */</span>\n \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> KFIFO_HEADER_H </span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> KFIFO_HEADER_H</span>\n \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;errno.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\n \n<span class=\"hljs-comment\">//判断x是否是2的次方</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> is_power_of_2(x) ((x) != 0 &amp;&amp; (((x) &amp; ((x) - 1)) == 0))</span>\n<span class=\"hljs-comment\">//取a和b中最小值</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span>\n \n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ring_buffer</span>\n&#123;\n    <span class=\"hljs-type\">void</span>         *buffer;     <span class=\"hljs-comment\">//缓冲区</span>\n    <span class=\"hljs-type\">uint32_t</span>     size;       <span class=\"hljs-comment\">//大小</span>\n    <span class=\"hljs-type\">uint32_t</span>     in;         <span class=\"hljs-comment\">//入口位置</span>\n    <span class=\"hljs-type\">uint32_t</span>       out;        <span class=\"hljs-comment\">//出口位置</span>\n    <span class=\"hljs-type\">pthread_mutex_t</span> *f_lock;    <span class=\"hljs-comment\">//互斥锁</span>\n&#125;;\n<span class=\"hljs-comment\">//初始化缓冲区</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ring_buffer</span>* <span class=\"hljs-built_in\">ring_buffer_init</span>(<span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size, <span class=\"hljs-type\">pthread_mutex_t</span> *f_lock)\n&#123;\n    <span class=\"hljs-built_in\">assert</span>(buffer);\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">ring_buffer</span> *ring_buf = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">is_power_of_2</span>(size))\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(stderr,<span class=\"hljs-string\">&quot;size must be power of 2.\\n&quot;</span>);\n        <span class=\"hljs-keyword\">return</span> ring_buf;\n    &#125;\n    ring_buf = (<span class=\"hljs-keyword\">struct</span> ring_buffer *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> ring_buffer));\n    <span class=\"hljs-keyword\">if</span> (!ring_buf)\n    &#123;\n        <span class=\"hljs-built_in\">fprintf</span>(stderr,<span class=\"hljs-string\">&quot;Failed to malloc memory,errno:%u,reason:%s&quot;</span>,\n            errno, <span class=\"hljs-built_in\">strerror</span>(errno));\n        <span class=\"hljs-keyword\">return</span> ring_buf;\n    &#125;\n    <span class=\"hljs-built_in\">memset</span>(ring_buf, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> ring_buffer));\n    ring_buf-&gt;buffer = buffer;\n    ring_buf-&gt;size = size;\n    ring_buf-&gt;in = <span class=\"hljs-number\">0</span>;\n    ring_buf-&gt;out = <span class=\"hljs-number\">0</span>;\n        ring_buf-&gt;f_lock = f_lock;\n    <span class=\"hljs-keyword\">return</span> ring_buf;\n&#125;\n<span class=\"hljs-comment\">//释放缓冲区</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ring_buffer_free</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (ring_buf)\n    &#123;\n    <span class=\"hljs-keyword\">if</span> (ring_buf-&gt;buffer)\n    &#123;\n        <span class=\"hljs-built_in\">free</span>(ring_buf-&gt;buffer);\n        ring_buf-&gt;buffer = <span class=\"hljs-literal\">NULL</span>;\n    &#125;\n    <span class=\"hljs-built_in\">free</span>(ring_buf);\n    ring_buf = <span class=\"hljs-literal\">NULL</span>;\n    &#125;\n&#125;\n \n<span class=\"hljs-comment\">//缓冲区的长度</span>\n<span class=\"hljs-type\">uint32_t</span> __ring_buffer_len(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf)\n&#123;\n    <span class=\"hljs-keyword\">return</span> (ring_buf-&gt;in - ring_buf-&gt;out);\n&#125;\n \n<span class=\"hljs-comment\">//从缓冲区中取数据</span>\n<span class=\"hljs-type\">uint32_t</span> __ring_buffer_get(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> * buffer, <span class=\"hljs-type\">uint32_t</span> size)\n&#123;\n    <span class=\"hljs-built_in\">assert</span>(ring_buf || buffer);\n    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;\n    size  = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;in - ring_buf-&gt;out);        \n    <span class=\"hljs-comment\">/* first get the data from fifo-&gt;out until the end of the buffer */</span>\n    len = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;size - (ring_buf-&gt;out &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)));\n    <span class=\"hljs-built_in\">memcpy</span>(buffer, ring_buf-&gt;buffer + (ring_buf-&gt;out &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)), len);\n    <span class=\"hljs-comment\">/* then get the rest (if any) from the beginning of the buffer */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(buffer + len, ring_buf-&gt;buffer, size - len);\n    ring_buf-&gt;out += size;\n    <span class=\"hljs-keyword\">return</span> size;\n&#125;\n<span class=\"hljs-comment\">//向缓冲区中存放数据</span>\n<span class=\"hljs-type\">uint32_t</span> __ring_buffer_put(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size)\n&#123;\n    <span class=\"hljs-built_in\">assert</span>(ring_buf || buffer);\n    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;\n    size = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;size - ring_buf-&gt;in + ring_buf-&gt;out);\n    <span class=\"hljs-comment\">/* first put the data starting from fifo-&gt;in to buffer end */</span>\n    len  = <span class=\"hljs-built_in\">min</span>(size, ring_buf-&gt;size - (ring_buf-&gt;in &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)));\n    <span class=\"hljs-built_in\">memcpy</span>(ring_buf-&gt;buffer + (ring_buf-&gt;in &amp; (ring_buf-&gt;size - <span class=\"hljs-number\">1</span>)), buffer, len);\n    <span class=\"hljs-comment\">/* then put the rest (if any) at the beginning of the buffer */</span>\n    <span class=\"hljs-built_in\">memcpy</span>(ring_buf-&gt;buffer, buffer + len, size - len);\n    ring_buf-&gt;in += size;\n    <span class=\"hljs-keyword\">return</span> size;\n&#125;\n \n<span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">ring_buffer_len</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">uint32_t</span> len = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">pthread_mutex_lock</span>(ring_buf-&gt;f_lock);\n    len = __ring_buffer_len(ring_buf);\n    <span class=\"hljs-built_in\">pthread_mutex_unlock</span>(ring_buf-&gt;f_lock);\n    <span class=\"hljs-keyword\">return</span> len;\n&#125;\n \n<span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">ring_buffer_get</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">uint32_t</span> ret;\n    <span class=\"hljs-built_in\">pthread_mutex_lock</span>(ring_buf-&gt;f_lock);\n    ret = __ring_buffer_get(ring_buf, buffer, size);\n    <span class=\"hljs-comment\">//buffer中没有数据</span>\n    <span class=\"hljs-keyword\">if</span> (ring_buf-&gt;in == ring_buf-&gt;out)\n    ring_buf-&gt;in = ring_buf-&gt;out = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">pthread_mutex_unlock</span>(ring_buf-&gt;f_lock);\n    <span class=\"hljs-keyword\">return</span> ret;\n&#125;\n \n<span class=\"hljs-function\"><span class=\"hljs-type\">uint32_t</span> <span class=\"hljs-title\">ring_buffer_put</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> ring_buffer *ring_buf, <span class=\"hljs-type\">void</span> *buffer, <span class=\"hljs-type\">uint32_t</span> size)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">uint32_t</span> ret;\n    <span class=\"hljs-built_in\">pthread_mutex_lock</span>(ring_buf-&gt;f_lock);\n    ret = __ring_buffer_put(ring_buf, buffer, size);\n    <span class=\"hljs-built_in\">pthread_mutex_unlock</span>(ring_buf-&gt;f_lock);\n    <span class=\"hljs-keyword\">return</span> ret;\n&#125;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n</code></pre>\n\n<p>使用栗子，采用多线程模拟生产者和消费者编写测试程序，如下所示：</p>\n<pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**@brief ring buffer测试程序，创建两个线程，一个生产者，一个消费者。</span>\n<span class=\"hljs-comment\"> * 生产者每隔1秒向buffer中投入数据，消费者每隔2秒去取数据。</span>\n<span class=\"hljs-comment\"> * */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;ring_buffer.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;pthread.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> BUFFER_SIZE  1024 * 1024</span>\n \n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">student_info</span></span>\n<span class=\"hljs-class\">&#123;</span>\n    <span class=\"hljs-type\">uint64_t</span> stu_id;\n    <span class=\"hljs-type\">uint32_t</span> age;\n    <span class=\"hljs-type\">uint32_t</span> score;\n&#125;student_info;\n \n \n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">print_student_info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> student_info *stu_info)</span>\n&#123;\n    assert(stu_info);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;id:%lu\\t&quot;</span>,stu_info-&gt;stu_id);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;age:%u\\t&quot;</span>,stu_info-&gt;age);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;score:%u\\n&quot;</span>,stu_info-&gt;score);\n&#125;\n \nstudent_info * <span class=\"hljs-title function_\">get_student_info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">time_t</span> timer)</span>\n&#123;\n    student_info *stu_info = (student_info *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(student_info));\n    <span class=\"hljs-keyword\">if</span> (!stu_info)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to malloc memory.\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;\n    &#125;\n    srand(timer);\n    stu_info-&gt;stu_id = <span class=\"hljs-number\">10000</span> + rand() % <span class=\"hljs-number\">9999</span>;\n    stu_info-&gt;age = rand() % <span class=\"hljs-number\">30</span>;\n    stu_info-&gt;score = rand() % <span class=\"hljs-number\">101</span>;\n    print_student_info(stu_info);\n    <span class=\"hljs-keyword\">return</span> stu_info;\n&#125;\n \n<span class=\"hljs-type\">void</span> * <span class=\"hljs-title function_\">consumer_proc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ring_buffer</span> *<span class=\"hljs-title\">ring_buf</span> =</span> (<span class=\"hljs-keyword\">struct</span> ring_buffer *)arg;\n    student_info stu_info; \n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)\n    &#123;\n    sleep(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------------------------------\\n&quot;</span>);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get a student info from ring buffer.\\n&quot;</span>);\n    ring_buffer_get(ring_buf, (<span class=\"hljs-type\">void</span> *)&amp;stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ring buffer length: %u\\n&quot;</span>, ring_buffer_len(ring_buf));\n    print_student_info(&amp;stu_info);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------------------------------\\n&quot;</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">void</span> *)ring_buf;\n&#125;\n \n<span class=\"hljs-type\">void</span> * <span class=\"hljs-title function_\">producer_proc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-type\">time_t</span> cur_time;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ring_buffer</span> *<span class=\"hljs-title\">ring_buf</span> =</span> (<span class=\"hljs-keyword\">struct</span> ring_buffer *)arg;\n    <span class=\"hljs-keyword\">while</span>(<span class=\"hljs-number\">1</span>)\n    &#123;\n    time(&amp;cur_time);\n    srand(cur_time);\n    <span class=\"hljs-type\">int</span> seed = rand() % <span class=\"hljs-number\">11111</span>;\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;******************************************\\n&quot;</span>);\n    student_info *stu_info = get_student_info(cur_time + seed);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;put a student info to ring buffer.\\n&quot;</span>);\n    ring_buffer_put(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ring buffer length: %u\\n&quot;</span>, ring_buffer_len(ring_buf));\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;******************************************\\n&quot;</span>);\n    sleep(<span class=\"hljs-number\">1</span>);\n    &#125;\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">void</span> *)ring_buf;\n&#125;\n \n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">consumer_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-type\">int</span> err;\n    <span class=\"hljs-type\">pthread_t</span> tid;\n    err = pthread_create(&amp;tid, <span class=\"hljs-literal\">NULL</span>, consumer_proc, arg);\n    <span class=\"hljs-keyword\">if</span> (err != <span class=\"hljs-number\">0</span>)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to create consumer thread.errno:%u, reason:%s\\n&quot;</span>,\n        errno, strerror(errno));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> tid;\n&#125;\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">producer_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span>\n&#123;\n    <span class=\"hljs-type\">int</span> err;\n    <span class=\"hljs-type\">pthread_t</span> tid;\n    err = pthread_create(&amp;tid, <span class=\"hljs-literal\">NULL</span>, producer_proc, arg);\n    <span class=\"hljs-keyword\">if</span> (err != <span class=\"hljs-number\">0</span>)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to create consumer thread.errno:%u, reason:%s\\n&quot;</span>,\n        errno, strerror(errno));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> tid;\n&#125;\n \n \n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n&#123;\n    <span class=\"hljs-type\">void</span> * buffer = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-type\">uint32_t</span> size = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">ring_buffer</span> *<span class=\"hljs-title\">ring_buf</span> =</span> <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-type\">pthread_t</span> consume_pid, produce_pid;\n \n    <span class=\"hljs-type\">pthread_mutex_t</span> *f_lock = (<span class=\"hljs-type\">pthread_mutex_t</span> *)<span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">pthread_mutex_t</span>));\n    <span class=\"hljs-keyword\">if</span> (pthread_mutex_init(f_lock, <span class=\"hljs-literal\">NULL</span>) != <span class=\"hljs-number\">0</span>)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed init mutex,errno:%u,reason:%s\\n&quot;</span>,\n        errno, strerror(errno));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    buffer = (<span class=\"hljs-type\">void</span> *)<span class=\"hljs-built_in\">malloc</span>(BUFFER_SIZE);\n    <span class=\"hljs-keyword\">if</span> (!buffer)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to malloc memory.\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    size = BUFFER_SIZE;\n    ring_buf = ring_buffer_init(buffer, size, f_lock);\n    <span class=\"hljs-keyword\">if</span> (!ring_buf)\n    &#123;\n    <span class=\"hljs-built_in\">fprintf</span>(<span class=\"hljs-built_in\">stderr</span>, <span class=\"hljs-string\">&quot;Failed to init ring buffer.\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> 0</span>\n    student_info *stu_info = get_student_info(<span class=\"hljs-number\">638946124</span>);\n    ring_buffer_put(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    stu_info = get_student_info(<span class=\"hljs-number\">976686464</span>);\n    ring_buffer_put(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    ring_buffer_get(ring_buf, (<span class=\"hljs-type\">void</span> *)stu_info, <span class=\"hljs-keyword\">sizeof</span>(student_info));\n    print_student_info(stu_info);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;multi thread test.......\\n&quot;</span>);\n    produce_pid  = producer_thread((<span class=\"hljs-type\">void</span>*)ring_buf);\n    consume_pid  = consumer_thread((<span class=\"hljs-type\">void</span>*)ring_buf);\n    pthread_join(produce_pid, <span class=\"hljs-literal\">NULL</span>);\n    pthread_join(consume_pid, <span class=\"hljs-literal\">NULL</span>);\n    ring_buffer_free(ring_buf);\n    <span class=\"hljs-built_in\">free</span>(f_lock);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n&#125;\n</code></pre>\n\n<h2 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h2><p><a href=\"https://www.cnblogs.com/Anker/p/3481373.html\">linux内核数据结构之kfifo - Daleshi的技术随笔 - 博客园</a></p>\n"},{"title":"linux 安装指定版本MySql","date":"2020-01-23T07:12:39.000Z","_content":"\n由于工作环境、生产环境，我们使用的操作系统为为CentOS6.9，所需mysql版本为5.7，目前CentOS6.x系统默认mysql版本为5.1，这个版本是实在是太旧了。\n\n### 彻底卸载系统已经安装的旧版本\n- 检查系统已经安装的mysql\n` rpm -qa|grep -i mysql`\n\n- 删除包\n`rpm -ev mysql_lib_xxxx`\n\n- 删除老版本安装残留文件\n`find / -iname mysql*` 删除对应目录已经文件\n\n- 删除my.cnf配置文件\n\n### 使用yum安装MySql5.7\n\n- 下载mysql5.7源\n`wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm`\n\n- 安装源\n`yum localinstall mysql-community-release-el6-5.noarch.rpm`\n\n- 查看可用源中包含哪些版本并开启指定版本\n```\nyum repolist all | grep mysql\nyum-config-manager --disable mysql56-community\nyum-config-manager --disable mysql55-community\nyum-config-manager --enable mysql57-community\n```\n\n- yum安装mysql\n`yum install mysql-community-server`\n\n- 启动mysql\n`service mysqld start`\n\n- 设置开机自动启动\n\n```\nchkconfig --list | grep mysqld\nchkconfig mysqld on\n```\n\n- 安装设置命令\n`mysql_secure_installation`\n\n### 修改root密码\n因为刚才启动的时候是系统默认配置的临时密码\n使用如下命令可以查看，并且修改：\n```\nsudo grep 'temporary password' /var/log/mysqld.log\nmysql -u root -p \nALTER USER 'root'@'localhost' IDENTIFIED BY 'newPassword';\n```\n\n### 设置允许连接数据库\n命令如下：\n```\nmysql -u root -p \ngrant all privileges on *.* to root@\"%\" identified by 'passwordith grant option;  \nflush privileges;\n```\n\n### 遇到的问题\n- 比较奇怪，域名解析错误\n 在yum install 的时候，发现大量的[Errno 14] PYCURL ERROR 6 - \"Couldn't resolve host 'mirrors.aliyun.com'\"错误，开始以为自己源设置错误，后来才知道，机器卡死过一次，导致系统莫名其妙的错误，了解网络的很快就知道需要设置系统的DNS\n 在`/etc/resolv.conf`文件中加入如下内容：\n ```\n nameserver 8.8.8.8\n  nameserver 114.114.114.114\n ```\n 之前是啥也没有的，都是些没用的注释解释信息","source":"_posts/linux 安装指定版本MySql.md","raw":"---\ntitle: linux 安装指定版本MySql\ndate: 2020-01-23 15:12:39\ntags: linux\ncategories: Mysql\n---\n\n由于工作环境、生产环境，我们使用的操作系统为为CentOS6.9，所需mysql版本为5.7，目前CentOS6.x系统默认mysql版本为5.1，这个版本是实在是太旧了。\n\n### 彻底卸载系统已经安装的旧版本\n- 检查系统已经安装的mysql\n` rpm -qa|grep -i mysql`\n\n- 删除包\n`rpm -ev mysql_lib_xxxx`\n\n- 删除老版本安装残留文件\n`find / -iname mysql*` 删除对应目录已经文件\n\n- 删除my.cnf配置文件\n\n### 使用yum安装MySql5.7\n\n- 下载mysql5.7源\n`wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm`\n\n- 安装源\n`yum localinstall mysql-community-release-el6-5.noarch.rpm`\n\n- 查看可用源中包含哪些版本并开启指定版本\n```\nyum repolist all | grep mysql\nyum-config-manager --disable mysql56-community\nyum-config-manager --disable mysql55-community\nyum-config-manager --enable mysql57-community\n```\n\n- yum安装mysql\n`yum install mysql-community-server`\n\n- 启动mysql\n`service mysqld start`\n\n- 设置开机自动启动\n\n```\nchkconfig --list | grep mysqld\nchkconfig mysqld on\n```\n\n- 安装设置命令\n`mysql_secure_installation`\n\n### 修改root密码\n因为刚才启动的时候是系统默认配置的临时密码\n使用如下命令可以查看，并且修改：\n```\nsudo grep 'temporary password' /var/log/mysqld.log\nmysql -u root -p \nALTER USER 'root'@'localhost' IDENTIFIED BY 'newPassword';\n```\n\n### 设置允许连接数据库\n命令如下：\n```\nmysql -u root -p \ngrant all privileges on *.* to root@\"%\" identified by 'passwordith grant option;  \nflush privileges;\n```\n\n### 遇到的问题\n- 比较奇怪，域名解析错误\n 在yum install 的时候，发现大量的[Errno 14] PYCURL ERROR 6 - \"Couldn't resolve host 'mirrors.aliyun.com'\"错误，开始以为自己源设置错误，后来才知道，机器卡死过一次，导致系统莫名其妙的错误，了解网络的很快就知道需要设置系统的DNS\n 在`/etc/resolv.conf`文件中加入如下内容：\n ```\n nameserver 8.8.8.8\n  nameserver 114.114.114.114\n ```\n 之前是啥也没有的，都是些没用的注释解释信息","slug":"linux 安装指定版本MySql","published":1,"updated":"2020-01-23T07:12:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzfz000fokec584d2ap0","content":"<p>由于工作环境、生产环境，我们使用的操作系统为为CentOS6.9，所需mysql版本为5.7，目前CentOS6.x系统默认mysql版本为5.1，这个版本是实在是太旧了。</p>\n<h3 id=\"彻底卸载系统已经安装的旧版本\"><a href=\"#彻底卸载系统已经安装的旧版本\" class=\"headerlink\" title=\"彻底卸载系统已经安装的旧版本\"></a>彻底卸载系统已经安装的旧版本</h3><ul>\n<li><p>检查系统已经安装的mysql<br><code> rpm -qa|grep -i mysql</code></p>\n</li>\n<li><p>删除包<br><code>rpm -ev mysql_lib_xxxx</code></p>\n</li>\n<li><p>删除老版本安装残留文件<br><code>find / -iname mysql*</code> 删除对应目录已经文件</p>\n</li>\n<li><p>删除my.cnf配置文件</p>\n</li>\n</ul>\n<h3 id=\"使用yum安装MySql5-7\"><a href=\"#使用yum安装MySql5-7\" class=\"headerlink\" title=\"使用yum安装MySql5.7\"></a>使用yum安装MySql5.7</h3><ul>\n<li><p>下载mysql5.7源<br><code>wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm</code></p>\n</li>\n<li><p>安装源<br><code>yum localinstall mysql-community-release-el6-5.noarch.rpm</code></p>\n</li>\n<li><p>查看可用源中包含哪些版本并开启指定版本</p>\n<pre><code class=\"hljs lua\">yum repolist all | grep mysql\nyum-<span class=\"hljs-built_in\">config</span>-manager <span class=\"hljs-comment\">--disable mysql56-community</span>\nyum-<span class=\"hljs-built_in\">config</span>-manager <span class=\"hljs-comment\">--disable mysql55-community</span>\nyum-<span class=\"hljs-built_in\">config</span>-manager <span class=\"hljs-comment\">--enable mysql57-community</span></code></pre>\n</li>\n<li><p>yum安装mysql<br><code>yum install mysql-community-server</code></p>\n</li>\n<li><p>启动mysql<br><code>service mysqld start</code></p>\n</li>\n<li><p>设置开机自动启动</p>\n</li>\n</ul>\n<pre><code class=\"hljs applescript\">chkconfig <span class=\"hljs-comment\">--list | grep mysqld</span>\nchkconfig mysqld <span class=\"hljs-keyword\">on</span></code></pre>\n\n<ul>\n<li>安装设置命令<br><code>mysql_secure_installation</code></li>\n</ul>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>因为刚才启动的时候是系统默认配置的临时密码<br>使用如下命令可以查看，并且修改：</p>\n<pre><code class=\"hljs pgsql\">sudo grep <span class=\"hljs-string\">&#x27;temporary password&#x27;</span> /var/<span class=\"hljs-keyword\">log</span>/mysqld.<span class=\"hljs-keyword\">log</span>\nmysql -u root -p \n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;root&#x27;</span>@<span class=\"hljs-string\">&#x27;localhost&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;newPassword&#x27;</span>;</code></pre>\n\n<h3 id=\"设置允许连接数据库\"><a href=\"#设置允许连接数据库\" class=\"headerlink\" title=\"设置允许连接数据库\"></a>设置允许连接数据库</h3><p>命令如下：</p>\n<pre><code class=\"hljs pgsql\">mysql -u root -p \n<span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">privileges</span> <span class=\"hljs-keyword\">on</span> *.* <span class=\"hljs-keyword\">to</span> root@&quot;%&quot; identified <span class=\"hljs-keyword\">by</span> <span class=\"hljs-string\">&#x27;passwordith grant option;  </span>\n<span class=\"hljs-string\">flush privileges;</span></code></pre>\n\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>比较奇怪，域名解析错误<br> 在yum install 的时候，发现大量的[Errno 14] PYCURL ERROR 6 - “Couldn’t resolve host ‘mirrors.aliyun.com’”错误，开始以为自己源设置错误，后来才知道，机器卡死过一次，导致系统莫名其妙的错误，了解网络的很快就知道需要设置系统的DNS<br> 在<code>/etc/resolv.conf</code>文件中加入如下内容： <pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">nameserver</span> <span class=\"hljs-number\">8.8.8.8</span>\n nameserver <span class=\"hljs-number\">114.114.114.114</span></code></pre>\n 之前是啥也没有的，都是些没用的注释解释信息</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>由于工作环境、生产环境，我们使用的操作系统为为CentOS6.9，所需mysql版本为5.7，目前CentOS6.x系统默认mysql版本为5.1，这个版本是实在是太旧了。</p>\n<h3 id=\"彻底卸载系统已经安装的旧版本\"><a href=\"#彻底卸载系统已经安装的旧版本\" class=\"headerlink\" title=\"彻底卸载系统已经安装的旧版本\"></a>彻底卸载系统已经安装的旧版本</h3><ul>\n<li><p>检查系统已经安装的mysql<br><code> rpm -qa|grep -i mysql</code></p>\n</li>\n<li><p>删除包<br><code>rpm -ev mysql_lib_xxxx</code></p>\n</li>\n<li><p>删除老版本安装残留文件<br><code>find / -iname mysql*</code> 删除对应目录已经文件</p>\n</li>\n<li><p>删除my.cnf配置文件</p>\n</li>\n</ul>\n<h3 id=\"使用yum安装MySql5-7\"><a href=\"#使用yum安装MySql5-7\" class=\"headerlink\" title=\"使用yum安装MySql5.7\"></a>使用yum安装MySql5.7</h3><ul>\n<li><p>下载mysql5.7源<br><code>wget dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm</code></p>\n</li>\n<li><p>安装源<br><code>yum localinstall mysql-community-release-el6-5.noarch.rpm</code></p>\n</li>\n<li><p>查看可用源中包含哪些版本并开启指定版本</p>\n<pre><code class=\"hljs lua\">yum repolist all | grep mysql\nyum-<span class=\"hljs-built_in\">config</span>-manager <span class=\"hljs-comment\">--disable mysql56-community</span>\nyum-<span class=\"hljs-built_in\">config</span>-manager <span class=\"hljs-comment\">--disable mysql55-community</span>\nyum-<span class=\"hljs-built_in\">config</span>-manager <span class=\"hljs-comment\">--enable mysql57-community</span></code></pre>\n</li>\n<li><p>yum安装mysql<br><code>yum install mysql-community-server</code></p>\n</li>\n<li><p>启动mysql<br><code>service mysqld start</code></p>\n</li>\n<li><p>设置开机自动启动</p>\n</li>\n</ul>\n<pre><code class=\"hljs applescript\">chkconfig <span class=\"hljs-comment\">--list | grep mysqld</span>\nchkconfig mysqld <span class=\"hljs-keyword\">on</span></code></pre>\n\n<ul>\n<li>安装设置命令<br><code>mysql_secure_installation</code></li>\n</ul>\n<h3 id=\"修改root密码\"><a href=\"#修改root密码\" class=\"headerlink\" title=\"修改root密码\"></a>修改root密码</h3><p>因为刚才启动的时候是系统默认配置的临时密码<br>使用如下命令可以查看，并且修改：</p>\n<pre><code class=\"hljs pgsql\">sudo grep <span class=\"hljs-string\">&#x27;temporary password&#x27;</span> /var/<span class=\"hljs-keyword\">log</span>/mysqld.<span class=\"hljs-keyword\">log</span>\nmysql -u root -p \n<span class=\"hljs-keyword\">ALTER</span> <span class=\"hljs-keyword\">USER</span> <span class=\"hljs-string\">&#x27;root&#x27;</span>@<span class=\"hljs-string\">&#x27;localhost&#x27;</span> IDENTIFIED <span class=\"hljs-keyword\">BY</span> <span class=\"hljs-string\">&#x27;newPassword&#x27;</span>;</code></pre>\n\n<h3 id=\"设置允许连接数据库\"><a href=\"#设置允许连接数据库\" class=\"headerlink\" title=\"设置允许连接数据库\"></a>设置允许连接数据库</h3><p>命令如下：</p>\n<pre><code class=\"hljs pgsql\">mysql -u root -p \n<span class=\"hljs-keyword\">grant</span> <span class=\"hljs-keyword\">all</span> <span class=\"hljs-keyword\">privileges</span> <span class=\"hljs-keyword\">on</span> *.* <span class=\"hljs-keyword\">to</span> root@&quot;%&quot; identified <span class=\"hljs-keyword\">by</span> <span class=\"hljs-string\">&#x27;passwordith grant option;  </span>\n<span class=\"hljs-string\">flush privileges;</span></code></pre>\n\n<h3 id=\"遇到的问题\"><a href=\"#遇到的问题\" class=\"headerlink\" title=\"遇到的问题\"></a>遇到的问题</h3><ul>\n<li>比较奇怪，域名解析错误<br> 在yum install 的时候，发现大量的[Errno 14] PYCURL ERROR 6 - “Couldn’t resolve host ‘mirrors.aliyun.com’”错误，开始以为自己源设置错误，后来才知道，机器卡死过一次，导致系统莫名其妙的错误，了解网络的很快就知道需要设置系统的DNS<br> 在<code>/etc/resolv.conf</code>文件中加入如下内容： <pre><code class=\"hljs nginx\"><span class=\"hljs-attribute\">nameserver</span> <span class=\"hljs-number\">8.8.8.8</span>\n nameserver <span class=\"hljs-number\">114.114.114.114</span></code></pre>\n 之前是啥也没有的，都是些没用的注释解释信息</li>\n</ul>\n"},{"title":"全局唯一ID生成算法优化","date":"2020-01-23T07:12:42.000Z","_content":"\n<!-- toc -->\n\n- [前言](#前言)\n- [Snowflake算法介绍](#Snowflake算法介绍)\n- [SnowFlake算法优化](#SnowFlake算法优化)\n  * [目前算法设计缺陷](#目前算法设计缺陷)\n  * [设计优化](#设计优化)\n- [是否这样就完美了呢？](#是否这样就完美了呢？)\n- [Talk is cheap, show you the code](#Talk-is-cheap-show-you-the-code)\n- [参考文章](#参考文章)\n\n<!-- tocstop -->\n\n## 前言\n\n在进程启动前，一般会给每个进程静态分配一个唯一标识ID(ServerID或者PipeID)\n```\nstruct SServerID\n{\n\tUINT16 wPlatform = 0;\t ///< Platform   平台id \n\tUINT16 wArea = 0;        ///< Area       区服id\n\tUINT16 wType = 0;        ///< Type       服务器App类型\n\tUINT16 wIndex = 0;       ///< Index      服务器App编号索引\n};\n```\n\n每个Role/Item/Hero/Mail 等创建的时候都会创建一个UUID来唯一标识，其中Mail_Uuid还有趋势递增的需求\n\n## Snowflake算法介绍\n\n*SnowFlake分布式生成Id算法由Twitter开源*\n\nSnowFlake算法生成id的结果是一个64bit大小的UINT64整数，它的结构如下图：\n![snowflake uuid-64bit](:storage\\1a51b319-5d9b-40f9-a828-cfc88309cea2\\4dbfceed.png)\n\nSnowFlake的优点: \n\t- 整体上按照时间自增排序\n\t- 整个分布式系统内不会产生ID碰撞(时间戳和自增序列以外的字段作区分), 并且效率较高(位运算),\n\nSnowFlake每秒能够产生6.4万ID左右.(和5段位的配置位数有关)\nUUID从高位到低位依次排列：\n- 第一段：39位, 当对于某一个时间点的时间戳差值（至少10年可用）\n- 第二段：3 位, 平台platform或大区id，比如QQ Android/QQ IOS/Wechat IOS 等（8）\n- 第三段：11位, 区服area id，对应的就是服务器小区的ID（2048）\n- 第四段：5 位, 服务器APP实例id index（32), Notice：appid需要在area范围内唯一\n- 第五段：6 位, 自增长id，也就是说在一个完整的毫秒时间内最多可以生成64个UUID\n\n## SnowFlake算法优化\n\n### 目前算法设计缺陷\n在实际服务器运行过程中，尤其在游戏服务器开发期间，大量用户注册，会有瞬间生成大量UUID的需求\n\n之前服务器的做法是：\n```cpp\n//遍历了一圈64个，等下一个毫秒生成\nif (m_nGlobalSeq == m_nMliSeq)\n{\n\t// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳\n\tnCurTimestamp = WaitForNextMilli(m_nLastTimestamp);\n}\n\n/**\n* 阻塞到下一个毫秒，直到获得新的时间戳\n*\n* @param lastTimestamp 上次生成ID的时间截\n* @return 当前时间戳\n*/\nUINT64 WaitForNextMilli(UINT64 lastTimestamp) const\n{\n\tUINT64 nTimestamp = _GetNowMliTime();\n\twhile (nTimestamp <= lastTimestamp)\n\t{\n\t\tnTimestamp = _GetNowMliTime();\n\t}\n\treturn nTimestamp;\n}\n\n```\n这里使用while强行等待到下一毫秒，相当于阻塞当前线程，从而成为热点函数，需要去优化\n\n### 设计优化\n- 合理分配各字段占用bit（图中已经是调整过的）\n- 将生成uuid单独出一个独立全局Server组件，提供全局唯一UUID服务，这样除去高位39bit外理论上其他bit都可以当作自增位，而且可以提前生成很多uuid放在pool当中，有需要的进程从当中取，可以满足需求，Baidu在github上开源的UUID生成算法就是这样处理的\n- 我们取一个折中方案，只是在server中加一个Pool，存放提前生成好的UUIDs，每次业务端需要UUID的时候首先从Pool中取，如果取不到就走原来的流程\n\n```cpp\nUINT64 GenId()\n{\n\tif (!IsEmpty())\n\t{\n\t\t//从Pool中取\n\t\treturn PopFrontElement();\n\t}\n\n\treturn NextId();\n}\n```\n\n既然存在Pool，那么就需要设计Pool中元素填充方案\n首先将Pool设定一个合适的固定最大值 const UINT32 UUID_POOL_MAX_SIZE = 1 << 13;   //\t\tuuid pool 最大数 8192\n然后根据当前Pool的状态，来定时填充，每次填充的数量为当前毫秒内所有可以生成的UUID数\n![Fill_Pool.png](:storage\\1a51b319-5d9b-40f9-a828-cfc88309cea2\\928daf4a.png)\n\n\n```cpp\n#include \"uuid_pool_mgr.h\"\n#include \"uuid_generator.h\"\n\n\nbool CUUIDPool::Init()\n{\n\tFillUuidPool();\n\treturn true;\n}\n\nvoid CUUIDPool::OnTimer(unsigned int nId)\n{\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : \" << nId;\n\tCUUIDMaker::Instance()->FillPoolWithInMli();\n\tFillUuidPool();\n}\n\nvoid CUUIDPool::FillUuidPool()\n{\n\tEUuidPoolState eUuidDequeState = CUUIDMaker::Instance()->GetUuidDequeState();\n\tuint32 nUpdateInterval = 5 * 60 * 1000;\n\tswitch (eUuidDequeState)\n\t{\n\tcase EUuidPoolState_Empty:\n\t\tnUpdateInterval = 1 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_0_30_Per:\n\t\tnUpdateInterval = 2 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_30_70_Per:\n\t\tnUpdateInterval = 3 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_70_100_Per:\n\t\tnUpdateInterval = 4 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Full:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\tdefault:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\t}\n\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : \" << eUuidDequeState;\n\tSetTimer(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n}\n\n\nenum EUuidPoolState\n{\n\tEUuidPoolState_Empty\t\t\t\t= 1,\n\tEUuidPoolState_Not_Full_0_30_Per\t= 2,\n\tEUuidPoolState_Not_Full_30_70_Per\t= 3,\n\tEUuidPoolState_Not_Full_70_100_Per\t= 4,\n\tEUuidPoolState_Full\t\t\t\t\t= 5,\n};\n\n//uuid_generator.h\n//将当前毫秒内的UUID全部生成并存到Pool中\nvoid FillPoolWithInMli()\n{\n\tEUuidPoolState nCurState = GetUuidDequeState();\n\tAtomicUInt64 nCurTimestamp = _GetNowMliTime();\n\twhile (nCurState != EUuidPoolState_Full)\n\t{\n\t\tUINT64 nNextUUId = NextId(false);\n\t\tif (nNextUUId == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tPushBackElement(nNextUUId);\n\n\t\tif (nCurTimestamp != _GetNowMliTime())\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n```\n\n## 是否这样就完美了呢？\n\n并没有呢！！！\n这个算法强制依赖时间递增，如果时间回拨怎么办？\n目前的做法是直接throw new exception\n分析时间回拨产生原因\n第一：人物操作，在真实环境一般不会有那个傻逼干这种事情，所以基本可以排除。 \n第二：由于有些业务等需要，机器需要同步时间服务器（在这个过程中可能会存在时间回拨，查了下我们服务器一般在10ms以内（2小时同步一次））。 Ntp过程可能产生时间回拨。\n第三：QA和策划测试过程中有需求怎么办？\n解决办法：\n1. 将uuid_generation独立出来给其他server提供服务\n2. 当回拨时间小于XXms，就等时间追上来之后继续生成。 (XXms对业务没有什么影响)\n3. 当时间大于XXms时间我们通过更换AppId位来来解决回拨问题。\n\n## Talk is cheap, show you the code\n```cpp\n#ifndef __UUID_GENERATOR_H__\n#define __UUID_GENERATOR_H__\n\n#include \"gnsingleton.h\"\n#include \"gntype.h\"\n#include \"gnpipe.h\"\n#include \"gntime.h\"\n#include \"noncopy.h\"\n#include \"gnserverid.h\"\n\n#include <assert.h>\n#include <mutex>\n#include <atomic>\n#include <chrono>\n#include <exception>\n#include <sstream>\n#include <deque>\n\nenum EUuidPoolState\n{\n\tEUuidPoolState_Empty\t\t\t\t= 1,\n\tEUuidPoolState_Not_Full_0_30_Per\t= 2,\n\tEUuidPoolState_Not_Full_30_70_Per\t= 3,\n\tEUuidPoolState_Not_Full_70_100_Per\t= 4,\n\tEUuidPoolState_Full\t\t\t\t\t= 5,\n};\n\n//#define SNOWFLAKE_ID_MAKER_NO_LOCK\nclass CSnowflakeIdMaker : private CNoncopy\n{\npublic:\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\ttypedef std::atomic<UINT32> AtomicUInt;\n\ttypedef std::atomic<UINT64> AtomicUInt64;\n#else\n\ttypedef UINT32 AtomicUInt;\n\ttypedef UINT64 AtomicUInt64;\n#endif\n\n\tconst UINT32 UUID_POOL_MAX_SIZE = 1 << 13;   //\t\tuuid pool 最大数 8192\n\tconst UINT64 START_EPOCH\t\t\t= 1541001600000LL;\t\t//开始时间截 (2018-11-01 00:00:00.000)，修改此时间可调整可用时长\n\t\t\t\t\t\t\t   \n\tconst UINT32 A_TIMESTAMP_BITS\t\t= 39;\t\t\t\t\t//时间戳所占的位数\n\tconst UINT32 B_PLATFORM_BITS\t\t= 3;\t\t\t\t\t//平台id所占的位数\n\tconst UINT32 C_AREA_BITS\t\t\t= 11;\t\t\t\t\t//区服id所占的位\n\tconst UINT32 D_APP_ID_BITS\t\t\t= 5;\t\t\t\t\t//app id所占的位数\n\tconst UINT32 E_INCR_SEQUENCE_BITS\t= 6;\t\t\t\t    //自增序列所占的位数\n\n\tconst UINT32 APP_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS;\t\t//APPID向左移位数\n\tconst UINT32 AREA_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS;\t\t\t\t\t\t\t\t\t\t\t//小区id向左移位数\n\tconst UINT32 PLATFORM_ID_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS;\t\t\t\t\t\t//大区id向左移位数\n\tconst UINT32 TIME_STAMP_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS + B_PLATFORM_BITS;\t\t//时间戳向左移位数\n\tconst UINT32 SEQUENCE_MASK\t\t\t= (1 << E_INCR_SEQUENCE_BITS) - 1;\t\t\t\t\t\t\t\t\t\t\t\t//生成序列的掩码\n\n\n\tCSnowflakeIdMaker() : m_nPlatformId(0), m_nAreaId(0), m_nGlobalSeq(0), m_nLastTimestamp(0) {}\n\n\tCSnowflakeIdMaker(const UINT32 nPlatId, const UINT32 nAreaId, const UINT32 nAppId)\n\t{\n\t\tInit(nPlatId, nAreaId, nAppId);\n\t}\n\n\tvoid Init(const UINT32 nPlatId, const UINT32 nAreaId, const UINT32 nAppId)\n\t{\n\t\tm_nPlatformId = nPlatId;\n\t\tm_nAreaId = nAreaId;\n\t\tm_nAppId = nAppId;\n\t}\n\n\tUINT64 GenId()\n\t{\n\t\tif (!IsEmpty())\n\t\t{\n\t\t\treturn PopFrontElement();\n\t\t}\n\n\t\treturn NextId();\n\t}\n\n\t/**\n\t* 获得下一个ID (该方法是线程安全的)\n\t* @param  bCanBlock 参数指定当前函数是否可以阻塞, 默认为true\n\t* @return SnowflakeId\n\t*/\n\tUINT64 NextId(bool bCanBlock = true)\n\t{\n\t\tusing namespace  std;\n\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\t\tstatic AtomicUInt64 nCurTimestamp{ 0 };\n#else\n\t\tstd::unique_lock<std::mutex> oLock{ m_oMutex };\n\t\tAtomicUInt64 nCurTimestamp{ 0 };\n#endif\n\n\t\tnCurTimestamp = _GetNowMliTime();\n\n\t\t// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常\n\t\tif (nCurTimestamp < m_nLastTimestamp)\n\t\t{\n\t\t\tstd::ostringstream oSS;\n\t\t\toSS << \"clock moved backwards.  Refusing to generate id for \" << m_nLastTimestamp - nCurTimestamp << \" milliseconds\";\n\t\t\tthrow std::exception(std::runtime_error(oSS.str()));\n\t\t}\n\n\t\tm_nGlobalSeq = (m_nGlobalSeq + 1) & SEQUENCE_MASK;\n\n\t\t// 为了使id递增+1均匀分布，这里seq跨毫秒也不清0\n\t\tif (m_nLastTimestamp == nCurTimestamp)\n\t\t{\n\t\t\t//遍历了一圈64个，等下一个毫秒生成\n\t\t\tif (m_nGlobalSeq == m_nMliSeq)\n\t\t\t{\n\t\t\t\tif (bCanBlock)\n\t\t\t\t{\n\t\t\t\t\t// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳\n\t\t\t\t\tnCurTimestamp = WaitForNextMilli(m_nLastTimestamp);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tm_nMliSeq = m_nGlobalSeq;\n\t\t}\n\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\t\tm_nLastTimestamp = nCurTimestamp.load();\n#else\n\t\tm_nLastTimestamp = nCurTimestamp;\n#endif\n\n\t\t// 移位并通过或运算拼到一起组成64位的ID\n\t\treturn ((nCurTimestamp - START_EPOCH) << TIME_STAMP_SHIFT)\n\t\t\t| (m_nPlatformId << PLATFORM_ID_SHIFT)\n\t\t\t| (m_nAreaId << AREA_ID_SHIFT)\n\t\t\t| (m_nAppId << APP_ID_SHIFT)\n\t\t\t| (m_nGlobalSeq);\n\t}\n\n\tEUuidPoolState GetUuidDequeState() \n\t{\n\t\tif (m_deUuidPool.empty())\n\t\t{\n\t\t\treturn EUuidPoolState_Empty;\n\t\t}\n\n\t\tsize_t nCurPoolSize = m_deUuidPool.size();\n\t\tif (nCurPoolSize >= UUID_POOL_MAX_SIZE)\n\t\t{\n\t\t\treturn EUuidPoolState_Full;\n\t\t}\n\n\t\tuint32 nCurPercent = nCurPoolSize * 100 / UUID_POOL_MAX_SIZE;\n\t\tif (nCurPercent < 30)\n\t\t{\n\t\t\treturn EUuidPoolState_Not_Full_0_30_Per;\n\t\t}\n\t\telse if (nCurPercent < 70)\n\t\t{\n\t\t\treturn EUuidPoolState_Not_Full_30_70_Per;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn EUuidPoolState_Not_Full_70_100_Per;\n\t\t}\n\n\t\treturn EUuidPoolState_Full;\n\t} \n\n\tvoid FillPoolWithInMli()\n\t{\n\t\tEUuidPoolState nCurState = GetUuidDequeState();\n\t\tAtomicUInt64 nCurTimestamp = _GetNowMliTime();\n\t\twhile (nCurState != EUuidPoolState_Full)\n\t\t{\n\t\t\tUINT64 nNextUUId = NextId(false);\n\t\t\tif (nNextUUId == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPushBackElement(nNextUUId);\n\n\t\t\tif (nCurTimestamp != _GetNowMliTime())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nprotected:\n\n\t//判断pool是否为空\n\tbool IsEmpty()\n\t{\n\t\treturn m_deUuidPool.empty();\n\t}\n\n\t//返回pool队列中front 元素\n\tUINT64 PopFrontElement()\n\t{\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\t\t\n#else\n\t\tstd::unique_lock<std::mutex> oLock{ m_oMutex };\n#endif\n\n\t\tUINT64 nFrontElement = m_deUuidPool.front();\n\t\tm_deUuidPool.pop_front();\n\t\treturn nFrontElement;\n\t}\n\n\tvoid PushBackElement(UINT64 nNextUUId)\n\t{\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n#else\n\t\tstd::unique_lock<std::mutex> oLock{ m_oMutex };\n#endif\n\t\tm_deUuidPool.push_back(nNextUUId);\n\t}\n\n\t/**\n\t* 返回以毫秒为单位的当前时间\n\t*\n\t* @return 当前时间(毫秒)\n\t*/\n\tUINT64 _GetNowMliTime() const\n\t{\n\t\tif (0)\n\t\t{\n\t\t\tStorm::CSTDateTime oDateTime;\n\t\t\toDateTime.Now();\n\t\t\treturn oDateTime.EpochMilliSecs();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tusing namespace std;\n\t\t\tauto nTimeNow = chrono::system_clock::now();\n\t\t\tauto nDurationInMs = chrono::duration_cast<chrono::milliseconds>(nTimeNow.time_since_epoch());\n\t\t\treturn nDurationInMs.count();\n\t\t}\n\t}\n\n\t/**\n\t* 阻塞到下一个毫秒，直到获得新的时间戳\n\t*\n\t* @param lastTimestamp 上次生成ID的时间截\n\t* @return 当前时间戳\n\t*/\n\tUINT64 WaitForNextMilli(UINT64 lastTimestamp) const\n\t{\n\t\tUINT64 nTimestamp = _GetNowMliTime();\n\t\twhile (nTimestamp <= lastTimestamp)\n\t\t{\n\t\t\tnTimestamp = _GetNowMliTime();\n\t\t}\n\t\treturn nTimestamp;\n\t}\n\nprivate:\n\n#ifndef SNOWFLAKE_ID_MAKER_NO_LOCK\n\tstd::mutex\t\tm_oMutex;\n#endif\n\n\tUINT32\t\t\tm_nPlatformId = 0;\t\t//平台id\n\tUINT32\t\t\tm_nAreaId = 0;\t\t\t//区服id\n\tUINT32\t\t\tm_nAppId = 0;\t\t\t//Appid\n\tAtomicUInt\t\tm_nGlobalSeq{ 0 };\t\t//全局序列\n\tAtomicUInt\t\tm_nMliSeq{ 0 };\t\t\t//每毫秒序列\n\tAtomicUInt64\tm_nLastTimestamp{ 0 };\t//上次生成ID的时间截\n\tstd::deque<UINT64> m_deUuidPool;\t\t\t//uuid池 用于存放预生成uuids\n};\n\n\n\n/************************************************************************/\n/* 负责生成全局唯一id\t\t\t\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\nclass CUUIDMaker : public Storm::TSingleton<CUUIDMaker>\n{\n\tfriend class Storm::TSingleton<CUUIDMaker>;\npublic:\n\tbool Init(const UINT32 nParaA, const UINT32 nParaB, const UINT32 nParaC)\n\t{\n\t\tm_oIdMaker.Init(nParaA, nParaB, nParaC);\n\t\treturn true;\n\t}\n\t\n\t/// init with pipeid\n\tbool Init(const UINT64 nPipeId)\n\t{\n\t\tusing namespace Storm;\n\t\tCServerID oServID(nPipeId);\n\t\tm_oIdMaker.Init(oServID.GetPlat(), oServID.GetArea(), oServID.GetIndex());\n\t\treturn true;\n\t}\n\n\tUINT64 GenId()\n\t{\n\t\treturn m_oIdMaker.GenId();\n\t}\n\n\tEUuidPoolState GetUuidDequeState()\n\t{\n\t\treturn m_oIdMaker.GetUuidDequeState();\n\t}\n\n\tvoid FillPoolWithInMli()\n\t{\n\t\tm_oIdMaker.FillPoolWithInMli();\n\t}\n\n\tUINT64 GetCompareIdFromTime(UINT32 nTimeVal);\n\n\tUINT64 GetTimeAddVal(UINT32 nTimeVal);\n\n\tUINT32 GetTimeValFromUuid(UINT64 nUuid);\n\nprivate:\n\tCSnowflakeIdMaker\tm_oIdMaker;\n};\n\n#define  GEN_GLOBAL_UUID()  CUUIDMaker::Instance()->GenId()\n\n\n#endif\n\n\n//gameserver \n#include \"uuid_pool_mgr.h\"\n#include \"uuid_generator.h\"\n\n\nbool CUUIDPool::Init()\n{\n\tFillUuidPool();\n\treturn true;\n}\n\nvoid CUUIDPool::OnTimer(unsigned int nId)\n{\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : \" << nId;\n\tCUUIDMaker::Instance()->FillPoolWithInMli();\n\tFillUuidPool();\n}\n\nvoid CUUIDPool::FillUuidPool()\n{\n\tEUuidPoolState eUuidDequeState = CUUIDMaker::Instance()->GetUuidDequeState();\n\tuint32 nUpdateInterval = 5 * 60 * 1000;\n\tswitch (eUuidDequeState)\n\t{\n\tcase EUuidPoolState_Empty:\n\t\tnUpdateInterval = 1 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_0_30_Per:\n\t\tnUpdateInterval = 2 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_30_70_Per:\n\t\tnUpdateInterval = 3 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_70_100_Per:\n\t\tnUpdateInterval = 4 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Full:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\tdefault:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\t}\n\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : \" << eUuidDequeState;\n\tSetTimer(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n}\n\n```\n## 参考文章\n[分布式唯一id：snowflake算法思考 - 掘金](https://juejin.im/post/5a7f9176f265da4e721c73a8)\n[https://tech.meituan.com/2017/04/21/mt-leaf.html](https://tech.meituan.com/MT_Leaf.html)\n[GitHub - baidu/uid-generator: UniqueID generator](https://github.com/baidu/uid-generator)","source":"_posts/全局唯一ID生成算法优化.md","raw":"---\ntitle: 全局唯一ID生成算法优化\ndate: 2020-01-23 15:12:42\ntags: uuid\ncategories: C/C++\n---\n\n<!-- toc -->\n\n- [前言](#前言)\n- [Snowflake算法介绍](#Snowflake算法介绍)\n- [SnowFlake算法优化](#SnowFlake算法优化)\n  * [目前算法设计缺陷](#目前算法设计缺陷)\n  * [设计优化](#设计优化)\n- [是否这样就完美了呢？](#是否这样就完美了呢？)\n- [Talk is cheap, show you the code](#Talk-is-cheap-show-you-the-code)\n- [参考文章](#参考文章)\n\n<!-- tocstop -->\n\n## 前言\n\n在进程启动前，一般会给每个进程静态分配一个唯一标识ID(ServerID或者PipeID)\n```\nstruct SServerID\n{\n\tUINT16 wPlatform = 0;\t ///< Platform   平台id \n\tUINT16 wArea = 0;        ///< Area       区服id\n\tUINT16 wType = 0;        ///< Type       服务器App类型\n\tUINT16 wIndex = 0;       ///< Index      服务器App编号索引\n};\n```\n\n每个Role/Item/Hero/Mail 等创建的时候都会创建一个UUID来唯一标识，其中Mail_Uuid还有趋势递增的需求\n\n## Snowflake算法介绍\n\n*SnowFlake分布式生成Id算法由Twitter开源*\n\nSnowFlake算法生成id的结果是一个64bit大小的UINT64整数，它的结构如下图：\n![snowflake uuid-64bit](:storage\\1a51b319-5d9b-40f9-a828-cfc88309cea2\\4dbfceed.png)\n\nSnowFlake的优点: \n\t- 整体上按照时间自增排序\n\t- 整个分布式系统内不会产生ID碰撞(时间戳和自增序列以外的字段作区分), 并且效率较高(位运算),\n\nSnowFlake每秒能够产生6.4万ID左右.(和5段位的配置位数有关)\nUUID从高位到低位依次排列：\n- 第一段：39位, 当对于某一个时间点的时间戳差值（至少10年可用）\n- 第二段：3 位, 平台platform或大区id，比如QQ Android/QQ IOS/Wechat IOS 等（8）\n- 第三段：11位, 区服area id，对应的就是服务器小区的ID（2048）\n- 第四段：5 位, 服务器APP实例id index（32), Notice：appid需要在area范围内唯一\n- 第五段：6 位, 自增长id，也就是说在一个完整的毫秒时间内最多可以生成64个UUID\n\n## SnowFlake算法优化\n\n### 目前算法设计缺陷\n在实际服务器运行过程中，尤其在游戏服务器开发期间，大量用户注册，会有瞬间生成大量UUID的需求\n\n之前服务器的做法是：\n```cpp\n//遍历了一圈64个，等下一个毫秒生成\nif (m_nGlobalSeq == m_nMliSeq)\n{\n\t// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳\n\tnCurTimestamp = WaitForNextMilli(m_nLastTimestamp);\n}\n\n/**\n* 阻塞到下一个毫秒，直到获得新的时间戳\n*\n* @param lastTimestamp 上次生成ID的时间截\n* @return 当前时间戳\n*/\nUINT64 WaitForNextMilli(UINT64 lastTimestamp) const\n{\n\tUINT64 nTimestamp = _GetNowMliTime();\n\twhile (nTimestamp <= lastTimestamp)\n\t{\n\t\tnTimestamp = _GetNowMliTime();\n\t}\n\treturn nTimestamp;\n}\n\n```\n这里使用while强行等待到下一毫秒，相当于阻塞当前线程，从而成为热点函数，需要去优化\n\n### 设计优化\n- 合理分配各字段占用bit（图中已经是调整过的）\n- 将生成uuid单独出一个独立全局Server组件，提供全局唯一UUID服务，这样除去高位39bit外理论上其他bit都可以当作自增位，而且可以提前生成很多uuid放在pool当中，有需要的进程从当中取，可以满足需求，Baidu在github上开源的UUID生成算法就是这样处理的\n- 我们取一个折中方案，只是在server中加一个Pool，存放提前生成好的UUIDs，每次业务端需要UUID的时候首先从Pool中取，如果取不到就走原来的流程\n\n```cpp\nUINT64 GenId()\n{\n\tif (!IsEmpty())\n\t{\n\t\t//从Pool中取\n\t\treturn PopFrontElement();\n\t}\n\n\treturn NextId();\n}\n```\n\n既然存在Pool，那么就需要设计Pool中元素填充方案\n首先将Pool设定一个合适的固定最大值 const UINT32 UUID_POOL_MAX_SIZE = 1 << 13;   //\t\tuuid pool 最大数 8192\n然后根据当前Pool的状态，来定时填充，每次填充的数量为当前毫秒内所有可以生成的UUID数\n![Fill_Pool.png](:storage\\1a51b319-5d9b-40f9-a828-cfc88309cea2\\928daf4a.png)\n\n\n```cpp\n#include \"uuid_pool_mgr.h\"\n#include \"uuid_generator.h\"\n\n\nbool CUUIDPool::Init()\n{\n\tFillUuidPool();\n\treturn true;\n}\n\nvoid CUUIDPool::OnTimer(unsigned int nId)\n{\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : \" << nId;\n\tCUUIDMaker::Instance()->FillPoolWithInMli();\n\tFillUuidPool();\n}\n\nvoid CUUIDPool::FillUuidPool()\n{\n\tEUuidPoolState eUuidDequeState = CUUIDMaker::Instance()->GetUuidDequeState();\n\tuint32 nUpdateInterval = 5 * 60 * 1000;\n\tswitch (eUuidDequeState)\n\t{\n\tcase EUuidPoolState_Empty:\n\t\tnUpdateInterval = 1 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_0_30_Per:\n\t\tnUpdateInterval = 2 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_30_70_Per:\n\t\tnUpdateInterval = 3 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_70_100_Per:\n\t\tnUpdateInterval = 4 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Full:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\tdefault:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\t}\n\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : \" << eUuidDequeState;\n\tSetTimer(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n}\n\n\nenum EUuidPoolState\n{\n\tEUuidPoolState_Empty\t\t\t\t= 1,\n\tEUuidPoolState_Not_Full_0_30_Per\t= 2,\n\tEUuidPoolState_Not_Full_30_70_Per\t= 3,\n\tEUuidPoolState_Not_Full_70_100_Per\t= 4,\n\tEUuidPoolState_Full\t\t\t\t\t= 5,\n};\n\n//uuid_generator.h\n//将当前毫秒内的UUID全部生成并存到Pool中\nvoid FillPoolWithInMli()\n{\n\tEUuidPoolState nCurState = GetUuidDequeState();\n\tAtomicUInt64 nCurTimestamp = _GetNowMliTime();\n\twhile (nCurState != EUuidPoolState_Full)\n\t{\n\t\tUINT64 nNextUUId = NextId(false);\n\t\tif (nNextUUId == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tPushBackElement(nNextUUId);\n\n\t\tif (nCurTimestamp != _GetNowMliTime())\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n```\n\n## 是否这样就完美了呢？\n\n并没有呢！！！\n这个算法强制依赖时间递增，如果时间回拨怎么办？\n目前的做法是直接throw new exception\n分析时间回拨产生原因\n第一：人物操作，在真实环境一般不会有那个傻逼干这种事情，所以基本可以排除。 \n第二：由于有些业务等需要，机器需要同步时间服务器（在这个过程中可能会存在时间回拨，查了下我们服务器一般在10ms以内（2小时同步一次））。 Ntp过程可能产生时间回拨。\n第三：QA和策划测试过程中有需求怎么办？\n解决办法：\n1. 将uuid_generation独立出来给其他server提供服务\n2. 当回拨时间小于XXms，就等时间追上来之后继续生成。 (XXms对业务没有什么影响)\n3. 当时间大于XXms时间我们通过更换AppId位来来解决回拨问题。\n\n## Talk is cheap, show you the code\n```cpp\n#ifndef __UUID_GENERATOR_H__\n#define __UUID_GENERATOR_H__\n\n#include \"gnsingleton.h\"\n#include \"gntype.h\"\n#include \"gnpipe.h\"\n#include \"gntime.h\"\n#include \"noncopy.h\"\n#include \"gnserverid.h\"\n\n#include <assert.h>\n#include <mutex>\n#include <atomic>\n#include <chrono>\n#include <exception>\n#include <sstream>\n#include <deque>\n\nenum EUuidPoolState\n{\n\tEUuidPoolState_Empty\t\t\t\t= 1,\n\tEUuidPoolState_Not_Full_0_30_Per\t= 2,\n\tEUuidPoolState_Not_Full_30_70_Per\t= 3,\n\tEUuidPoolState_Not_Full_70_100_Per\t= 4,\n\tEUuidPoolState_Full\t\t\t\t\t= 5,\n};\n\n//#define SNOWFLAKE_ID_MAKER_NO_LOCK\nclass CSnowflakeIdMaker : private CNoncopy\n{\npublic:\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\ttypedef std::atomic<UINT32> AtomicUInt;\n\ttypedef std::atomic<UINT64> AtomicUInt64;\n#else\n\ttypedef UINT32 AtomicUInt;\n\ttypedef UINT64 AtomicUInt64;\n#endif\n\n\tconst UINT32 UUID_POOL_MAX_SIZE = 1 << 13;   //\t\tuuid pool 最大数 8192\n\tconst UINT64 START_EPOCH\t\t\t= 1541001600000LL;\t\t//开始时间截 (2018-11-01 00:00:00.000)，修改此时间可调整可用时长\n\t\t\t\t\t\t\t   \n\tconst UINT32 A_TIMESTAMP_BITS\t\t= 39;\t\t\t\t\t//时间戳所占的位数\n\tconst UINT32 B_PLATFORM_BITS\t\t= 3;\t\t\t\t\t//平台id所占的位数\n\tconst UINT32 C_AREA_BITS\t\t\t= 11;\t\t\t\t\t//区服id所占的位\n\tconst UINT32 D_APP_ID_BITS\t\t\t= 5;\t\t\t\t\t//app id所占的位数\n\tconst UINT32 E_INCR_SEQUENCE_BITS\t= 6;\t\t\t\t    //自增序列所占的位数\n\n\tconst UINT32 APP_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS;\t\t//APPID向左移位数\n\tconst UINT32 AREA_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS;\t\t\t\t\t\t\t\t\t\t\t//小区id向左移位数\n\tconst UINT32 PLATFORM_ID_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS;\t\t\t\t\t\t//大区id向左移位数\n\tconst UINT32 TIME_STAMP_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS + B_PLATFORM_BITS;\t\t//时间戳向左移位数\n\tconst UINT32 SEQUENCE_MASK\t\t\t= (1 << E_INCR_SEQUENCE_BITS) - 1;\t\t\t\t\t\t\t\t\t\t\t\t//生成序列的掩码\n\n\n\tCSnowflakeIdMaker() : m_nPlatformId(0), m_nAreaId(0), m_nGlobalSeq(0), m_nLastTimestamp(0) {}\n\n\tCSnowflakeIdMaker(const UINT32 nPlatId, const UINT32 nAreaId, const UINT32 nAppId)\n\t{\n\t\tInit(nPlatId, nAreaId, nAppId);\n\t}\n\n\tvoid Init(const UINT32 nPlatId, const UINT32 nAreaId, const UINT32 nAppId)\n\t{\n\t\tm_nPlatformId = nPlatId;\n\t\tm_nAreaId = nAreaId;\n\t\tm_nAppId = nAppId;\n\t}\n\n\tUINT64 GenId()\n\t{\n\t\tif (!IsEmpty())\n\t\t{\n\t\t\treturn PopFrontElement();\n\t\t}\n\n\t\treturn NextId();\n\t}\n\n\t/**\n\t* 获得下一个ID (该方法是线程安全的)\n\t* @param  bCanBlock 参数指定当前函数是否可以阻塞, 默认为true\n\t* @return SnowflakeId\n\t*/\n\tUINT64 NextId(bool bCanBlock = true)\n\t{\n\t\tusing namespace  std;\n\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\t\tstatic AtomicUInt64 nCurTimestamp{ 0 };\n#else\n\t\tstd::unique_lock<std::mutex> oLock{ m_oMutex };\n\t\tAtomicUInt64 nCurTimestamp{ 0 };\n#endif\n\n\t\tnCurTimestamp = _GetNowMliTime();\n\n\t\t// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常\n\t\tif (nCurTimestamp < m_nLastTimestamp)\n\t\t{\n\t\t\tstd::ostringstream oSS;\n\t\t\toSS << \"clock moved backwards.  Refusing to generate id for \" << m_nLastTimestamp - nCurTimestamp << \" milliseconds\";\n\t\t\tthrow std::exception(std::runtime_error(oSS.str()));\n\t\t}\n\n\t\tm_nGlobalSeq = (m_nGlobalSeq + 1) & SEQUENCE_MASK;\n\n\t\t// 为了使id递增+1均匀分布，这里seq跨毫秒也不清0\n\t\tif (m_nLastTimestamp == nCurTimestamp)\n\t\t{\n\t\t\t//遍历了一圈64个，等下一个毫秒生成\n\t\t\tif (m_nGlobalSeq == m_nMliSeq)\n\t\t\t{\n\t\t\t\tif (bCanBlock)\n\t\t\t\t{\n\t\t\t\t\t// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳\n\t\t\t\t\tnCurTimestamp = WaitForNextMilli(m_nLastTimestamp);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\t\n\t\t\tm_nMliSeq = m_nGlobalSeq;\n\t\t}\n\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\t\tm_nLastTimestamp = nCurTimestamp.load();\n#else\n\t\tm_nLastTimestamp = nCurTimestamp;\n#endif\n\n\t\t// 移位并通过或运算拼到一起组成64位的ID\n\t\treturn ((nCurTimestamp - START_EPOCH) << TIME_STAMP_SHIFT)\n\t\t\t| (m_nPlatformId << PLATFORM_ID_SHIFT)\n\t\t\t| (m_nAreaId << AREA_ID_SHIFT)\n\t\t\t| (m_nAppId << APP_ID_SHIFT)\n\t\t\t| (m_nGlobalSeq);\n\t}\n\n\tEUuidPoolState GetUuidDequeState() \n\t{\n\t\tif (m_deUuidPool.empty())\n\t\t{\n\t\t\treturn EUuidPoolState_Empty;\n\t\t}\n\n\t\tsize_t nCurPoolSize = m_deUuidPool.size();\n\t\tif (nCurPoolSize >= UUID_POOL_MAX_SIZE)\n\t\t{\n\t\t\treturn EUuidPoolState_Full;\n\t\t}\n\n\t\tuint32 nCurPercent = nCurPoolSize * 100 / UUID_POOL_MAX_SIZE;\n\t\tif (nCurPercent < 30)\n\t\t{\n\t\t\treturn EUuidPoolState_Not_Full_0_30_Per;\n\t\t}\n\t\telse if (nCurPercent < 70)\n\t\t{\n\t\t\treturn EUuidPoolState_Not_Full_30_70_Per;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn EUuidPoolState_Not_Full_70_100_Per;\n\t\t}\n\n\t\treturn EUuidPoolState_Full;\n\t} \n\n\tvoid FillPoolWithInMli()\n\t{\n\t\tEUuidPoolState nCurState = GetUuidDequeState();\n\t\tAtomicUInt64 nCurTimestamp = _GetNowMliTime();\n\t\twhile (nCurState != EUuidPoolState_Full)\n\t\t{\n\t\t\tUINT64 nNextUUId = NextId(false);\n\t\t\tif (nNextUUId == 0)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tPushBackElement(nNextUUId);\n\n\t\t\tif (nCurTimestamp != _GetNowMliTime())\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\nprotected:\n\n\t//判断pool是否为空\n\tbool IsEmpty()\n\t{\n\t\treturn m_deUuidPool.empty();\n\t}\n\n\t//返回pool队列中front 元素\n\tUINT64 PopFrontElement()\n\t{\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n\t\t\n#else\n\t\tstd::unique_lock<std::mutex> oLock{ m_oMutex };\n#endif\n\n\t\tUINT64 nFrontElement = m_deUuidPool.front();\n\t\tm_deUuidPool.pop_front();\n\t\treturn nFrontElement;\n\t}\n\n\tvoid PushBackElement(UINT64 nNextUUId)\n\t{\n#ifdef SNOWFLAKE_ID_MAKER_NO_LOCK\n#else\n\t\tstd::unique_lock<std::mutex> oLock{ m_oMutex };\n#endif\n\t\tm_deUuidPool.push_back(nNextUUId);\n\t}\n\n\t/**\n\t* 返回以毫秒为单位的当前时间\n\t*\n\t* @return 当前时间(毫秒)\n\t*/\n\tUINT64 _GetNowMliTime() const\n\t{\n\t\tif (0)\n\t\t{\n\t\t\tStorm::CSTDateTime oDateTime;\n\t\t\toDateTime.Now();\n\t\t\treturn oDateTime.EpochMilliSecs();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tusing namespace std;\n\t\t\tauto nTimeNow = chrono::system_clock::now();\n\t\t\tauto nDurationInMs = chrono::duration_cast<chrono::milliseconds>(nTimeNow.time_since_epoch());\n\t\t\treturn nDurationInMs.count();\n\t\t}\n\t}\n\n\t/**\n\t* 阻塞到下一个毫秒，直到获得新的时间戳\n\t*\n\t* @param lastTimestamp 上次生成ID的时间截\n\t* @return 当前时间戳\n\t*/\n\tUINT64 WaitForNextMilli(UINT64 lastTimestamp) const\n\t{\n\t\tUINT64 nTimestamp = _GetNowMliTime();\n\t\twhile (nTimestamp <= lastTimestamp)\n\t\t{\n\t\t\tnTimestamp = _GetNowMliTime();\n\t\t}\n\t\treturn nTimestamp;\n\t}\n\nprivate:\n\n#ifndef SNOWFLAKE_ID_MAKER_NO_LOCK\n\tstd::mutex\t\tm_oMutex;\n#endif\n\n\tUINT32\t\t\tm_nPlatformId = 0;\t\t//平台id\n\tUINT32\t\t\tm_nAreaId = 0;\t\t\t//区服id\n\tUINT32\t\t\tm_nAppId = 0;\t\t\t//Appid\n\tAtomicUInt\t\tm_nGlobalSeq{ 0 };\t\t//全局序列\n\tAtomicUInt\t\tm_nMliSeq{ 0 };\t\t\t//每毫秒序列\n\tAtomicUInt64\tm_nLastTimestamp{ 0 };\t//上次生成ID的时间截\n\tstd::deque<UINT64> m_deUuidPool;\t\t\t//uuid池 用于存放预生成uuids\n};\n\n\n\n/************************************************************************/\n/* 负责生成全局唯一id\t\t\t\t\t\t\t\t\t\t\t\t*/\n/************************************************************************/\nclass CUUIDMaker : public Storm::TSingleton<CUUIDMaker>\n{\n\tfriend class Storm::TSingleton<CUUIDMaker>;\npublic:\n\tbool Init(const UINT32 nParaA, const UINT32 nParaB, const UINT32 nParaC)\n\t{\n\t\tm_oIdMaker.Init(nParaA, nParaB, nParaC);\n\t\treturn true;\n\t}\n\t\n\t/// init with pipeid\n\tbool Init(const UINT64 nPipeId)\n\t{\n\t\tusing namespace Storm;\n\t\tCServerID oServID(nPipeId);\n\t\tm_oIdMaker.Init(oServID.GetPlat(), oServID.GetArea(), oServID.GetIndex());\n\t\treturn true;\n\t}\n\n\tUINT64 GenId()\n\t{\n\t\treturn m_oIdMaker.GenId();\n\t}\n\n\tEUuidPoolState GetUuidDequeState()\n\t{\n\t\treturn m_oIdMaker.GetUuidDequeState();\n\t}\n\n\tvoid FillPoolWithInMli()\n\t{\n\t\tm_oIdMaker.FillPoolWithInMli();\n\t}\n\n\tUINT64 GetCompareIdFromTime(UINT32 nTimeVal);\n\n\tUINT64 GetTimeAddVal(UINT32 nTimeVal);\n\n\tUINT32 GetTimeValFromUuid(UINT64 nUuid);\n\nprivate:\n\tCSnowflakeIdMaker\tm_oIdMaker;\n};\n\n#define  GEN_GLOBAL_UUID()  CUUIDMaker::Instance()->GenId()\n\n\n#endif\n\n\n//gameserver \n#include \"uuid_pool_mgr.h\"\n#include \"uuid_generator.h\"\n\n\nbool CUUIDPool::Init()\n{\n\tFillUuidPool();\n\treturn true;\n}\n\nvoid CUUIDPool::OnTimer(unsigned int nId)\n{\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : \" << nId;\n\tCUUIDMaker::Instance()->FillPoolWithInMli();\n\tFillUuidPool();\n}\n\nvoid CUUIDPool::FillUuidPool()\n{\n\tEUuidPoolState eUuidDequeState = CUUIDMaker::Instance()->GetUuidDequeState();\n\tuint32 nUpdateInterval = 5 * 60 * 1000;\n\tswitch (eUuidDequeState)\n\t{\n\tcase EUuidPoolState_Empty:\n\t\tnUpdateInterval = 1 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_0_30_Per:\n\t\tnUpdateInterval = 2 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_30_70_Per:\n\t\tnUpdateInterval = 3 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Not_Full_70_100_Per:\n\t\tnUpdateInterval = 4 * 60 * 1000;\n\t\tbreak;\n\tcase EUuidPoolState_Full:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\tdefault:\n\t\tnUpdateInterval = 5 * 60 * 1000;\n\t\tbreak;\n\t}\n\n\tEXLOG_DEBUG << \"[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : \" << eUuidDequeState;\n\tSetTimer(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n}\n\n```\n## 参考文章\n[分布式唯一id：snowflake算法思考 - 掘金](https://juejin.im/post/5a7f9176f265da4e721c73a8)\n[https://tech.meituan.com/2017/04/21/mt-leaf.html](https://tech.meituan.com/MT_Leaf.html)\n[GitHub - baidu/uid-generator: UniqueID generator](https://github.com/baidu/uid-generator)","slug":"全局唯一ID生成算法优化","published":1,"updated":"2020-01-23T07:12:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzg0000gokecg3e85j7j","content":"<!-- toc -->\n\n<ul>\n<li><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></li>\n<li><a href=\"#Snowflake%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D\">Snowflake算法介绍</a></li>\n<li><a href=\"#SnowFlake%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96\">SnowFlake算法优化</a><ul>\n<li><a href=\"#%E7%9B%AE%E5%89%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7\">目前算法设计缺陷</a></li>\n<li><a href=\"#%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96\">设计优化</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%98%AF%E5%90%A6%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%AE%8C%E7%BE%8E%E4%BA%86%E5%91%A2%EF%BC%9F\">是否这样就完美了呢？</a></li>\n<li><a href=\"#Talk-is-cheap-show-you-the-code\">Talk is cheap, show you the code</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\">参考文章</a></li>\n</ul>\n<!-- tocstop -->\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在进程启动前，一般会给每个进程静态分配一个唯一标识ID(ServerID或者PipeID)</p>\n<pre><code class=\"hljs abnf\">struct SServerID\n&#123;\n    UINT16 wPlatform <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;\t ///&lt; Platform   平台id </span>\n    UINT16 wArea <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;        ///&lt; Area       区服id</span>\n    UINT16 wType <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;        ///&lt; Type       服务器App类型</span>\n    UINT16 wIndex <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;       ///&lt; Index      服务器App编号索引</span>\n&#125;<span class=\"hljs-comment\">;</span></code></pre>\n\n<p>每个Role&#x2F;Item&#x2F;Hero&#x2F;Mail 等创建的时候都会创建一个UUID来唯一标识，其中Mail_Uuid还有趋势递增的需求</p>\n<h2 id=\"Snowflake算法介绍\"><a href=\"#Snowflake算法介绍\" class=\"headerlink\" title=\"Snowflake算法介绍\"></a>Snowflake算法介绍</h2><p><em>SnowFlake分布式生成Id算法由Twitter开源</em></p>\n<p>SnowFlake算法生成id的结果是一个64bit大小的UINT64整数，它的结构如下图：<br><img src=\"/:storage%5C1a51b319-5d9b-40f9-a828-cfc88309cea2%5C4dbfceed.png\" alt=\"snowflake uuid-64bit\"></p>\n<p>SnowFlake的优点:<br>    - 整体上按照时间自增排序<br>    - 整个分布式系统内不会产生ID碰撞(时间戳和自增序列以外的字段作区分), 并且效率较高(位运算),</p>\n<p>SnowFlake每秒能够产生6.4万ID左右.(和5段位的配置位数有关)<br>UUID从高位到低位依次排列：</p>\n<ul>\n<li>第一段：39位, 当对于某一个时间点的时间戳差值（至少10年可用）</li>\n<li>第二段：3 位, 平台platform或大区id，比如QQ Android&#x2F;QQ IOS&#x2F;Wechat IOS 等（8）</li>\n<li>第三段：11位, 区服area id，对应的就是服务器小区的ID（2048）</li>\n<li>第四段：5 位, 服务器APP实例id index（32), Notice：appid需要在area范围内唯一</li>\n<li>第五段：6 位, 自增长id，也就是说在一个完整的毫秒时间内最多可以生成64个UUID</li>\n</ul>\n<h2 id=\"SnowFlake算法优化\"><a href=\"#SnowFlake算法优化\" class=\"headerlink\" title=\"SnowFlake算法优化\"></a>SnowFlake算法优化</h2><h3 id=\"目前算法设计缺陷\"><a href=\"#目前算法设计缺陷\" class=\"headerlink\" title=\"目前算法设计缺陷\"></a>目前算法设计缺陷</h3><p>在实际服务器运行过程中，尤其在游戏服务器开发期间，大量用户注册，会有瞬间生成大量UUID的需求</p>\n<p>之前服务器的做法是：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//遍历了一圈64个，等下一个毫秒生成</span>\n<span class=\"hljs-keyword\">if</span> (m_nGlobalSeq == m_nMliSeq)\n&#123;\n    <span class=\"hljs-comment\">// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳</span>\n    nCurTimestamp = <span class=\"hljs-built_in\">WaitForNextMilli</span>(m_nLastTimestamp);\n&#125;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* 阻塞到下一个毫秒，直到获得新的时间戳</span>\n<span class=\"hljs-comment\">*</span>\n<span class=\"hljs-comment\">* @param lastTimestamp 上次生成ID的时间截</span>\n<span class=\"hljs-comment\">* @return 当前时间戳</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">WaitForNextMilli</span><span class=\"hljs-params\">(UINT64 lastTimestamp)</span> <span class=\"hljs-type\">const</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    UINT64 nTimestamp = _GetNowMliTime();\n    <span class=\"hljs-keyword\">while</span> (nTimestamp &lt;= lastTimestamp)\n    &#123;\n        nTimestamp = _GetNowMliTime();\n    &#125;\n    <span class=\"hljs-keyword\">return</span> nTimestamp;\n&#125;\n</code></pre>\n<p>这里使用while强行等待到下一毫秒，相当于阻塞当前线程，从而成为热点函数，需要去优化</p>\n<h3 id=\"设计优化\"><a href=\"#设计优化\" class=\"headerlink\" title=\"设计优化\"></a>设计优化</h3><ul>\n<li>合理分配各字段占用bit（图中已经是调整过的）</li>\n<li>将生成uuid单独出一个独立全局Server组件，提供全局唯一UUID服务，这样除去高位39bit外理论上其他bit都可以当作自增位，而且可以提前生成很多uuid放在pool当中，有需要的进程从当中取，可以满足需求，Baidu在github上开源的UUID生成算法就是这样处理的</li>\n<li>我们取一个折中方案，只是在server中加一个Pool，存放提前生成好的UUIDs，每次业务端需要UUID的时候首先从Pool中取，如果取不到就走原来的流程</li>\n</ul>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GenId</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">IsEmpty</span>())\n    &#123;\n        <span class=\"hljs-comment\">//从Pool中取</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">PopFrontElement</span>();\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">NextId</span>();\n&#125;</code></pre>\n\n<p>既然存在Pool，那么就需要设计Pool中元素填充方案<br>首先将Pool设定一个合适的固定最大值 const UINT32 UUID_POOL_MAX_SIZE &#x3D; 1 &lt;&lt; 13;   &#x2F;&#x2F;\t\tuuid pool 最大数 8192<br>然后根据当前Pool的状态，来定时填充，每次填充的数量为当前毫秒内所有可以生成的UUID数<br><img src=\"/:storage%5C1a51b319-5d9b-40f9-a828-cfc88309cea2%5C928daf4a.png\" alt=\"Fill_Pool.png\"></p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_pool_mgr.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_generator.h&quot;</span></span>\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CUUIDPool::Init</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::OnTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : &quot;</span> &lt;&lt; nId;\n    CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">FillPoolWithInMli</span>();\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::FillUuidPool</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EUuidPoolState eUuidDequeState = CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    uint32 nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n    <span class=\"hljs-keyword\">switch</span> (eUuidDequeState)\n    &#123;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Empty:\n        nUpdateInterval = <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_0_30_Per:\n        nUpdateInterval = <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_30_70_Per:\n        nUpdateInterval = <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_70_100_Per:\n        nUpdateInterval = <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Full:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    &#125;\n\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : &quot;</span> &lt;&lt; eUuidDequeState;\n    <span class=\"hljs-built_in\">SetTimer</span>(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n&#125;\n\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">EUuidPoolState</span>\n&#123;\n    EUuidPoolState_Empty\t\t\t\t= <span class=\"hljs-number\">1</span>,\n    EUuidPoolState_Not_Full_0_30_Per\t= <span class=\"hljs-number\">2</span>,\n    EUuidPoolState_Not_Full_30_70_Per\t= <span class=\"hljs-number\">3</span>,\n    EUuidPoolState_Not_Full_70_100_Per\t= <span class=\"hljs-number\">4</span>,\n    EUuidPoolState_Full\t\t\t\t\t= <span class=\"hljs-number\">5</span>,\n&#125;;\n\n<span class=\"hljs-comment\">//uuid_generator.h</span>\n<span class=\"hljs-comment\">//将当前毫秒内的UUID全部生成并存到Pool中</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">FillPoolWithInMli</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EUuidPoolState nCurState = <span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    AtomicUInt64 nCurTimestamp = _GetNowMliTime();\n    <span class=\"hljs-keyword\">while</span> (nCurState != EUuidPoolState_Full)\n    &#123;\n        UINT64 nNextUUId = <span class=\"hljs-built_in\">NextId</span>(<span class=\"hljs-literal\">false</span>);\n        <span class=\"hljs-keyword\">if</span> (nNextUUId == <span class=\"hljs-number\">0</span>)\n        &#123;\n            <span class=\"hljs-keyword\">break</span>;\n        &#125;\n\n        <span class=\"hljs-built_in\">PushBackElement</span>(nNextUUId);\n\n        <span class=\"hljs-keyword\">if</span> (nCurTimestamp != _GetNowMliTime())\n        &#123;\n            <span class=\"hljs-keyword\">break</span>;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"是否这样就完美了呢？\"><a href=\"#是否这样就完美了呢？\" class=\"headerlink\" title=\"是否这样就完美了呢？\"></a>是否这样就完美了呢？</h2><p>并没有呢！！！<br>这个算法强制依赖时间递增，如果时间回拨怎么办？<br>目前的做法是直接throw new exception<br>分析时间回拨产生原因<br>第一：人物操作，在真实环境一般不会有那个傻逼干这种事情，所以基本可以排除。<br>第二：由于有些业务等需要，机器需要同步时间服务器（在这个过程中可能会存在时间回拨，查了下我们服务器一般在10ms以内（2小时同步一次））。 Ntp过程可能产生时间回拨。<br>第三：QA和策划测试过程中有需求怎么办？<br>解决办法：</p>\n<ol>\n<li>将uuid_generation独立出来给其他server提供服务</li>\n<li>当回拨时间小于XXms，就等时间追上来之后继续生成。 (XXms对业务没有什么影响)</li>\n<li>当时间大于XXms时间我们通过更换AppId位来来解决回拨问题。</li>\n</ol>\n<h2 id=\"Talk-is-cheap-show-you-the-code\"><a href=\"#Talk-is-cheap-show-you-the-code\" class=\"headerlink\" title=\"Talk is cheap, show you the code\"></a>Talk is cheap, show you the code</h2><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> __UUID_GENERATOR_H__</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __UUID_GENERATOR_H__</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnsingleton.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gntype.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnpipe.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gntime.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;noncopy.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnserverid.h&quot;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;atomic&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;exception&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span>\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">EUuidPoolState</span>\n&#123;\n    EUuidPoolState_Empty\t\t\t\t= <span class=\"hljs-number\">1</span>,\n    EUuidPoolState_Not_Full_0_30_Per\t= <span class=\"hljs-number\">2</span>,\n    EUuidPoolState_Not_Full_30_70_Per\t= <span class=\"hljs-number\">3</span>,\n    EUuidPoolState_Not_Full_70_100_Per\t= <span class=\"hljs-number\">4</span>,\n    EUuidPoolState_Full\t\t\t\t\t= <span class=\"hljs-number\">5</span>,\n&#125;;\n\n<span class=\"hljs-comment\">//#define SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CSnowflakeIdMaker</span> : <span class=\"hljs-keyword\">private</span> CNoncopy\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n    <span class=\"hljs-keyword\">typedef</span> std::atomic&lt;UINT32&gt; AtomicUInt;\n    <span class=\"hljs-keyword\">typedef</span> std::atomic&lt;UINT64&gt; AtomicUInt64;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n    <span class=\"hljs-keyword\">typedef</span> UINT32 AtomicUInt;\n    <span class=\"hljs-keyword\">typedef</span> UINT64 AtomicUInt64;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    <span class=\"hljs-type\">const</span> UINT32 UUID_POOL_MAX_SIZE = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">13</span>;   <span class=\"hljs-comment\">//\t\tuuid pool 最大数 8192</span>\n    <span class=\"hljs-type\">const</span> UINT64 START_EPOCH\t\t\t= <span class=\"hljs-number\">1541001600000LL</span>;\t\t<span class=\"hljs-comment\">//开始时间截 (2018-11-01 00:00:00.000)，修改此时间可调整可用时长</span>\n                               \n    <span class=\"hljs-type\">const</span> UINT32 A_TIMESTAMP_BITS\t\t= <span class=\"hljs-number\">39</span>;\t\t\t\t\t<span class=\"hljs-comment\">//时间戳所占的位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 B_PLATFORM_BITS\t\t= <span class=\"hljs-number\">3</span>;\t\t\t\t\t<span class=\"hljs-comment\">//平台id所占的位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 C_AREA_BITS\t\t\t= <span class=\"hljs-number\">11</span>;\t\t\t\t\t<span class=\"hljs-comment\">//区服id所占的位</span>\n    <span class=\"hljs-type\">const</span> UINT32 D_APP_ID_BITS\t\t\t= <span class=\"hljs-number\">5</span>;\t\t\t\t\t<span class=\"hljs-comment\">//app id所占的位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 E_INCR_SEQUENCE_BITS\t= <span class=\"hljs-number\">6</span>;\t\t\t\t    <span class=\"hljs-comment\">//自增序列所占的位数</span>\n\n    <span class=\"hljs-type\">const</span> UINT32 APP_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS;\t\t<span class=\"hljs-comment\">//APPID向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 AREA_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//小区id向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 PLATFORM_ID_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS;\t\t\t\t\t\t<span class=\"hljs-comment\">//大区id向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 TIME_STAMP_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS + B_PLATFORM_BITS;\t\t<span class=\"hljs-comment\">//时间戳向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 SEQUENCE_MASK\t\t\t= (<span class=\"hljs-number\">1</span> &lt;&lt; E_INCR_SEQUENCE_BITS) - <span class=\"hljs-number\">1</span>;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//生成序列的掩码</span>\n\n\n    <span class=\"hljs-built_in\">CSnowflakeIdMaker</span>() : <span class=\"hljs-built_in\">m_nPlatformId</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">m_nAreaId</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">m_nGlobalSeq</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">m_nLastTimestamp</span>(<span class=\"hljs-number\">0</span>) &#123;&#125;\n\n    <span class=\"hljs-built_in\">CSnowflakeIdMaker</span>(<span class=\"hljs-type\">const</span> UINT32 nPlatId, <span class=\"hljs-type\">const</span> UINT32 nAreaId, <span class=\"hljs-type\">const</span> UINT32 nAppId)\n    &#123;\n        <span class=\"hljs-built_in\">Init</span>(nPlatId, nAreaId, nAppId);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT32 nPlatId, <span class=\"hljs-type\">const</span> UINT32 nAreaId, <span class=\"hljs-type\">const</span> UINT32 nAppId)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        m_nPlatformId = nPlatId;\n        m_nAreaId = nAreaId;\n        m_nAppId = nAppId;\n    &#125;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GenId</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">IsEmpty</span>())\n        &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">PopFrontElement</span>();\n        &#125;\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">NextId</span>();\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 获得下一个ID (该方法是线程安全的)</span>\n<span class=\"hljs-comment\">    * @param  bCanBlock 参数指定当前函数是否可以阻塞, 默认为true</span>\n<span class=\"hljs-comment\">    * @return SnowflakeId</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">NextId</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> bCanBlock = <span class=\"hljs-literal\">true</span>)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span>  std;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n        <span class=\"hljs-type\">static</span> AtomicUInt64 nCurTimestamp&#123; <span class=\"hljs-number\">0</span> &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;\n        AtomicUInt64 nCurTimestamp&#123; <span class=\"hljs-number\">0</span> &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        nCurTimestamp = _GetNowMliTime();\n\n        <span class=\"hljs-comment\">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span>\n        <span class=\"hljs-keyword\">if</span> (nCurTimestamp &lt; m_nLastTimestamp)\n        &#123;\n            std::ostringstream oSS;\n            oSS &lt;&lt; <span class=\"hljs-string\">&quot;clock moved backwards.  Refusing to generate id for &quot;</span> &lt;&lt; m_nLastTimestamp - nCurTimestamp &lt;&lt; <span class=\"hljs-string\">&quot; milliseconds&quot;</span>;\n            <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">exception</span>(std::<span class=\"hljs-built_in\">runtime_error</span>(oSS.<span class=\"hljs-built_in\">str</span>()));\n        &#125;\n\n        m_nGlobalSeq = (m_nGlobalSeq + <span class=\"hljs-number\">1</span>) &amp; SEQUENCE_MASK;\n\n        <span class=\"hljs-comment\">// 为了使id递增+1均匀分布，这里seq跨毫秒也不清0</span>\n        <span class=\"hljs-keyword\">if</span> (m_nLastTimestamp == nCurTimestamp)\n        &#123;\n            <span class=\"hljs-comment\">//遍历了一圈64个，等下一个毫秒生成</span>\n            <span class=\"hljs-keyword\">if</span> (m_nGlobalSeq == m_nMliSeq)\n            &#123;\n                <span class=\"hljs-keyword\">if</span> (bCanBlock)\n                &#123;\n                    <span class=\"hljs-comment\">// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳</span>\n                    nCurTimestamp = <span class=\"hljs-built_in\">WaitForNextMilli</span>(m_nLastTimestamp);\n                &#125;\n                <span class=\"hljs-keyword\">else</span>\n                &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">else</span>\n        &#123;\t\n            m_nMliSeq = m_nGlobalSeq;\n        &#125;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n        m_nLastTimestamp = nCurTimestamp.<span class=\"hljs-built_in\">load</span>();\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        m_nLastTimestamp = nCurTimestamp;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        <span class=\"hljs-comment\">// 移位并通过或运算拼到一起组成64位的ID</span>\n        <span class=\"hljs-keyword\">return</span> ((nCurTimestamp - START_EPOCH) &lt;&lt; TIME_STAMP_SHIFT)\n            | (m_nPlatformId &lt;&lt; PLATFORM_ID_SHIFT)\n            | (m_nAreaId &lt;&lt; AREA_ID_SHIFT)\n            | (m_nAppId &lt;&lt; APP_ID_SHIFT)\n            | (m_nGlobalSeq);\n    &#125;\n\n    <span class=\"hljs-function\">EUuidPoolState <span class=\"hljs-title\">GetUuidDequeState</span><span class=\"hljs-params\">()</span> </span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (m_deUuidPool.<span class=\"hljs-built_in\">empty</span>())\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Empty;\n        &#125;\n\n        <span class=\"hljs-type\">size_t</span> nCurPoolSize = m_deUuidPool.<span class=\"hljs-built_in\">size</span>();\n        <span class=\"hljs-keyword\">if</span> (nCurPoolSize &gt;= UUID_POOL_MAX_SIZE)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Full;\n        &#125;\n\n        uint32 nCurPercent = nCurPoolSize * <span class=\"hljs-number\">100</span> / UUID_POOL_MAX_SIZE;\n        <span class=\"hljs-keyword\">if</span> (nCurPercent &lt; <span class=\"hljs-number\">30</span>)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Not_Full_0_30_Per;\n        &#125;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nCurPercent &lt; <span class=\"hljs-number\">70</span>)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Not_Full_30_70_Per;\n        &#125;\n        <span class=\"hljs-keyword\">else</span>\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Not_Full_70_100_Per;\n        &#125;\n\n        <span class=\"hljs-keyword\">return</span> EUuidPoolState_Full;\n    &#125; \n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">FillPoolWithInMli</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        EUuidPoolState nCurState = <span class=\"hljs-built_in\">GetUuidDequeState</span>();\n        AtomicUInt64 nCurTimestamp = _GetNowMliTime();\n        <span class=\"hljs-keyword\">while</span> (nCurState != EUuidPoolState_Full)\n        &#123;\n            UINT64 nNextUUId = <span class=\"hljs-built_in\">NextId</span>(<span class=\"hljs-literal\">false</span>);\n            <span class=\"hljs-keyword\">if</span> (nNextUUId == <span class=\"hljs-number\">0</span>)\n            &#123;\n                <span class=\"hljs-keyword\">break</span>;\n            &#125;\n            \n            <span class=\"hljs-built_in\">PushBackElement</span>(nNextUUId);\n\n            <span class=\"hljs-keyword\">if</span> (nCurTimestamp != _GetNowMliTime())\n            &#123;\n                <span class=\"hljs-keyword\">break</span>;\n            &#125;\n        &#125;\n    &#125;\n\n<span class=\"hljs-keyword\">protected</span>:\n\n    <span class=\"hljs-comment\">//判断pool是否为空</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">IsEmpty</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> m_deUuidPool.<span class=\"hljs-built_in\">empty</span>();\n    &#125;\n\n    <span class=\"hljs-comment\">//返回pool队列中front 元素</span>\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">PopFrontElement</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n        \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        UINT64 nFrontElement = m_deUuidPool.<span class=\"hljs-built_in\">front</span>();\n        m_deUuidPool.<span class=\"hljs-built_in\">pop_front</span>();\n        <span class=\"hljs-keyword\">return</span> nFrontElement;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PushBackElement</span><span class=\"hljs-params\">(UINT64 nNextUUId)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        m_deUuidPool.<span class=\"hljs-built_in\">push_back</span>(nNextUUId);\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 返回以毫秒为单位的当前时间</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * @return 当前时间(毫秒)</span>\n<span class=\"hljs-comment\">    */</span>\n    UINT64 _GetNowMliTime() <span class=\"hljs-type\">const</span>\n    &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>)\n        &#123;\n            Storm::CSTDateTime oDateTime;\n            oDateTime.<span class=\"hljs-built_in\">Now</span>();\n            <span class=\"hljs-keyword\">return</span> oDateTime.<span class=\"hljs-built_in\">EpochMilliSecs</span>();\n        &#125;\n        <span class=\"hljs-keyword\">else</span>\n        &#123;\n            <span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\n            <span class=\"hljs-keyword\">auto</span> nTimeNow = chrono::system_clock::<span class=\"hljs-built_in\">now</span>();\n            <span class=\"hljs-keyword\">auto</span> nDurationInMs = chrono::<span class=\"hljs-built_in\">duration_cast</span>&lt;chrono::milliseconds&gt;(nTimeNow.<span class=\"hljs-built_in\">time_since_epoch</span>());\n            <span class=\"hljs-keyword\">return</span> nDurationInMs.<span class=\"hljs-built_in\">count</span>();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 阻塞到下一个毫秒，直到获得新的时间戳</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * @param lastTimestamp 上次生成ID的时间截</span>\n<span class=\"hljs-comment\">    * @return 当前时间戳</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">WaitForNextMilli</span><span class=\"hljs-params\">(UINT64 lastTimestamp)</span> <span class=\"hljs-type\">const</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        UINT64 nTimestamp = _GetNowMliTime();\n        <span class=\"hljs-keyword\">while</span> (nTimestamp &lt;= lastTimestamp)\n        &#123;\n            nTimestamp = _GetNowMliTime();\n        &#125;\n        <span class=\"hljs-keyword\">return</span> nTimestamp;\n    &#125;\n\n<span class=\"hljs-keyword\">private</span>:\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n    std::mutex\t\tm_oMutex;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    UINT32\t\t\tm_nPlatformId = <span class=\"hljs-number\">0</span>;\t\t<span class=\"hljs-comment\">//平台id</span>\n    UINT32\t\t\tm_nAreaId = <span class=\"hljs-number\">0</span>;\t\t\t<span class=\"hljs-comment\">//区服id</span>\n    UINT32\t\t\tm_nAppId = <span class=\"hljs-number\">0</span>;\t\t\t<span class=\"hljs-comment\">//Appid</span>\n    AtomicUInt\t\tm_nGlobalSeq&#123; <span class=\"hljs-number\">0</span> &#125;;\t\t<span class=\"hljs-comment\">//全局序列</span>\n    AtomicUInt\t\tm_nMliSeq&#123; <span class=\"hljs-number\">0</span> &#125;;\t\t\t<span class=\"hljs-comment\">//每毫秒序列</span>\n    AtomicUInt64\tm_nLastTimestamp&#123; <span class=\"hljs-number\">0</span> &#125;;\t<span class=\"hljs-comment\">//上次生成ID的时间截</span>\n    std::deque&lt;UINT64&gt; m_deUuidPool;\t\t\t<span class=\"hljs-comment\">//uuid池 用于存放预生成uuids</span>\n&#125;;\n\n\n\n<span class=\"hljs-comment\">/************************************************************************/</span>\n<span class=\"hljs-comment\">/* 负责生成全局唯一id                                                */</span>\n<span class=\"hljs-comment\">/************************************************************************/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CUUIDMaker</span> : <span class=\"hljs-keyword\">public</span> Storm::TSingleton&lt;CUUIDMaker&gt;\n&#123;\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Storm</span>::TSingleton&lt;CUUIDMaker&gt;;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT32 nParaA, <span class=\"hljs-type\">const</span> UINT32 nParaB, <span class=\"hljs-type\">const</span> UINT32 nParaC)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        m_oIdMaker.<span class=\"hljs-built_in\">Init</span>(nParaA, nParaB, nParaC);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    &#125;\n    \n    <span class=\"hljs-comment\">/// init with pipeid</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nPipeId)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> Storm;\n        <span class=\"hljs-function\">CServerID <span class=\"hljs-title\">oServID</span><span class=\"hljs-params\">(nPipeId)</span></span>;\n        m_oIdMaker.<span class=\"hljs-built_in\">Init</span>(oServID.<span class=\"hljs-built_in\">GetPlat</span>(), oServID.<span class=\"hljs-built_in\">GetArea</span>(), oServID.<span class=\"hljs-built_in\">GetIndex</span>());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    &#125;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GenId</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> m_oIdMaker.<span class=\"hljs-built_in\">GenId</span>();\n    &#125;\n\n    <span class=\"hljs-function\">EUuidPoolState <span class=\"hljs-title\">GetUuidDequeState</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> m_oIdMaker.<span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">FillPoolWithInMli</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        m_oIdMaker.<span class=\"hljs-built_in\">FillPoolWithInMli</span>();\n    &#125;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GetCompareIdFromTime</span><span class=\"hljs-params\">(UINT32 nTimeVal)</span></span>;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GetTimeAddVal</span><span class=\"hljs-params\">(UINT32 nTimeVal)</span></span>;\n\n    <span class=\"hljs-function\">UINT32 <span class=\"hljs-title\">GetTimeValFromUuid</span><span class=\"hljs-params\">(UINT64 nUuid)</span></span>;\n\n<span class=\"hljs-keyword\">private</span>:\n    CSnowflakeIdMaker\tm_oIdMaker;\n&#125;;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  GEN_GLOBAL_UUID()  CUUIDMaker::Instance()-&gt;GenId()</span>\n\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n\n<span class=\"hljs-comment\">//gameserver </span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_pool_mgr.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_generator.h&quot;</span></span>\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CUUIDPool::Init</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::OnTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : &quot;</span> &lt;&lt; nId;\n    CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">FillPoolWithInMli</span>();\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::FillUuidPool</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EUuidPoolState eUuidDequeState = CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    uint32 nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n    <span class=\"hljs-keyword\">switch</span> (eUuidDequeState)\n    &#123;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Empty:\n        nUpdateInterval = <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_0_30_Per:\n        nUpdateInterval = <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_30_70_Per:\n        nUpdateInterval = <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_70_100_Per:\n        nUpdateInterval = <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Full:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    &#125;\n\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : &quot;</span> &lt;&lt; eUuidDequeState;\n    <span class=\"hljs-built_in\">SetTimer</span>(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n&#125;\n</code></pre>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://juejin.im/post/5a7f9176f265da4e721c73a8\">分布式唯一id：snowflake算法思考 - 掘金</a><br><a href=\"https://tech.meituan.com/MT_Leaf.html\">https://tech.meituan.com/2017/04/21/mt-leaf.html</a><br><a href=\"https://github.com/baidu/uid-generator\">GitHub - baidu&#x2F;uid-generator: UniqueID generator</a></p>\n","site":{"data":{}},"excerpt":"","more":"<!-- toc -->\n\n<ul>\n<li><a href=\"#%E5%89%8D%E8%A8%80\">前言</a></li>\n<li><a href=\"#Snowflake%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D\">Snowflake算法介绍</a></li>\n<li><a href=\"#SnowFlake%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96\">SnowFlake算法优化</a><ul>\n<li><a href=\"#%E7%9B%AE%E5%89%8D%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7\">目前算法设计缺陷</a></li>\n<li><a href=\"#%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96\">设计优化</a></li>\n</ul>\n</li>\n<li><a href=\"#%E6%98%AF%E5%90%A6%E8%BF%99%E6%A0%B7%E5%B0%B1%E5%AE%8C%E7%BE%8E%E4%BA%86%E5%91%A2%EF%BC%9F\">是否这样就完美了呢？</a></li>\n<li><a href=\"#Talk-is-cheap-show-you-the-code\">Talk is cheap, show you the code</a></li>\n<li><a href=\"#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0\">参考文章</a></li>\n</ul>\n<!-- tocstop -->\n\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在进程启动前，一般会给每个进程静态分配一个唯一标识ID(ServerID或者PipeID)</p>\n<pre><code class=\"hljs abnf\">struct SServerID\n&#123;\n    UINT16 wPlatform <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;\t ///&lt; Platform   平台id </span>\n    UINT16 wArea <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;        ///&lt; Area       区服id</span>\n    UINT16 wType <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;        ///&lt; Type       服务器App类型</span>\n    UINT16 wIndex <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;       ///&lt; Index      服务器App编号索引</span>\n&#125;<span class=\"hljs-comment\">;</span></code></pre>\n\n<p>每个Role&#x2F;Item&#x2F;Hero&#x2F;Mail 等创建的时候都会创建一个UUID来唯一标识，其中Mail_Uuid还有趋势递增的需求</p>\n<h2 id=\"Snowflake算法介绍\"><a href=\"#Snowflake算法介绍\" class=\"headerlink\" title=\"Snowflake算法介绍\"></a>Snowflake算法介绍</h2><p><em>SnowFlake分布式生成Id算法由Twitter开源</em></p>\n<p>SnowFlake算法生成id的结果是一个64bit大小的UINT64整数，它的结构如下图：<br><img src=\"/:storage%5C1a51b319-5d9b-40f9-a828-cfc88309cea2%5C4dbfceed.png\" alt=\"snowflake uuid-64bit\"></p>\n<p>SnowFlake的优点:<br>    - 整体上按照时间自增排序<br>    - 整个分布式系统内不会产生ID碰撞(时间戳和自增序列以外的字段作区分), 并且效率较高(位运算),</p>\n<p>SnowFlake每秒能够产生6.4万ID左右.(和5段位的配置位数有关)<br>UUID从高位到低位依次排列：</p>\n<ul>\n<li>第一段：39位, 当对于某一个时间点的时间戳差值（至少10年可用）</li>\n<li>第二段：3 位, 平台platform或大区id，比如QQ Android&#x2F;QQ IOS&#x2F;Wechat IOS 等（8）</li>\n<li>第三段：11位, 区服area id，对应的就是服务器小区的ID（2048）</li>\n<li>第四段：5 位, 服务器APP实例id index（32), Notice：appid需要在area范围内唯一</li>\n<li>第五段：6 位, 自增长id，也就是说在一个完整的毫秒时间内最多可以生成64个UUID</li>\n</ul>\n<h2 id=\"SnowFlake算法优化\"><a href=\"#SnowFlake算法优化\" class=\"headerlink\" title=\"SnowFlake算法优化\"></a>SnowFlake算法优化</h2><h3 id=\"目前算法设计缺陷\"><a href=\"#目前算法设计缺陷\" class=\"headerlink\" title=\"目前算法设计缺陷\"></a>目前算法设计缺陷</h3><p>在实际服务器运行过程中，尤其在游戏服务器开发期间，大量用户注册，会有瞬间生成大量UUID的需求</p>\n<p>之前服务器的做法是：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-comment\">//遍历了一圈64个，等下一个毫秒生成</span>\n<span class=\"hljs-keyword\">if</span> (m_nGlobalSeq == m_nMliSeq)\n&#123;\n    <span class=\"hljs-comment\">// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳</span>\n    nCurTimestamp = <span class=\"hljs-built_in\">WaitForNextMilli</span>(m_nLastTimestamp);\n&#125;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* 阻塞到下一个毫秒，直到获得新的时间戳</span>\n<span class=\"hljs-comment\">*</span>\n<span class=\"hljs-comment\">* @param lastTimestamp 上次生成ID的时间截</span>\n<span class=\"hljs-comment\">* @return 当前时间戳</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">WaitForNextMilli</span><span class=\"hljs-params\">(UINT64 lastTimestamp)</span> <span class=\"hljs-type\">const</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    UINT64 nTimestamp = _GetNowMliTime();\n    <span class=\"hljs-keyword\">while</span> (nTimestamp &lt;= lastTimestamp)\n    &#123;\n        nTimestamp = _GetNowMliTime();\n    &#125;\n    <span class=\"hljs-keyword\">return</span> nTimestamp;\n&#125;\n</code></pre>\n<p>这里使用while强行等待到下一毫秒，相当于阻塞当前线程，从而成为热点函数，需要去优化</p>\n<h3 id=\"设计优化\"><a href=\"#设计优化\" class=\"headerlink\" title=\"设计优化\"></a>设计优化</h3><ul>\n<li>合理分配各字段占用bit（图中已经是调整过的）</li>\n<li>将生成uuid单独出一个独立全局Server组件，提供全局唯一UUID服务，这样除去高位39bit外理论上其他bit都可以当作自增位，而且可以提前生成很多uuid放在pool当中，有需要的进程从当中取，可以满足需求，Baidu在github上开源的UUID生成算法就是这样处理的</li>\n<li>我们取一个折中方案，只是在server中加一个Pool，存放提前生成好的UUIDs，每次业务端需要UUID的时候首先从Pool中取，如果取不到就走原来的流程</li>\n</ul>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GenId</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">IsEmpty</span>())\n    &#123;\n        <span class=\"hljs-comment\">//从Pool中取</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">PopFrontElement</span>();\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">NextId</span>();\n&#125;</code></pre>\n\n<p>既然存在Pool，那么就需要设计Pool中元素填充方案<br>首先将Pool设定一个合适的固定最大值 const UINT32 UUID_POOL_MAX_SIZE &#x3D; 1 &lt;&lt; 13;   &#x2F;&#x2F;\t\tuuid pool 最大数 8192<br>然后根据当前Pool的状态，来定时填充，每次填充的数量为当前毫秒内所有可以生成的UUID数<br><img src=\"/:storage%5C1a51b319-5d9b-40f9-a828-cfc88309cea2%5C928daf4a.png\" alt=\"Fill_Pool.png\"></p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_pool_mgr.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_generator.h&quot;</span></span>\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CUUIDPool::Init</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::OnTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : &quot;</span> &lt;&lt; nId;\n    CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">FillPoolWithInMli</span>();\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::FillUuidPool</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EUuidPoolState eUuidDequeState = CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    uint32 nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n    <span class=\"hljs-keyword\">switch</span> (eUuidDequeState)\n    &#123;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Empty:\n        nUpdateInterval = <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_0_30_Per:\n        nUpdateInterval = <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_30_70_Per:\n        nUpdateInterval = <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_70_100_Per:\n        nUpdateInterval = <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Full:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    &#125;\n\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : &quot;</span> &lt;&lt; eUuidDequeState;\n    <span class=\"hljs-built_in\">SetTimer</span>(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n&#125;\n\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">EUuidPoolState</span>\n&#123;\n    EUuidPoolState_Empty\t\t\t\t= <span class=\"hljs-number\">1</span>,\n    EUuidPoolState_Not_Full_0_30_Per\t= <span class=\"hljs-number\">2</span>,\n    EUuidPoolState_Not_Full_30_70_Per\t= <span class=\"hljs-number\">3</span>,\n    EUuidPoolState_Not_Full_70_100_Per\t= <span class=\"hljs-number\">4</span>,\n    EUuidPoolState_Full\t\t\t\t\t= <span class=\"hljs-number\">5</span>,\n&#125;;\n\n<span class=\"hljs-comment\">//uuid_generator.h</span>\n<span class=\"hljs-comment\">//将当前毫秒内的UUID全部生成并存到Pool中</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">FillPoolWithInMli</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EUuidPoolState nCurState = <span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    AtomicUInt64 nCurTimestamp = _GetNowMliTime();\n    <span class=\"hljs-keyword\">while</span> (nCurState != EUuidPoolState_Full)\n    &#123;\n        UINT64 nNextUUId = <span class=\"hljs-built_in\">NextId</span>(<span class=\"hljs-literal\">false</span>);\n        <span class=\"hljs-keyword\">if</span> (nNextUUId == <span class=\"hljs-number\">0</span>)\n        &#123;\n            <span class=\"hljs-keyword\">break</span>;\n        &#125;\n\n        <span class=\"hljs-built_in\">PushBackElement</span>(nNextUUId);\n\n        <span class=\"hljs-keyword\">if</span> (nCurTimestamp != _GetNowMliTime())\n        &#123;\n            <span class=\"hljs-keyword\">break</span>;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n\n<h2 id=\"是否这样就完美了呢？\"><a href=\"#是否这样就完美了呢？\" class=\"headerlink\" title=\"是否这样就完美了呢？\"></a>是否这样就完美了呢？</h2><p>并没有呢！！！<br>这个算法强制依赖时间递增，如果时间回拨怎么办？<br>目前的做法是直接throw new exception<br>分析时间回拨产生原因<br>第一：人物操作，在真实环境一般不会有那个傻逼干这种事情，所以基本可以排除。<br>第二：由于有些业务等需要，机器需要同步时间服务器（在这个过程中可能会存在时间回拨，查了下我们服务器一般在10ms以内（2小时同步一次））。 Ntp过程可能产生时间回拨。<br>第三：QA和策划测试过程中有需求怎么办？<br>解决办法：</p>\n<ol>\n<li>将uuid_generation独立出来给其他server提供服务</li>\n<li>当回拨时间小于XXms，就等时间追上来之后继续生成。 (XXms对业务没有什么影响)</li>\n<li>当时间大于XXms时间我们通过更换AppId位来来解决回拨问题。</li>\n</ol>\n<h2 id=\"Talk-is-cheap-show-you-the-code\"><a href=\"#Talk-is-cheap-show-you-the-code\" class=\"headerlink\" title=\"Talk is cheap, show you the code\"></a>Talk is cheap, show you the code</h2><pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> __UUID_GENERATOR_H__</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> __UUID_GENERATOR_H__</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnsingleton.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gntype.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnpipe.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gntime.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;noncopy.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnserverid.h&quot;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;mutex&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;atomic&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;chrono&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;exception&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sstream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;deque&gt;</span></span>\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">EUuidPoolState</span>\n&#123;\n    EUuidPoolState_Empty\t\t\t\t= <span class=\"hljs-number\">1</span>,\n    EUuidPoolState_Not_Full_0_30_Per\t= <span class=\"hljs-number\">2</span>,\n    EUuidPoolState_Not_Full_30_70_Per\t= <span class=\"hljs-number\">3</span>,\n    EUuidPoolState_Not_Full_70_100_Per\t= <span class=\"hljs-number\">4</span>,\n    EUuidPoolState_Full\t\t\t\t\t= <span class=\"hljs-number\">5</span>,\n&#125;;\n\n<span class=\"hljs-comment\">//#define SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CSnowflakeIdMaker</span> : <span class=\"hljs-keyword\">private</span> CNoncopy\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n    <span class=\"hljs-keyword\">typedef</span> std::atomic&lt;UINT32&gt; AtomicUInt;\n    <span class=\"hljs-keyword\">typedef</span> std::atomic&lt;UINT64&gt; AtomicUInt64;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n    <span class=\"hljs-keyword\">typedef</span> UINT32 AtomicUInt;\n    <span class=\"hljs-keyword\">typedef</span> UINT64 AtomicUInt64;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    <span class=\"hljs-type\">const</span> UINT32 UUID_POOL_MAX_SIZE = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">13</span>;   <span class=\"hljs-comment\">//\t\tuuid pool 最大数 8192</span>\n    <span class=\"hljs-type\">const</span> UINT64 START_EPOCH\t\t\t= <span class=\"hljs-number\">1541001600000LL</span>;\t\t<span class=\"hljs-comment\">//开始时间截 (2018-11-01 00:00:00.000)，修改此时间可调整可用时长</span>\n                               \n    <span class=\"hljs-type\">const</span> UINT32 A_TIMESTAMP_BITS\t\t= <span class=\"hljs-number\">39</span>;\t\t\t\t\t<span class=\"hljs-comment\">//时间戳所占的位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 B_PLATFORM_BITS\t\t= <span class=\"hljs-number\">3</span>;\t\t\t\t\t<span class=\"hljs-comment\">//平台id所占的位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 C_AREA_BITS\t\t\t= <span class=\"hljs-number\">11</span>;\t\t\t\t\t<span class=\"hljs-comment\">//区服id所占的位</span>\n    <span class=\"hljs-type\">const</span> UINT32 D_APP_ID_BITS\t\t\t= <span class=\"hljs-number\">5</span>;\t\t\t\t\t<span class=\"hljs-comment\">//app id所占的位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 E_INCR_SEQUENCE_BITS\t= <span class=\"hljs-number\">6</span>;\t\t\t\t    <span class=\"hljs-comment\">//自增序列所占的位数</span>\n\n    <span class=\"hljs-type\">const</span> UINT32 APP_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS;\t\t<span class=\"hljs-comment\">//APPID向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 AREA_ID_SHIFT\t\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS;\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//小区id向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 PLATFORM_ID_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS;\t\t\t\t\t\t<span class=\"hljs-comment\">//大区id向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 TIME_STAMP_SHIFT\t\t= E_INCR_SEQUENCE_BITS + D_APP_ID_BITS + C_AREA_BITS + B_PLATFORM_BITS;\t\t<span class=\"hljs-comment\">//时间戳向左移位数</span>\n    <span class=\"hljs-type\">const</span> UINT32 SEQUENCE_MASK\t\t\t= (<span class=\"hljs-number\">1</span> &lt;&lt; E_INCR_SEQUENCE_BITS) - <span class=\"hljs-number\">1</span>;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"hljs-comment\">//生成序列的掩码</span>\n\n\n    <span class=\"hljs-built_in\">CSnowflakeIdMaker</span>() : <span class=\"hljs-built_in\">m_nPlatformId</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">m_nAreaId</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">m_nGlobalSeq</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">m_nLastTimestamp</span>(<span class=\"hljs-number\">0</span>) &#123;&#125;\n\n    <span class=\"hljs-built_in\">CSnowflakeIdMaker</span>(<span class=\"hljs-type\">const</span> UINT32 nPlatId, <span class=\"hljs-type\">const</span> UINT32 nAreaId, <span class=\"hljs-type\">const</span> UINT32 nAppId)\n    &#123;\n        <span class=\"hljs-built_in\">Init</span>(nPlatId, nAreaId, nAppId);\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT32 nPlatId, <span class=\"hljs-type\">const</span> UINT32 nAreaId, <span class=\"hljs-type\">const</span> UINT32 nAppId)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        m_nPlatformId = nPlatId;\n        m_nAreaId = nAreaId;\n        m_nAppId = nAppId;\n    &#125;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GenId</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">IsEmpty</span>())\n        &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">PopFrontElement</span>();\n        &#125;\n\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">NextId</span>();\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 获得下一个ID (该方法是线程安全的)</span>\n<span class=\"hljs-comment\">    * @param  bCanBlock 参数指定当前函数是否可以阻塞, 默认为true</span>\n<span class=\"hljs-comment\">    * @return SnowflakeId</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">NextId</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> bCanBlock = <span class=\"hljs-literal\">true</span>)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span>  std;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n        <span class=\"hljs-type\">static</span> AtomicUInt64 nCurTimestamp&#123; <span class=\"hljs-number\">0</span> &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;\n        AtomicUInt64 nCurTimestamp&#123; <span class=\"hljs-number\">0</span> &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        nCurTimestamp = _GetNowMliTime();\n\n        <span class=\"hljs-comment\">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span>\n        <span class=\"hljs-keyword\">if</span> (nCurTimestamp &lt; m_nLastTimestamp)\n        &#123;\n            std::ostringstream oSS;\n            oSS &lt;&lt; <span class=\"hljs-string\">&quot;clock moved backwards.  Refusing to generate id for &quot;</span> &lt;&lt; m_nLastTimestamp - nCurTimestamp &lt;&lt; <span class=\"hljs-string\">&quot; milliseconds&quot;</span>;\n            <span class=\"hljs-keyword\">throw</span> std::<span class=\"hljs-built_in\">exception</span>(std::<span class=\"hljs-built_in\">runtime_error</span>(oSS.<span class=\"hljs-built_in\">str</span>()));\n        &#125;\n\n        m_nGlobalSeq = (m_nGlobalSeq + <span class=\"hljs-number\">1</span>) &amp; SEQUENCE_MASK;\n\n        <span class=\"hljs-comment\">// 为了使id递增+1均匀分布，这里seq跨毫秒也不清0</span>\n        <span class=\"hljs-keyword\">if</span> (m_nLastTimestamp == nCurTimestamp)\n        &#123;\n            <span class=\"hljs-comment\">//遍历了一圈64个，等下一个毫秒生成</span>\n            <span class=\"hljs-keyword\">if</span> (m_nGlobalSeq == m_nMliSeq)\n            &#123;\n                <span class=\"hljs-keyword\">if</span> (bCanBlock)\n                &#123;\n                    <span class=\"hljs-comment\">// 毫秒内序列溢出, 阻塞到下一个毫秒,获得新的时间戳</span>\n                    nCurTimestamp = <span class=\"hljs-built_in\">WaitForNextMilli</span>(m_nLastTimestamp);\n                &#125;\n                <span class=\"hljs-keyword\">else</span>\n                &#123;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n                &#125;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">else</span>\n        &#123;\t\n            m_nMliSeq = m_nGlobalSeq;\n        &#125;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n        m_nLastTimestamp = nCurTimestamp.<span class=\"hljs-built_in\">load</span>();\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        m_nLastTimestamp = nCurTimestamp;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        <span class=\"hljs-comment\">// 移位并通过或运算拼到一起组成64位的ID</span>\n        <span class=\"hljs-keyword\">return</span> ((nCurTimestamp - START_EPOCH) &lt;&lt; TIME_STAMP_SHIFT)\n            | (m_nPlatformId &lt;&lt; PLATFORM_ID_SHIFT)\n            | (m_nAreaId &lt;&lt; AREA_ID_SHIFT)\n            | (m_nAppId &lt;&lt; APP_ID_SHIFT)\n            | (m_nGlobalSeq);\n    &#125;\n\n    <span class=\"hljs-function\">EUuidPoolState <span class=\"hljs-title\">GetUuidDequeState</span><span class=\"hljs-params\">()</span> </span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">if</span> (m_deUuidPool.<span class=\"hljs-built_in\">empty</span>())\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Empty;\n        &#125;\n\n        <span class=\"hljs-type\">size_t</span> nCurPoolSize = m_deUuidPool.<span class=\"hljs-built_in\">size</span>();\n        <span class=\"hljs-keyword\">if</span> (nCurPoolSize &gt;= UUID_POOL_MAX_SIZE)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Full;\n        &#125;\n\n        uint32 nCurPercent = nCurPoolSize * <span class=\"hljs-number\">100</span> / UUID_POOL_MAX_SIZE;\n        <span class=\"hljs-keyword\">if</span> (nCurPercent &lt; <span class=\"hljs-number\">30</span>)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Not_Full_0_30_Per;\n        &#125;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nCurPercent &lt; <span class=\"hljs-number\">70</span>)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Not_Full_30_70_Per;\n        &#125;\n        <span class=\"hljs-keyword\">else</span>\n        &#123;\n            <span class=\"hljs-keyword\">return</span> EUuidPoolState_Not_Full_70_100_Per;\n        &#125;\n\n        <span class=\"hljs-keyword\">return</span> EUuidPoolState_Full;\n    &#125; \n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">FillPoolWithInMli</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        EUuidPoolState nCurState = <span class=\"hljs-built_in\">GetUuidDequeState</span>();\n        AtomicUInt64 nCurTimestamp = _GetNowMliTime();\n        <span class=\"hljs-keyword\">while</span> (nCurState != EUuidPoolState_Full)\n        &#123;\n            UINT64 nNextUUId = <span class=\"hljs-built_in\">NextId</span>(<span class=\"hljs-literal\">false</span>);\n            <span class=\"hljs-keyword\">if</span> (nNextUUId == <span class=\"hljs-number\">0</span>)\n            &#123;\n                <span class=\"hljs-keyword\">break</span>;\n            &#125;\n            \n            <span class=\"hljs-built_in\">PushBackElement</span>(nNextUUId);\n\n            <span class=\"hljs-keyword\">if</span> (nCurTimestamp != _GetNowMliTime())\n            &#123;\n                <span class=\"hljs-keyword\">break</span>;\n            &#125;\n        &#125;\n    &#125;\n\n<span class=\"hljs-keyword\">protected</span>:\n\n    <span class=\"hljs-comment\">//判断pool是否为空</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">IsEmpty</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> m_deUuidPool.<span class=\"hljs-built_in\">empty</span>();\n    &#125;\n\n    <span class=\"hljs-comment\">//返回pool队列中front 元素</span>\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">PopFrontElement</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n        \n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n        UINT64 nFrontElement = m_deUuidPool.<span class=\"hljs-built_in\">front</span>();\n        m_deUuidPool.<span class=\"hljs-built_in\">pop_front</span>();\n        <span class=\"hljs-keyword\">return</span> nFrontElement;\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PushBackElement</span><span class=\"hljs-params\">(UINT64 nNextUUId)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n        std::unique_lock&lt;std::mutex&gt; oLock&#123; m_oMutex &#125;;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n        m_deUuidPool.<span class=\"hljs-built_in\">push_back</span>(nNextUUId);\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 返回以毫秒为单位的当前时间</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * @return 当前时间(毫秒)</span>\n<span class=\"hljs-comment\">    */</span>\n    UINT64 _GetNowMliTime() <span class=\"hljs-type\">const</span>\n    &#123;\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>)\n        &#123;\n            Storm::CSTDateTime oDateTime;\n            oDateTime.<span class=\"hljs-built_in\">Now</span>();\n            <span class=\"hljs-keyword\">return</span> oDateTime.<span class=\"hljs-built_in\">EpochMilliSecs</span>();\n        &#125;\n        <span class=\"hljs-keyword\">else</span>\n        &#123;\n            <span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\n            <span class=\"hljs-keyword\">auto</span> nTimeNow = chrono::system_clock::<span class=\"hljs-built_in\">now</span>();\n            <span class=\"hljs-keyword\">auto</span> nDurationInMs = chrono::<span class=\"hljs-built_in\">duration_cast</span>&lt;chrono::milliseconds&gt;(nTimeNow.<span class=\"hljs-built_in\">time_since_epoch</span>());\n            <span class=\"hljs-keyword\">return</span> nDurationInMs.<span class=\"hljs-built_in\">count</span>();\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * 阻塞到下一个毫秒，直到获得新的时间戳</span>\n<span class=\"hljs-comment\">    *</span>\n<span class=\"hljs-comment\">    * @param lastTimestamp 上次生成ID的时间截</span>\n<span class=\"hljs-comment\">    * @return 当前时间戳</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">WaitForNextMilli</span><span class=\"hljs-params\">(UINT64 lastTimestamp)</span> <span class=\"hljs-type\">const</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        UINT64 nTimestamp = _GetNowMliTime();\n        <span class=\"hljs-keyword\">while</span> (nTimestamp &lt;= lastTimestamp)\n        &#123;\n            nTimestamp = _GetNowMliTime();\n        &#125;\n        <span class=\"hljs-keyword\">return</span> nTimestamp;\n    &#125;\n\n<span class=\"hljs-keyword\">private</span>:\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> SNOWFLAKE_ID_MAKER_NO_LOCK</span>\n    std::mutex\t\tm_oMutex;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    UINT32\t\t\tm_nPlatformId = <span class=\"hljs-number\">0</span>;\t\t<span class=\"hljs-comment\">//平台id</span>\n    UINT32\t\t\tm_nAreaId = <span class=\"hljs-number\">0</span>;\t\t\t<span class=\"hljs-comment\">//区服id</span>\n    UINT32\t\t\tm_nAppId = <span class=\"hljs-number\">0</span>;\t\t\t<span class=\"hljs-comment\">//Appid</span>\n    AtomicUInt\t\tm_nGlobalSeq&#123; <span class=\"hljs-number\">0</span> &#125;;\t\t<span class=\"hljs-comment\">//全局序列</span>\n    AtomicUInt\t\tm_nMliSeq&#123; <span class=\"hljs-number\">0</span> &#125;;\t\t\t<span class=\"hljs-comment\">//每毫秒序列</span>\n    AtomicUInt64\tm_nLastTimestamp&#123; <span class=\"hljs-number\">0</span> &#125;;\t<span class=\"hljs-comment\">//上次生成ID的时间截</span>\n    std::deque&lt;UINT64&gt; m_deUuidPool;\t\t\t<span class=\"hljs-comment\">//uuid池 用于存放预生成uuids</span>\n&#125;;\n\n\n\n<span class=\"hljs-comment\">/************************************************************************/</span>\n<span class=\"hljs-comment\">/* 负责生成全局唯一id                                                */</span>\n<span class=\"hljs-comment\">/************************************************************************/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CUUIDMaker</span> : <span class=\"hljs-keyword\">public</span> Storm::TSingleton&lt;CUUIDMaker&gt;\n&#123;\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Storm</span>::TSingleton&lt;CUUIDMaker&gt;;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT32 nParaA, <span class=\"hljs-type\">const</span> UINT32 nParaB, <span class=\"hljs-type\">const</span> UINT32 nParaC)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        m_oIdMaker.<span class=\"hljs-built_in\">Init</span>(nParaA, nParaB, nParaC);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    &#125;\n    \n    <span class=\"hljs-comment\">/// init with pipeid</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nPipeId)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> Storm;\n        <span class=\"hljs-function\">CServerID <span class=\"hljs-title\">oServID</span><span class=\"hljs-params\">(nPipeId)</span></span>;\n        m_oIdMaker.<span class=\"hljs-built_in\">Init</span>(oServID.<span class=\"hljs-built_in\">GetPlat</span>(), oServID.<span class=\"hljs-built_in\">GetArea</span>(), oServID.<span class=\"hljs-built_in\">GetIndex</span>());\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n    &#125;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GenId</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> m_oIdMaker.<span class=\"hljs-built_in\">GenId</span>();\n    &#125;\n\n    <span class=\"hljs-function\">EUuidPoolState <span class=\"hljs-title\">GetUuidDequeState</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> m_oIdMaker.<span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    &#125;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">FillPoolWithInMli</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        m_oIdMaker.<span class=\"hljs-built_in\">FillPoolWithInMli</span>();\n    &#125;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GetCompareIdFromTime</span><span class=\"hljs-params\">(UINT32 nTimeVal)</span></span>;\n\n    <span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">GetTimeAddVal</span><span class=\"hljs-params\">(UINT32 nTimeVal)</span></span>;\n\n    <span class=\"hljs-function\">UINT32 <span class=\"hljs-title\">GetTimeValFromUuid</span><span class=\"hljs-params\">(UINT64 nUuid)</span></span>;\n\n<span class=\"hljs-keyword\">private</span>:\n    CSnowflakeIdMaker\tm_oIdMaker;\n&#125;;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>  GEN_GLOBAL_UUID()  CUUIDMaker::Instance()-&gt;GenId()</span>\n\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n\n<span class=\"hljs-comment\">//gameserver </span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_pool_mgr.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;uuid_generator.h&quot;</span></span>\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CUUIDPool::Init</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::OnTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Old EUuidPoolState : &quot;</span> &lt;&lt; nId;\n    CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">FillPoolWithInMli</span>();\n    <span class=\"hljs-built_in\">FillUuidPool</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CUUIDPool::FillUuidPool</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    EUuidPoolState eUuidDequeState = CUUIDMaker::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">GetUuidDequeState</span>();\n    uint32 nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n    <span class=\"hljs-keyword\">switch</span> (eUuidDequeState)\n    &#123;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Empty:\n        nUpdateInterval = <span class=\"hljs-number\">1</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_0_30_Per:\n        nUpdateInterval = <span class=\"hljs-number\">2</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_30_70_Per:\n        nUpdateInterval = <span class=\"hljs-number\">3</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Not_Full_70_100_Per:\n        nUpdateInterval = <span class=\"hljs-number\">4</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">case</span> EUuidPoolState_Full:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    <span class=\"hljs-keyword\">default</span>:\n        nUpdateInterval = <span class=\"hljs-number\">5</span> * <span class=\"hljs-number\">60</span> * <span class=\"hljs-number\">1000</span>;\n        <span class=\"hljs-keyword\">break</span>;\n    &#125;\n\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzUuid]CUUIDPool::OnTimer Now EUuidPoolState : &quot;</span> &lt;&lt; eUuidDequeState;\n    <span class=\"hljs-built_in\">SetTimer</span>(eUuidDequeState, nUpdateInterval, nUpdateInterval, ETIMER_ONCE);\n&#125;\n</code></pre>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\"参考文章\"></a>参考文章</h2><p><a href=\"https://juejin.im/post/5a7f9176f265da4e721c73a8\">分布式唯一id：snowflake算法思考 - 掘金</a><br><a href=\"https://tech.meituan.com/MT_Leaf.html\">https://tech.meituan.com/2017/04/21/mt-leaf.html</a><br><a href=\"https://github.com/baidu/uid-generator\">GitHub - baidu&#x2F;uid-generator: UniqueID generator</a></p>\n"},{"title":"单生产者单消费者环形缓冲","date":"2020-01-23T07:12:50.000Z","_content":"\n头文件\n```c++\n#ifndef _SIMPLE_LOOP_BUFFER_H__\n#define _SIMPLE_LOOP_BUFFER_H__\n\n#include \"gntype.h\"\n#include \"gnmutex.h\"\n#include \"gnlock.h\"\n#include \"server_define.h\"\nusing namespace Storm;\n\ntypedef struct _tagBlock\n{\n    _tagBlock() \n    {\n        memset(pBuffer, 0, sizeof(char)*(MAX_CACHE_PACKET_SIZE + 1));\n    }\n    ~_tagBlock() {};\n\n    char  pBuffer[MAX_CACHE_PACKET_SIZE + 1]; \n    char* GetBuff() { return pBuffer; }\n    int32 GetBuffLen() { return MAX_CACHE_PACKET_SIZE + 1; }\n}CBlock;\n\nclass CSimpleLoopBufferEx\n{\npublic:\n    CSimpleLoopBufferEx();\n    ~CSimpleLoopBufferEx();\n\n    void Clear();\n\n    /**\n    * @brief\n    * 初始化循环缓冲区\n    * @param nSize : 初始化虚幻缓冲区的大小，实际大小为nSize+1\n    * @return 成功返回true，失败返回false\n    */\n    bool Init();\n\n    /**\n    * @brief\n    * 将需要存储的Buffer拷贝到循环缓冲区的结尾\n    * @param pData : [输入参数]指向需要插入循环缓冲区的Buffer起始位置\n    * @param nLen : 指向需要插入的Buffer的长度\n    * @return 如果循环缓冲区拥有的大小大于等于nLen，返回true，否则返回false\n    * @remark 此函数不是线程安全的\n    */\n    INT32 PushBack(const CHAR *pData, INT32 nLen);\n\n    /**\n    * @brief\n    * 从循环缓冲区的起始位置取nLen长度的Buffer，拷贝放入Buffer中\n    * @param pBuf : [输入输出参数]获取数据的Buffer的起始指针\n    * @param nLen : 需要读出的Buffer长度\n    * @return 如果有足够所需读出的数据，返回true，否则返回false\n    * @remark 此函数不是线程安全的\n    */\n    INT32 PopFront(CHAR * &pBuf, INT32 nLen,CHAR* szData);\n\n    /**\n    * @brief\n    * 丢弃nLen长度的数据\n    * @param nLen : 需要丢弃的长度\n    * @return void\n    * @remark 此函数不是线程安全的\n    */\n    bool DiscardFront(INT32 nLen);\n\n    /**\n    * @brief\n    * 获取剩余可用空间大小\n    * @return INT32\n    * @remark 此函数不是线程安全的\n    */\n    INT32 GetFreeSpare();\n\n    /**\n    * @brief\n    * 拷贝内存中的数据\n    * @param nReadOffSet : m_pNextRead的偏移量\n    * @param nLen : 需要读出的Buffer长度\n    * @remark 此函数不是线程安全的\n    */\n    INT32 GetData(INT32 nReadOffSet,INT32 nLen, CHAR* szData);\n\n\nprivate:\n    CHAR    *m_pBuffer;\n    CHAR    *m_pNextRead;\n    CHAR    *m_pNextWrite;\n    CHAR    *m_pEnd;\n};\n\n#endif\n```\n\n实现\n\n```c++\n#include \"simpleloopbuffer.h\"\n#include <stdio.h>\n#include <memory.h>\n#include \"gndebug.h\"\n#include \"../../common/commonloggerex.h\"\n#include \"gate_factory.h\"\n\n\nusing namespace Storm;\n\nCSimpleLoopBufferEx::CSimpleLoopBufferEx() :\n    m_pBuffer(NULL),\n    m_pNextRead(NULL),\n    m_pNextWrite(NULL),\n    m_pEnd(NULL)\n{\n}\n\nCSimpleLoopBufferEx::~CSimpleLoopBufferEx()\n{\n    if (NULL != m_pBuffer)\n    {\n        CGateFactory::Instance()->ReleaseBlock((CBlock*)m_pBuffer);\n        m_pBuffer = NULL;\n        //delete[] m_pBuffer;\n        //m_pBuffer = NULL;\n    }\n}\n\nvoid CSimpleLoopBufferEx::Clear()\n{\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n}\n\nbool CSimpleLoopBufferEx::Init()\n{\n    //m_pBuffer = SDNew char[nSize + 1];\n    CBlock* pBlock = CGateFactory::Instance()->CreateBlock();\n    if (!pBlock)\n        return false;\n\n    m_pBuffer = pBlock->GetBuff();\n    if (NULL == m_pBuffer)\n    {\n        return false;\n    }\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n    //m_pEnd = m_pBuffer + nSize + 1;\n    m_pEnd = m_pBuffer + pBlock->GetBuffLen();\n    return true;\n}\n\nINT32 CSimpleLoopBufferEx::PushBack(const CHAR *pData, INT32 nLen)\n{\n    CHAR* poRead = m_pNextRead;\n    if (m_pNextWrite >= poRead)\n    {\n        //  1、尾部指针减去写起始位置小于 nLen \n        //  2、读的起始位置减去内存首地址 小于nLen\n        //  内存空间不够，不能将数据写入缓存\n        /*                          == 内存模型 ==\n                   (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        if (nLeft + nRight <= nLen)\n        {\n            return -1;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n                                       m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poRead - m_pNextWrite <= nLen)\n        {\n            return -2;\n        }\n    }\n    //     else  //  m_pNextWrite == m_pNextRead\n    //     {\n    //         if (m_pNextWrite > m_pBuffer)\n    //         {\n    //             m_oMutex.Unlock();\n    //             return -3;\n    //         }\n    //     }\n    if (m_pEnd - m_pNextWrite > nLen)\n    {\n        memcpy(m_pNextWrite, pData, nLen);\n        m_pNextWrite += nLen;\n    }\n    else if (m_pEnd - m_pNextWrite == nLen)\n    {\n        memcpy(m_pNextWrite, pData, nLen);\n        m_pNextWrite = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - m_pNextWrite;\n        memcpy(m_pNextWrite, pData, nStartLen);\n        memcpy(m_pBuffer, pData + nStartLen, nLen - nStartLen);\n        m_pNextWrite = m_pBuffer + nLen - nStartLen;\n    }\n    return nLen;\n}\n\nINT32 CSimpleLoopBufferEx::PopFront(CHAR * &pBuf, INT32 nLen, CHAR* szData)\n{\n    CHAR* poNextWrite = m_pNextWrite;\n    if (poNextWrite == m_pNextRead)\n    {\n        EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-1\";\n        return -1;\n    }\n    if (poNextWrite > m_pNextRead)\n    {\n        /*                          == 内存模型 ==\n                   (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poNextWrite - m_pNextRead < nLen)\n        {\n            EXLOG_ERROR << \"PopFront failed! ErrCode:-2\";\n            return -2;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n                                      m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        if (nLeft + nRight < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-3\";\n            return -3;\n        }\n    }\n    if (m_pEnd - m_pNextRead > nLen)\n    {\n        memcpy(szData, m_pNextRead, nLen);\n        m_pNextRead += nLen;\n    }\n    else if (m_pEnd - m_pNextRead == nLen)\n    {\n        memcpy(szData, m_pNextRead, nLen);\n        m_pNextRead = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        memcpy(szData, m_pNextRead, nStartLen);\n        memcpy(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    }\n    return nLen;\n}\n\n\nbool CSimpleLoopBufferEx::DiscardFront(INT32 nLen)\n{\n    CHAR* poNextWrite = m_pNextWrite;\n    if (poNextWrite == m_pNextRead)\n    {\n        EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-1\";\n        return false;\n    }\n    if (poNextWrite > m_pNextRead)\n    {\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poNextWrite - m_pNextRead < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-2\";\n            return false;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        if (nLeft + nRight < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-3\";\n            return false;\n        }\n    }\n    if (m_pEnd - m_pNextRead > nLen)\n    {\n        m_pNextRead += nLen;\n    }\n    else if (m_pEnd - m_pNextRead == nLen)\n    {\n        m_pNextRead = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    }\n\n    return true;\n}\n\nINT32 CSimpleLoopBufferEx::GetFreeSpare()\n{\n    CHAR* poRead = m_pNextRead;\n    if (m_pNextWrite >= poRead)\n    {\n        //  1、尾部指针减去写起始位置小于 nLen \n        //  2、读的起始位置减去内存首地址 小于nLen\n        //  内存空间不够，不能将数据写入缓存\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        return nLeft + nRight;\n\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n\n        return poRead - m_pNextWrite;\n    }\n}\n\nINT32 CSimpleLoopBufferEx::GetData(INT32 nReadOffSet, INT32 nLen, CHAR* szData)\n{\n    //指针偏移\n    CHAR* poNextWrite = m_pNextWrite;\n    if (poNextWrite == m_pNextRead)\n    {\n        EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-1\";\n        return -1;\n    }\n\n    CHAR *pReadOffSet = m_pNextRead + nReadOffSet;\n    if (poNextWrite > m_pNextRead)\n    {\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n\n        if (pReadOffSet >= m_pNextWrite)\n        {\n            EXLOG_ERROR << \"GetData failed! ErrCode:-2\";\n            return -2;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n\n        if (pReadOffSet < m_pEnd)\n        {\n\n        }\n        else if (pReadOffSet == m_pEnd)\n        {\n            pReadOffSet = m_pBuffer;\n            if (pReadOffSet >= m_pNextWrite)\n            {\n                EXLOG_ERROR << \"GetData failed! ErrCode:-3\";\n                return -3;\n            }\n        }\n        else {\n            pReadOffSet = m_pBuffer + nReadOffSet - (m_pEnd - m_pNextRead);\n            if (pReadOffSet >= m_pNextWrite)\n            {\n                EXLOG_ERROR << \"GetData failed! ErrCode:-4\";\n                return -4;\n            }\n        }\n    }\n\n    //拷贝数据\n\n    if (poNextWrite > pReadOffSet)\n    {\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poNextWrite - pReadOffSet < nLen)\n        {\n            EXLOG_ERROR << \"PopFront failed! ErrCode:-5\";\n            return -5;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - pReadOffSet;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        if (nLeft + nRight < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-6\";\n            return -6;\n        }\n    }\n    if (m_pEnd - pReadOffSet > nLen)\n    {\n        memcpy(szData, pReadOffSet, nLen);\n        //pReadOffSet += nLen;\n    }\n    else if (m_pEnd - pReadOffSet == nLen)\n    {\n        memcpy(szData, pReadOffSet, nLen);\n        //pReadOffSet = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - pReadOffSet;\n        memcpy(szData, pReadOffSet, nStartLen);\n        memcpy(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        //m_pNextRead = m_pBuffer + nLen - nStartLen;\n    }\n\n\n    return nLen;\n\n}\n\n```","source":"_posts/单生产者单消费者环形缓冲.md","raw":"\n---\ntitle: 单生产者单消费者环形缓冲\ndate: 2020-01-23 15:12:50\ntags: ringbuff\ncategories: C/C++\n---\n\n头文件\n```c++\n#ifndef _SIMPLE_LOOP_BUFFER_H__\n#define _SIMPLE_LOOP_BUFFER_H__\n\n#include \"gntype.h\"\n#include \"gnmutex.h\"\n#include \"gnlock.h\"\n#include \"server_define.h\"\nusing namespace Storm;\n\ntypedef struct _tagBlock\n{\n    _tagBlock() \n    {\n        memset(pBuffer, 0, sizeof(char)*(MAX_CACHE_PACKET_SIZE + 1));\n    }\n    ~_tagBlock() {};\n\n    char  pBuffer[MAX_CACHE_PACKET_SIZE + 1]; \n    char* GetBuff() { return pBuffer; }\n    int32 GetBuffLen() { return MAX_CACHE_PACKET_SIZE + 1; }\n}CBlock;\n\nclass CSimpleLoopBufferEx\n{\npublic:\n    CSimpleLoopBufferEx();\n    ~CSimpleLoopBufferEx();\n\n    void Clear();\n\n    /**\n    * @brief\n    * 初始化循环缓冲区\n    * @param nSize : 初始化虚幻缓冲区的大小，实际大小为nSize+1\n    * @return 成功返回true，失败返回false\n    */\n    bool Init();\n\n    /**\n    * @brief\n    * 将需要存储的Buffer拷贝到循环缓冲区的结尾\n    * @param pData : [输入参数]指向需要插入循环缓冲区的Buffer起始位置\n    * @param nLen : 指向需要插入的Buffer的长度\n    * @return 如果循环缓冲区拥有的大小大于等于nLen，返回true，否则返回false\n    * @remark 此函数不是线程安全的\n    */\n    INT32 PushBack(const CHAR *pData, INT32 nLen);\n\n    /**\n    * @brief\n    * 从循环缓冲区的起始位置取nLen长度的Buffer，拷贝放入Buffer中\n    * @param pBuf : [输入输出参数]获取数据的Buffer的起始指针\n    * @param nLen : 需要读出的Buffer长度\n    * @return 如果有足够所需读出的数据，返回true，否则返回false\n    * @remark 此函数不是线程安全的\n    */\n    INT32 PopFront(CHAR * &pBuf, INT32 nLen,CHAR* szData);\n\n    /**\n    * @brief\n    * 丢弃nLen长度的数据\n    * @param nLen : 需要丢弃的长度\n    * @return void\n    * @remark 此函数不是线程安全的\n    */\n    bool DiscardFront(INT32 nLen);\n\n    /**\n    * @brief\n    * 获取剩余可用空间大小\n    * @return INT32\n    * @remark 此函数不是线程安全的\n    */\n    INT32 GetFreeSpare();\n\n    /**\n    * @brief\n    * 拷贝内存中的数据\n    * @param nReadOffSet : m_pNextRead的偏移量\n    * @param nLen : 需要读出的Buffer长度\n    * @remark 此函数不是线程安全的\n    */\n    INT32 GetData(INT32 nReadOffSet,INT32 nLen, CHAR* szData);\n\n\nprivate:\n    CHAR    *m_pBuffer;\n    CHAR    *m_pNextRead;\n    CHAR    *m_pNextWrite;\n    CHAR    *m_pEnd;\n};\n\n#endif\n```\n\n实现\n\n```c++\n#include \"simpleloopbuffer.h\"\n#include <stdio.h>\n#include <memory.h>\n#include \"gndebug.h\"\n#include \"../../common/commonloggerex.h\"\n#include \"gate_factory.h\"\n\n\nusing namespace Storm;\n\nCSimpleLoopBufferEx::CSimpleLoopBufferEx() :\n    m_pBuffer(NULL),\n    m_pNextRead(NULL),\n    m_pNextWrite(NULL),\n    m_pEnd(NULL)\n{\n}\n\nCSimpleLoopBufferEx::~CSimpleLoopBufferEx()\n{\n    if (NULL != m_pBuffer)\n    {\n        CGateFactory::Instance()->ReleaseBlock((CBlock*)m_pBuffer);\n        m_pBuffer = NULL;\n        //delete[] m_pBuffer;\n        //m_pBuffer = NULL;\n    }\n}\n\nvoid CSimpleLoopBufferEx::Clear()\n{\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n}\n\nbool CSimpleLoopBufferEx::Init()\n{\n    //m_pBuffer = SDNew char[nSize + 1];\n    CBlock* pBlock = CGateFactory::Instance()->CreateBlock();\n    if (!pBlock)\n        return false;\n\n    m_pBuffer = pBlock->GetBuff();\n    if (NULL == m_pBuffer)\n    {\n        return false;\n    }\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n    //m_pEnd = m_pBuffer + nSize + 1;\n    m_pEnd = m_pBuffer + pBlock->GetBuffLen();\n    return true;\n}\n\nINT32 CSimpleLoopBufferEx::PushBack(const CHAR *pData, INT32 nLen)\n{\n    CHAR* poRead = m_pNextRead;\n    if (m_pNextWrite >= poRead)\n    {\n        //  1、尾部指针减去写起始位置小于 nLen \n        //  2、读的起始位置减去内存首地址 小于nLen\n        //  内存空间不够，不能将数据写入缓存\n        /*                          == 内存模型 ==\n                   (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        if (nLeft + nRight <= nLen)\n        {\n            return -1;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n                                       m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poRead - m_pNextWrite <= nLen)\n        {\n            return -2;\n        }\n    }\n    //     else  //  m_pNextWrite == m_pNextRead\n    //     {\n    //         if (m_pNextWrite > m_pBuffer)\n    //         {\n    //             m_oMutex.Unlock();\n    //             return -3;\n    //         }\n    //     }\n    if (m_pEnd - m_pNextWrite > nLen)\n    {\n        memcpy(m_pNextWrite, pData, nLen);\n        m_pNextWrite += nLen;\n    }\n    else if (m_pEnd - m_pNextWrite == nLen)\n    {\n        memcpy(m_pNextWrite, pData, nLen);\n        m_pNextWrite = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - m_pNextWrite;\n        memcpy(m_pNextWrite, pData, nStartLen);\n        memcpy(m_pBuffer, pData + nStartLen, nLen - nStartLen);\n        m_pNextWrite = m_pBuffer + nLen - nStartLen;\n    }\n    return nLen;\n}\n\nINT32 CSimpleLoopBufferEx::PopFront(CHAR * &pBuf, INT32 nLen, CHAR* szData)\n{\n    CHAR* poNextWrite = m_pNextWrite;\n    if (poNextWrite == m_pNextRead)\n    {\n        EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-1\";\n        return -1;\n    }\n    if (poNextWrite > m_pNextRead)\n    {\n        /*                          == 内存模型 ==\n                   (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poNextWrite - m_pNextRead < nLen)\n        {\n            EXLOG_ERROR << \"PopFront failed! ErrCode:-2\";\n            return -2;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n                                      m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        if (nLeft + nRight < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-3\";\n            return -3;\n        }\n    }\n    if (m_pEnd - m_pNextRead > nLen)\n    {\n        memcpy(szData, m_pNextRead, nLen);\n        m_pNextRead += nLen;\n    }\n    else if (m_pEnd - m_pNextRead == nLen)\n    {\n        memcpy(szData, m_pNextRead, nLen);\n        m_pNextRead = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        memcpy(szData, m_pNextRead, nStartLen);\n        memcpy(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    }\n    return nLen;\n}\n\n\nbool CSimpleLoopBufferEx::DiscardFront(INT32 nLen)\n{\n    CHAR* poNextWrite = m_pNextWrite;\n    if (poNextWrite == m_pNextRead)\n    {\n        EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-1\";\n        return false;\n    }\n    if (poNextWrite > m_pNextRead)\n    {\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poNextWrite - m_pNextRead < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-2\";\n            return false;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        if (nLeft + nRight < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-3\";\n            return false;\n        }\n    }\n    if (m_pEnd - m_pNextRead > nLen)\n    {\n        m_pNextRead += nLen;\n    }\n    else if (m_pEnd - m_pNextRead == nLen)\n    {\n        m_pNextRead = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    }\n\n    return true;\n}\n\nINT32 CSimpleLoopBufferEx::GetFreeSpare()\n{\n    CHAR* poRead = m_pNextRead;\n    if (m_pNextWrite >= poRead)\n    {\n        //  1、尾部指针减去写起始位置小于 nLen \n        //  2、读的起始位置减去内存首地址 小于nLen\n        //  内存空间不够，不能将数据写入缓存\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        return nLeft + nRight;\n\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n\n        return poRead - m_pNextWrite;\n    }\n}\n\nINT32 CSimpleLoopBufferEx::GetData(INT32 nReadOffSet, INT32 nLen, CHAR* szData)\n{\n    //指针偏移\n    CHAR* poNextWrite = m_pNextWrite;\n    if (poNextWrite == m_pNextRead)\n    {\n        EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-1\";\n        return -1;\n    }\n\n    CHAR *pReadOffSet = m_pNextRead + nReadOffSet;\n    if (poNextWrite > m_pNextRead)\n    {\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n\n        if (pReadOffSet >= m_pNextWrite)\n        {\n            EXLOG_ERROR << \"GetData failed! ErrCode:-2\";\n            return -2;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n\n        if (pReadOffSet < m_pEnd)\n        {\n\n        }\n        else if (pReadOffSet == m_pEnd)\n        {\n            pReadOffSet = m_pBuffer;\n            if (pReadOffSet >= m_pNextWrite)\n            {\n                EXLOG_ERROR << \"GetData failed! ErrCode:-3\";\n                return -3;\n            }\n        }\n        else {\n            pReadOffSet = m_pBuffer + nReadOffSet - (m_pEnd - m_pNextRead);\n            if (pReadOffSet >= m_pNextWrite)\n            {\n                EXLOG_ERROR << \"GetData failed! ErrCode:-4\";\n                return -4;\n            }\n        }\n    }\n\n    //拷贝数据\n\n    if (poNextWrite > pReadOffSet)\n    {\n        /*                          == 内存模型 ==\n        (empty)             m_pNextRead         m_pNextWrite       (empty)\n        |----------------------------------|--------------------|---------------------|\n        */\n        if (poNextWrite - pReadOffSet < nLen)\n        {\n            EXLOG_ERROR << \"PopFront failed! ErrCode:-5\";\n            return -5;\n        }\n    }\n    else\n    {\n        /*                          == 内存模型 ==\n        m_pNextWrite (empty) m_pNextRead\n        |----------------------------------|--------------------|---------------------|\n        */\n        INT32 nRight = m_pEnd - pReadOffSet;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        if (nLeft + nRight < nLen)\n        {\n            EXLOG_ERROR << \"[%s:%d]:PopFront failed! ErrCode:-6\";\n            return -6;\n        }\n    }\n    if (m_pEnd - pReadOffSet > nLen)\n    {\n        memcpy(szData, pReadOffSet, nLen);\n        //pReadOffSet += nLen;\n    }\n    else if (m_pEnd - pReadOffSet == nLen)\n    {\n        memcpy(szData, pReadOffSet, nLen);\n        //pReadOffSet = m_pBuffer;\n    }\n    else\n    {\n        INT32 nStartLen = m_pEnd - pReadOffSet;\n        memcpy(szData, pReadOffSet, nStartLen);\n        memcpy(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        //m_pNextRead = m_pBuffer + nLen - nStartLen;\n    }\n\n\n    return nLen;\n\n}\n\n```","slug":"单生产者单消费者环形缓冲","published":1,"updated":"2020-01-23T07:12:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzg2000lokecffzxggh4","content":"<p>头文件</p>\n<pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> _SIMPLE_LOOP_BUFFER_H__</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _SIMPLE_LOOP_BUFFER_H__</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gntype.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnmutex.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnlock.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;server_define.h&quot;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> Storm;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">_tagBlock</span>\n&#123;\n    _tagBlock() \n    &#123;\n        <span class=\"hljs-built_in\">memset</span>(pBuffer, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">char</span>)*(MAX_CACHE_PACKET_SIZE + <span class=\"hljs-number\">1</span>));\n    &#125;\n    ~_tagBlock() &#123;&#125;;\n\n    <span class=\"hljs-type\">char</span>  pBuffer[MAX_CACHE_PACKET_SIZE + <span class=\"hljs-number\">1</span>]; \n    <span class=\"hljs-function\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">GetBuff</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> pBuffer; &#125;\n    <span class=\"hljs-function\">int32 <span class=\"hljs-title\">GetBuffLen</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> MAX_CACHE_PACKET_SIZE + <span class=\"hljs-number\">1</span>; &#125;\n&#125;CBlock;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CSimpleLoopBufferEx</span>\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>();\n    ~<span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>();\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Clear</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 初始化循环缓冲区</span>\n<span class=\"hljs-comment\">    * @param nSize : 初始化虚幻缓冲区的大小，实际大小为nSize+1</span>\n<span class=\"hljs-comment\">    * @return 成功返回true，失败返回false</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 将需要存储的Buffer拷贝到循环缓冲区的结尾</span>\n<span class=\"hljs-comment\">    * @param pData : [输入参数]指向需要插入循环缓冲区的Buffer起始位置</span>\n<span class=\"hljs-comment\">    * @param nLen : 指向需要插入的Buffer的长度</span>\n<span class=\"hljs-comment\">    * @return 如果循环缓冲区拥有的大小大于等于nLen，返回true，否则返回false</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">PushBack</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> CHAR *pData, INT32 nLen)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 从循环缓冲区的起始位置取nLen长度的Buffer，拷贝放入Buffer中</span>\n<span class=\"hljs-comment\">    * @param pBuf : [输入输出参数]获取数据的Buffer的起始指针</span>\n<span class=\"hljs-comment\">    * @param nLen : 需要读出的Buffer长度</span>\n<span class=\"hljs-comment\">    * @return 如果有足够所需读出的数据，返回true，否则返回false</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">PopFront</span><span class=\"hljs-params\">(CHAR * &amp;pBuf, INT32 nLen,CHAR* szData)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 丢弃nLen长度的数据</span>\n<span class=\"hljs-comment\">    * @param nLen : 需要丢弃的长度</span>\n<span class=\"hljs-comment\">    * @return void</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">DiscardFront</span><span class=\"hljs-params\">(INT32 nLen)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 获取剩余可用空间大小</span>\n<span class=\"hljs-comment\">    * @return INT32</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">GetFreeSpare</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 拷贝内存中的数据</span>\n<span class=\"hljs-comment\">    * @param nReadOffSet : m_pNextRead的偏移量</span>\n<span class=\"hljs-comment\">    * @param nLen : 需要读出的Buffer长度</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">GetData</span><span class=\"hljs-params\">(INT32 nReadOffSet,INT32 nLen, CHAR* szData)</span></span>;\n\n\n<span class=\"hljs-keyword\">private</span>:\n    CHAR    *m_pBuffer;\n    CHAR    *m_pNextRead;\n    CHAR    *m_pNextWrite;\n    CHAR    *m_pEnd;\n&#125;;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span></code></pre>\n\n<p>实现</p>\n<pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;simpleloopbuffer.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gndebug.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;../../common/commonloggerex.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gate_factory.h&quot;</span></span>\n\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> Storm;\n\nCSimpleLoopBufferEx::<span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>() :\n    <span class=\"hljs-built_in\">m_pBuffer</span>(<span class=\"hljs-literal\">NULL</span>),\n    <span class=\"hljs-built_in\">m_pNextRead</span>(<span class=\"hljs-literal\">NULL</span>),\n    <span class=\"hljs-built_in\">m_pNextWrite</span>(<span class=\"hljs-literal\">NULL</span>),\n    <span class=\"hljs-built_in\">m_pEnd</span>(<span class=\"hljs-literal\">NULL</span>)\n&#123;\n&#125;\n\nCSimpleLoopBufferEx::~<span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>()\n&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">NULL</span> != m_pBuffer)\n    &#123;\n        CGateFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">ReleaseBlock</span>((CBlock*)m_pBuffer);\n        m_pBuffer = <span class=\"hljs-literal\">NULL</span>;\n        <span class=\"hljs-comment\">//delete[] m_pBuffer;</span>\n        <span class=\"hljs-comment\">//m_pBuffer = NULL;</span>\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CSimpleLoopBufferEx::Clear</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CSimpleLoopBufferEx::Init</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-comment\">//m_pBuffer = SDNew char[nSize + 1];</span>\n    CBlock* pBlock = CGateFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">CreateBlock</span>();\n    <span class=\"hljs-keyword\">if</span> (!pBlock)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\n    m_pBuffer = pBlock-&gt;<span class=\"hljs-built_in\">GetBuff</span>();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">NULL</span> == m_pBuffer)\n    &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    &#125;\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n    <span class=\"hljs-comment\">//m_pEnd = m_pBuffer + nSize + 1;</span>\n    m_pEnd = m_pBuffer + pBlock-&gt;<span class=\"hljs-built_in\">GetBuffLen</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::PushBack</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> CHAR *pData, INT32 nLen)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poRead = m_pNextRead;\n    <span class=\"hljs-keyword\">if</span> (m_pNextWrite &gt;= poRead)\n    &#123;\n        <span class=\"hljs-comment\">//  1、尾部指针减去写起始位置小于 nLen </span>\n        <span class=\"hljs-comment\">//  2、读的起始位置减去内存首地址 小于nLen</span>\n        <span class=\"hljs-comment\">//  内存空间不够，不能将数据写入缓存</span>\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                   (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt;= nLen)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                                       m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poRead - m_pNextWrite &lt;= nLen)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-2</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-comment\">//     else  //  m_pNextWrite == m_pNextRead</span>\n    <span class=\"hljs-comment\">//     &#123;</span>\n    <span class=\"hljs-comment\">//         if (m_pNextWrite &gt; m_pBuffer)</span>\n    <span class=\"hljs-comment\">//         &#123;</span>\n    <span class=\"hljs-comment\">//             m_oMutex.Unlock();</span>\n    <span class=\"hljs-comment\">//             return -3;</span>\n    <span class=\"hljs-comment\">//         &#125;</span>\n    <span class=\"hljs-comment\">//     &#125;</span>\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextWrite &gt; nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(m_pNextWrite, pData, nLen);\n        m_pNextWrite += nLen;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextWrite == nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(m_pNextWrite, pData, nLen);\n        m_pNextWrite = m_pBuffer;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - m_pNextWrite;\n        <span class=\"hljs-built_in\">memcpy</span>(m_pNextWrite, pData, nStartLen);\n        <span class=\"hljs-built_in\">memcpy</span>(m_pBuffer, pData + nStartLen, nLen - nStartLen);\n        m_pNextWrite = m_pBuffer + nLen - nStartLen;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> nLen;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::PopFront</span><span class=\"hljs-params\">(CHAR * &amp;pBuf, INT32 nLen, CHAR* szData)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poNextWrite = m_pNextWrite;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite == m_pNextRead)\n    &#123;\n        EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-1&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; m_pNextRead)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                   (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poNextWrite - m_pNextRead &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;PopFront failed! ErrCode:-2&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-2</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                                      m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-3&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-3</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead &gt; nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, m_pNextRead, nLen);\n        m_pNextRead += nLen;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead == nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, m_pNextRead, nLen);\n        m_pNextRead = m_pBuffer;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, m_pNextRead, nStartLen);\n        <span class=\"hljs-built_in\">memcpy</span>(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> nLen;\n&#125;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CSimpleLoopBufferEx::DiscardFront</span><span class=\"hljs-params\">(INT32 nLen)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poNextWrite = m_pNextWrite;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite == m_pNextRead)\n    &#123;\n        EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-1&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; m_pNextRead)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poNextWrite - m_pNextRead &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-2&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-3&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead &gt; nLen)\n    &#123;\n        m_pNextRead += nLen;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead == nLen)\n    &#123;\n        m_pNextRead = m_pBuffer;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::GetFreeSpare</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poRead = m_pNextRead;\n    <span class=\"hljs-keyword\">if</span> (m_pNextWrite &gt;= poRead)\n    &#123;\n        <span class=\"hljs-comment\">//  1、尾部指针减去写起始位置小于 nLen </span>\n        <span class=\"hljs-comment\">//  2、读的起始位置减去内存首地址 小于nLen</span>\n        <span class=\"hljs-comment\">//  内存空间不够，不能将数据写入缓存</span>\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        <span class=\"hljs-keyword\">return</span> nLeft + nRight;\n\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n\n        <span class=\"hljs-keyword\">return</span> poRead - m_pNextWrite;\n    &#125;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::GetData</span><span class=\"hljs-params\">(INT32 nReadOffSet, INT32 nLen, CHAR* szData)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-comment\">//指针偏移</span>\n    CHAR* poNextWrite = m_pNextWrite;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite == m_pNextRead)\n    &#123;\n        EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-1&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n\n    CHAR *pReadOffSet = m_pNextRead + nReadOffSet;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; m_pNextRead)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n\n        <span class=\"hljs-keyword\">if</span> (pReadOffSet &gt;= m_pNextWrite)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;GetData failed! ErrCode:-2&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-2</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n\n        <span class=\"hljs-keyword\">if</span> (pReadOffSet &lt; m_pEnd)\n        &#123;\n\n        &#125;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pReadOffSet == m_pEnd)\n        &#123;\n            pReadOffSet = m_pBuffer;\n            <span class=\"hljs-keyword\">if</span> (pReadOffSet &gt;= m_pNextWrite)\n            &#123;\n                EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;GetData failed! ErrCode:-3&quot;</span>;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-3</span>;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">else</span> &#123;\n            pReadOffSet = m_pBuffer + nReadOffSet - (m_pEnd - m_pNextRead);\n            <span class=\"hljs-keyword\">if</span> (pReadOffSet &gt;= m_pNextWrite)\n            &#123;\n                EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;GetData failed! ErrCode:-4&quot;</span>;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-4</span>;\n            &#125;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">//拷贝数据</span>\n\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; pReadOffSet)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poNextWrite - pReadOffSet &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;PopFront failed! ErrCode:-5&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-5</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - pReadOffSet;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-6&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-6</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - pReadOffSet &gt; nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, pReadOffSet, nLen);\n        <span class=\"hljs-comment\">//pReadOffSet += nLen;</span>\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - pReadOffSet == nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, pReadOffSet, nLen);\n        <span class=\"hljs-comment\">//pReadOffSet = m_pBuffer;</span>\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - pReadOffSet;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, pReadOffSet, nStartLen);\n        <span class=\"hljs-built_in\">memcpy</span>(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        <span class=\"hljs-comment\">//m_pNextRead = m_pBuffer + nLen - nStartLen;</span>\n    &#125;\n\n\n    <span class=\"hljs-keyword\">return</span> nLen;\n\n&#125;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>头文件</p>\n<pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> _SIMPLE_LOOP_BUFFER_H__</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _SIMPLE_LOOP_BUFFER_H__</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gntype.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnmutex.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gnlock.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;server_define.h&quot;</span></span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> Storm;\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">_tagBlock</span>\n&#123;\n    _tagBlock() \n    &#123;\n        <span class=\"hljs-built_in\">memset</span>(pBuffer, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">char</span>)*(MAX_CACHE_PACKET_SIZE + <span class=\"hljs-number\">1</span>));\n    &#125;\n    ~_tagBlock() &#123;&#125;;\n\n    <span class=\"hljs-type\">char</span>  pBuffer[MAX_CACHE_PACKET_SIZE + <span class=\"hljs-number\">1</span>]; \n    <span class=\"hljs-function\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">GetBuff</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> pBuffer; &#125;\n    <span class=\"hljs-function\">int32 <span class=\"hljs-title\">GetBuffLen</span><span class=\"hljs-params\">()</span> </span>&#123; <span class=\"hljs-keyword\">return</span> MAX_CACHE_PACKET_SIZE + <span class=\"hljs-number\">1</span>; &#125;\n&#125;CBlock;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CSimpleLoopBufferEx</span>\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>();\n    ~<span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>();\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Clear</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 初始化循环缓冲区</span>\n<span class=\"hljs-comment\">    * @param nSize : 初始化虚幻缓冲区的大小，实际大小为nSize+1</span>\n<span class=\"hljs-comment\">    * @return 成功返回true，失败返回false</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">Init</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 将需要存储的Buffer拷贝到循环缓冲区的结尾</span>\n<span class=\"hljs-comment\">    * @param pData : [输入参数]指向需要插入循环缓冲区的Buffer起始位置</span>\n<span class=\"hljs-comment\">    * @param nLen : 指向需要插入的Buffer的长度</span>\n<span class=\"hljs-comment\">    * @return 如果循环缓冲区拥有的大小大于等于nLen，返回true，否则返回false</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">PushBack</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> CHAR *pData, INT32 nLen)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 从循环缓冲区的起始位置取nLen长度的Buffer，拷贝放入Buffer中</span>\n<span class=\"hljs-comment\">    * @param pBuf : [输入输出参数]获取数据的Buffer的起始指针</span>\n<span class=\"hljs-comment\">    * @param nLen : 需要读出的Buffer长度</span>\n<span class=\"hljs-comment\">    * @return 如果有足够所需读出的数据，返回true，否则返回false</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">PopFront</span><span class=\"hljs-params\">(CHAR * &amp;pBuf, INT32 nLen,CHAR* szData)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 丢弃nLen长度的数据</span>\n<span class=\"hljs-comment\">    * @param nLen : 需要丢弃的长度</span>\n<span class=\"hljs-comment\">    * @return void</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">DiscardFront</span><span class=\"hljs-params\">(INT32 nLen)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 获取剩余可用空间大小</span>\n<span class=\"hljs-comment\">    * @return INT32</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">GetFreeSpare</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief</span>\n<span class=\"hljs-comment\">    * 拷贝内存中的数据</span>\n<span class=\"hljs-comment\">    * @param nReadOffSet : m_pNextRead的偏移量</span>\n<span class=\"hljs-comment\">    * @param nLen : 需要读出的Buffer长度</span>\n<span class=\"hljs-comment\">    * @remark 此函数不是线程安全的</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\">INT32 <span class=\"hljs-title\">GetData</span><span class=\"hljs-params\">(INT32 nReadOffSet,INT32 nLen, CHAR* szData)</span></span>;\n\n\n<span class=\"hljs-keyword\">private</span>:\n    CHAR    *m_pBuffer;\n    CHAR    *m_pNextRead;\n    CHAR    *m_pNextWrite;\n    CHAR    *m_pEnd;\n&#125;;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span></code></pre>\n\n<p>实现</p>\n<pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;simpleloopbuffer.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gndebug.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;../../common/commonloggerex.h&quot;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gate_factory.h&quot;</span></span>\n\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> Storm;\n\nCSimpleLoopBufferEx::<span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>() :\n    <span class=\"hljs-built_in\">m_pBuffer</span>(<span class=\"hljs-literal\">NULL</span>),\n    <span class=\"hljs-built_in\">m_pNextRead</span>(<span class=\"hljs-literal\">NULL</span>),\n    <span class=\"hljs-built_in\">m_pNextWrite</span>(<span class=\"hljs-literal\">NULL</span>),\n    <span class=\"hljs-built_in\">m_pEnd</span>(<span class=\"hljs-literal\">NULL</span>)\n&#123;\n&#125;\n\nCSimpleLoopBufferEx::~<span class=\"hljs-built_in\">CSimpleLoopBufferEx</span>()\n&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">NULL</span> != m_pBuffer)\n    &#123;\n        CGateFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">ReleaseBlock</span>((CBlock*)m_pBuffer);\n        m_pBuffer = <span class=\"hljs-literal\">NULL</span>;\n        <span class=\"hljs-comment\">//delete[] m_pBuffer;</span>\n        <span class=\"hljs-comment\">//m_pBuffer = NULL;</span>\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CSimpleLoopBufferEx::Clear</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CSimpleLoopBufferEx::Init</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-comment\">//m_pBuffer = SDNew char[nSize + 1];</span>\n    CBlock* pBlock = CGateFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">CreateBlock</span>();\n    <span class=\"hljs-keyword\">if</span> (!pBlock)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n\n    m_pBuffer = pBlock-&gt;<span class=\"hljs-built_in\">GetBuff</span>();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">NULL</span> == m_pBuffer)\n    &#123;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    &#125;\n    m_pNextRead = m_pBuffer;\n    m_pNextWrite = m_pBuffer;\n    <span class=\"hljs-comment\">//m_pEnd = m_pBuffer + nSize + 1;</span>\n    m_pEnd = m_pBuffer + pBlock-&gt;<span class=\"hljs-built_in\">GetBuffLen</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::PushBack</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> CHAR *pData, INT32 nLen)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poRead = m_pNextRead;\n    <span class=\"hljs-keyword\">if</span> (m_pNextWrite &gt;= poRead)\n    &#123;\n        <span class=\"hljs-comment\">//  1、尾部指针减去写起始位置小于 nLen </span>\n        <span class=\"hljs-comment\">//  2、读的起始位置减去内存首地址 小于nLen</span>\n        <span class=\"hljs-comment\">//  内存空间不够，不能将数据写入缓存</span>\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                   (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt;= nLen)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                                       m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poRead - m_pNextWrite &lt;= nLen)\n        &#123;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-2</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-comment\">//     else  //  m_pNextWrite == m_pNextRead</span>\n    <span class=\"hljs-comment\">//     &#123;</span>\n    <span class=\"hljs-comment\">//         if (m_pNextWrite &gt; m_pBuffer)</span>\n    <span class=\"hljs-comment\">//         &#123;</span>\n    <span class=\"hljs-comment\">//             m_oMutex.Unlock();</span>\n    <span class=\"hljs-comment\">//             return -3;</span>\n    <span class=\"hljs-comment\">//         &#125;</span>\n    <span class=\"hljs-comment\">//     &#125;</span>\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextWrite &gt; nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(m_pNextWrite, pData, nLen);\n        m_pNextWrite += nLen;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextWrite == nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(m_pNextWrite, pData, nLen);\n        m_pNextWrite = m_pBuffer;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - m_pNextWrite;\n        <span class=\"hljs-built_in\">memcpy</span>(m_pNextWrite, pData, nStartLen);\n        <span class=\"hljs-built_in\">memcpy</span>(m_pBuffer, pData + nStartLen, nLen - nStartLen);\n        m_pNextWrite = m_pBuffer + nLen - nStartLen;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> nLen;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::PopFront</span><span class=\"hljs-params\">(CHAR * &amp;pBuf, INT32 nLen, CHAR* szData)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poNextWrite = m_pNextWrite;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite == m_pNextRead)\n    &#123;\n        EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-1&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; m_pNextRead)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                   (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poNextWrite - m_pNextRead &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;PopFront failed! ErrCode:-2&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-2</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">                                      m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-3&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-3</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead &gt; nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, m_pNextRead, nLen);\n        m_pNextRead += nLen;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead == nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, m_pNextRead, nLen);\n        m_pNextRead = m_pBuffer;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, m_pNextRead, nStartLen);\n        <span class=\"hljs-built_in\">memcpy</span>(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    &#125;\n    <span class=\"hljs-keyword\">return</span> nLen;\n&#125;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">CSimpleLoopBufferEx::DiscardFront</span><span class=\"hljs-params\">(INT32 nLen)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poNextWrite = m_pNextWrite;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite == m_pNextRead)\n    &#123;\n        EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-1&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; m_pNextRead)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poNextWrite - m_pNextRead &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-2&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextRead;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-3&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead &gt; nLen)\n    &#123;\n        m_pNextRead += nLen;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - m_pNextRead == nLen)\n    &#123;\n        m_pNextRead = m_pBuffer;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - m_pNextRead;\n        m_pNextRead = m_pBuffer + nLen - nStartLen;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::GetFreeSpare</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CHAR* poRead = m_pNextRead;\n    <span class=\"hljs-keyword\">if</span> (m_pNextWrite &gt;= poRead)\n    &#123;\n        <span class=\"hljs-comment\">//  1、尾部指针减去写起始位置小于 nLen </span>\n        <span class=\"hljs-comment\">//  2、读的起始位置减去内存首地址 小于nLen</span>\n        <span class=\"hljs-comment\">//  内存空间不够，不能将数据写入缓存</span>\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - m_pNextWrite;\n        INT32 nLeft = poRead - m_pBuffer;\n        <span class=\"hljs-keyword\">return</span> nLeft + nRight;\n\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n\n        <span class=\"hljs-keyword\">return</span> poRead - m_pNextWrite;\n    &#125;\n&#125;\n\n<span class=\"hljs-function\">INT32 <span class=\"hljs-title\">CSimpleLoopBufferEx::GetData</span><span class=\"hljs-params\">(INT32 nReadOffSet, INT32 nLen, CHAR* szData)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-comment\">//指针偏移</span>\n    CHAR* poNextWrite = m_pNextWrite;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite == m_pNextRead)\n    &#123;\n        EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-1&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    &#125;\n\n    CHAR *pReadOffSet = m_pNextRead + nReadOffSet;\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; m_pNextRead)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n\n        <span class=\"hljs-keyword\">if</span> (pReadOffSet &gt;= m_pNextWrite)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;GetData failed! ErrCode:-2&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-2</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n\n        <span class=\"hljs-keyword\">if</span> (pReadOffSet &lt; m_pEnd)\n        &#123;\n\n        &#125;\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pReadOffSet == m_pEnd)\n        &#123;\n            pReadOffSet = m_pBuffer;\n            <span class=\"hljs-keyword\">if</span> (pReadOffSet &gt;= m_pNextWrite)\n            &#123;\n                EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;GetData failed! ErrCode:-3&quot;</span>;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-3</span>;\n            &#125;\n        &#125;\n        <span class=\"hljs-keyword\">else</span> &#123;\n            pReadOffSet = m_pBuffer + nReadOffSet - (m_pEnd - m_pNextRead);\n            <span class=\"hljs-keyword\">if</span> (pReadOffSet &gt;= m_pNextWrite)\n            &#123;\n                EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;GetData failed! ErrCode:-4&quot;</span>;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-4</span>;\n            &#125;\n        &#125;\n    &#125;\n\n    <span class=\"hljs-comment\">//拷贝数据</span>\n\n    <span class=\"hljs-keyword\">if</span> (poNextWrite &gt; pReadOffSet)\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        (empty)             m_pNextRead         m_pNextWrite       (empty)</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        <span class=\"hljs-keyword\">if</span> (poNextWrite - pReadOffSet &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;PopFront failed! ErrCode:-5&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-5</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-comment\">/*                          == 内存模型 ==</span>\n<span class=\"hljs-comment\">        m_pNextWrite (empty) m_pNextRead</span>\n<span class=\"hljs-comment\">        |----------------------------------|--------------------|---------------------|</span>\n<span class=\"hljs-comment\">        */</span>\n        INT32 nRight = m_pEnd - pReadOffSet;\n        INT32 nLeft = poNextWrite - m_pBuffer;\n        <span class=\"hljs-keyword\">if</span> (nLeft + nRight &lt; nLen)\n        &#123;\n            EXLOG_ERROR &lt;&lt; <span class=\"hljs-string\">&quot;[%s:%d]:PopFront failed! ErrCode:-6&quot;</span>;\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-6</span>;\n        &#125;\n    &#125;\n    <span class=\"hljs-keyword\">if</span> (m_pEnd - pReadOffSet &gt; nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, pReadOffSet, nLen);\n        <span class=\"hljs-comment\">//pReadOffSet += nLen;</span>\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (m_pEnd - pReadOffSet == nLen)\n    &#123;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, pReadOffSet, nLen);\n        <span class=\"hljs-comment\">//pReadOffSet = m_pBuffer;</span>\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        INT32 nStartLen = m_pEnd - pReadOffSet;\n        <span class=\"hljs-built_in\">memcpy</span>(szData, pReadOffSet, nStartLen);\n        <span class=\"hljs-built_in\">memcpy</span>(szData + nStartLen, m_pBuffer, nLen - nStartLen);\n        <span class=\"hljs-comment\">//m_pNextRead = m_pBuffer + nLen - nStartLen;</span>\n    &#125;\n\n\n    <span class=\"hljs-keyword\">return</span> nLen;\n\n&#125;\n</code></pre>"},{"title":"各类APP排行榜实现","date":"2020-01-23T07:12:45.000Z","_content":"\n## 需求背景\n1. 查看TopN的用户排名\n2. 查看自己的排名\n3. 用户积分变更后，排名及时更新\n\n## 实现方案\n### 方案一 利用MYSQL 排序\n利用MySQL来实现，存放一张用户积分表user_score\n取前top N，自己的排名都可以通过简单的sql语句搞定。\n算法简单，利用sql的功能，不需要其他复杂逻辑，对于数据量比较少、性能要求不高，可以使用。但是对于海量数据，性能是无法接受的。可能会导致全局锁表之类的问题。\n\n### 方案二 内存数组排序\n在内存中预分配所要排名用户大小的数组，所有的积分排名变更基于此移动元素，成熟排序算法有最小/大堆、快速排序等，这种方案优点是当数据量小的时候，简单快捷，容易实现，不需要其他任何组件支持，但是当面对海量数据的时候数组空间占用可能不太现实\n\n### 方案三 利用GCC库支持\n具体的，用GCC的pb_ds库中有assoc_container来进行实现。\n参考[tree_order_statistics.cc](https://opensource.apple.com/source/llvmgcc42/llvmgcc42-2336.9/libstdc++-v3/testsuite/ext/pb_ds/example/tree_order_statistics.cc)：\n```cpp\n#include <cassert>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace pb_ds;\nusing namespace pb_ds;\n\n// A red-black tree table storing ints and their order\n// statistics. Note that since the tree uses\n// tree_order_statistics_node_update as its update policy, then it\n// includes its methods by_order and order_of_key.\ntypedef\ntree<\n  int,\n  null_mapped_type,\n  less<int>,\n  rb_tree_tag,\n  // This policy updates nodes' metadata for order statistics.\n  tree_order_statistics_node_update>\nset_t;\n\nint main()\n{\n  // Insert some entries into s.\n  set_t s;\n  s.insert(12);\n  s.insert(505);\n  s.insert(30);\n  s.insert(1000);\n  s.insert(10000);\n  s.insert(100);\n\n  // The order of the keys should be: 12, 30, 100, 505, 1000, 10000.\n  assert(*s.find_by_order(0) == 12);\n  assert(*s.find_by_order(1) == 30);\n  assert(*s.find_by_order(2) == 100);\n  assert(*s.find_by_order(3) == 505);\n  assert(*s.find_by_order(4) == 1000);\n  assert(*s.find_by_order(5) == 10000);\n  assert(s.find_by_order(6) == s.end());\n\n  // The order of the keys should be: 12, 30, 100, 505, 1000, 10000.\n  assert(s.order_of_key(10) == 0);\n  assert(s.order_of_key(12) == 0);\n  assert(s.order_of_key(15) == 1);\n  assert(s.order_of_key(30) == 1);\n  assert(s.order_of_key(99) == 2);\n  assert(s.order_of_key(100) == 2);\n  assert(s.order_of_key(505) == 3);\n  assert(s.order_of_key(1000) == 4);\n  assert(s.order_of_key(10000) == 5);\n  assert(s.order_of_key(9999999) == 6);\n\n  // Erase an entry.\n  s.erase(30);\n\n  // The order of the keys should be: 12, 100, 505, 1000, 10000.\n  assert(*s.find_by_order(0) == 12);\n  assert(*s.find_by_order(1) == 100);\n  assert(*s.find_by_order(2) == 505);\n  assert(*s.find_by_order(3) == 1000);\n  assert(*s.find_by_order(4) == 10000);\n  assert(s.find_by_order(5) == s.end());\n\n  // The order of the keys should be: 12, 100, 505, 1000, 10000.\n  assert(s.order_of_key(10) == 0);\n  assert(s.order_of_key(12) == 0);\n  assert(s.order_of_key(100) == 1);\n  assert(s.order_of_key(505) == 2);\n  assert(s.order_of_key(707) == 3);\n  assert(s.order_of_key(1000) == 3);\n  assert(s.order_of_key(1001) == 4);\n  assert(s.order_of_key(10000) == 4);\n  assert(s.order_of_key(100000) == 5);\n  assert(s.order_of_key(9999999) == 5);\n\n  return 0;\n}\n```\n存取效率都可以达到O(log(n))，不足就是程序重启后数据会丢失。还是对所有的用户积分，没必要。\n而且是有依赖，不方便扩展，实现不了复杂的需求，\n\n### 方案四 实现排序树\n\n大致实现思路如下：\n\n\n　　我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量，非叶子结点的count值总是等于其左右子结点的count值之和。\n\n\n　　以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！\n\n\n　　虽然，本算法的更新和查询都涉及到若干个操作，但如果我们为区间的from_score和to_score建立索引，这些操作都是基于键的查询和更新，不会产生表扫描，因此效率更高。另外，本算法并不依赖于关系数据模型和SQL运算，可以轻易地改造为NoSQL等其他存储方式，而基于键的操作也很容易引入缓存机制进一步优化性能。进一步，我们可以估算一下树形区间的数目大约为2,000,000，考虑每个结点的大小，整个结构只占用几十M空间。所以，我们完全可以在内存建立区间树结构，并通过user_score表在O(n)的时间内初始化区间树，然后排名的查询和更新操作都可以在内存进行。一般来讲，同样的算法，从数据库到内存算法的性能提升常常可以达到10^5以上；因此，本算法可以达到非常高的性能。\n\n\n　　算法特点\n\n\n　　优点：结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；不依赖于SQL，容易改造为NoSQL或内存数据结构。\n\n\n　　缺点：算法相对更复杂。\n\n### 方案五 实现跳表排序\n\nskip list是链表的一种特殊形式，对链表的一种优化；保证INSERT和REMOVE操作是O(logn)，而通用链表的复杂度为O(n);\n优点：实现较简单，效率基本上O(log(N))\n缺点：当达到亿级别时的数据时，性能会急剧下降\n\n### 方案六 利用redis特新实现\n其实redis底层还是使用跳表实现排序的，只是将接口都封装好了，使用接口也比较完善，稳定。\n\nredis的zset天生是用来做排行榜的、好友列表, 去重, 历史记录等业务需求。接口使用非常简单。接口非常丰富，基本上需要的实现都能满足，说明如下：\n\nZAdd/ZRem是O(log(N))，ZRangeByScore/ZRemRangeByScore是O(log(N)+M)，N是Set大小，M是结果/操作元素的个数。\n\nZSET的实现用到了两个数据结构：hash table 和 skip list(跳跃表)，其中hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) ，而skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。\n\n优点：基于redis开发，速度快；使用redis相关特性\n\n缺点：当达到亿级别时的数据时，性能会急剧下降\n\n来实现排行榜的方法很多，可以根据自己的具体需求，参考选用。\n\n## 方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算\n\n基于此，假设我们游戏内只需要排前100名，这里我们只需要维护一个100大小的数组\n1. 当元素A需要参与排序的时候，与数组中最小的积分进行比较，如果能进100名，那么将第100剔除，将A加入，并记录最小元素，这样就完成了积分上涨的情况\n2. 还有一种就是已经在前100名中元素的积分发生变化下降，那么需要在前100名后找出可以进排行榜的元素，这种情况比较麻烦，可以使用最大堆保存剩下所有用户的数据，当需要找出能替换进入排行榜的元素就非常快logn，选择特定数据结构非常重要\n3. 既然大于N的用户不需要精确排名，那么怎么样估算大概排名呢？一般做法是按照数值区间建立所若干个桶，比如我们预计要排名的那一个数据的最大值能到1W。我建立0-10， 10-100，100-1000， 1000-2000， 2000-5000， 5000-10000 这样6个桶，每个桶里面记录分值在这个桶对应的区间内，有多少个玩家。 比如\n0-10， 10人\n10-100，20人\n100-1000，30人\n1000-2000， 40人\n2000-5000， 50人\n5000-10000， 60人\n那么如果一个玩家 是 1234分，那么他的排名就超过了 （10 + 20 + 30）/ （10 + 20 + 30 + 40 + 50 + 60）这个百分比的玩家（所以桶分的越细，后面的排名越精确）\n实质就是按照分区间记录区间内元素个数，从而估算大概排名，因此数值区间越小，估算约精确。\n\n\n","source":"_posts/各类APP排行榜实现.md","raw":"---\ntitle: 各类APP排行榜实现\ndate: 2020-01-23 15:12:45\ntags: rank\ncategories: Game\n---\n\n## 需求背景\n1. 查看TopN的用户排名\n2. 查看自己的排名\n3. 用户积分变更后，排名及时更新\n\n## 实现方案\n### 方案一 利用MYSQL 排序\n利用MySQL来实现，存放一张用户积分表user_score\n取前top N，自己的排名都可以通过简单的sql语句搞定。\n算法简单，利用sql的功能，不需要其他复杂逻辑，对于数据量比较少、性能要求不高，可以使用。但是对于海量数据，性能是无法接受的。可能会导致全局锁表之类的问题。\n\n### 方案二 内存数组排序\n在内存中预分配所要排名用户大小的数组，所有的积分排名变更基于此移动元素，成熟排序算法有最小/大堆、快速排序等，这种方案优点是当数据量小的时候，简单快捷，容易实现，不需要其他任何组件支持，但是当面对海量数据的时候数组空间占用可能不太现实\n\n### 方案三 利用GCC库支持\n具体的，用GCC的pb_ds库中有assoc_container来进行实现。\n参考[tree_order_statistics.cc](https://opensource.apple.com/source/llvmgcc42/llvmgcc42-2336.9/libstdc++-v3/testsuite/ext/pb_ds/example/tree_order_statistics.cc)：\n```cpp\n#include <cassert>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace pb_ds;\nusing namespace pb_ds;\n\n// A red-black tree table storing ints and their order\n// statistics. Note that since the tree uses\n// tree_order_statistics_node_update as its update policy, then it\n// includes its methods by_order and order_of_key.\ntypedef\ntree<\n  int,\n  null_mapped_type,\n  less<int>,\n  rb_tree_tag,\n  // This policy updates nodes' metadata for order statistics.\n  tree_order_statistics_node_update>\nset_t;\n\nint main()\n{\n  // Insert some entries into s.\n  set_t s;\n  s.insert(12);\n  s.insert(505);\n  s.insert(30);\n  s.insert(1000);\n  s.insert(10000);\n  s.insert(100);\n\n  // The order of the keys should be: 12, 30, 100, 505, 1000, 10000.\n  assert(*s.find_by_order(0) == 12);\n  assert(*s.find_by_order(1) == 30);\n  assert(*s.find_by_order(2) == 100);\n  assert(*s.find_by_order(3) == 505);\n  assert(*s.find_by_order(4) == 1000);\n  assert(*s.find_by_order(5) == 10000);\n  assert(s.find_by_order(6) == s.end());\n\n  // The order of the keys should be: 12, 30, 100, 505, 1000, 10000.\n  assert(s.order_of_key(10) == 0);\n  assert(s.order_of_key(12) == 0);\n  assert(s.order_of_key(15) == 1);\n  assert(s.order_of_key(30) == 1);\n  assert(s.order_of_key(99) == 2);\n  assert(s.order_of_key(100) == 2);\n  assert(s.order_of_key(505) == 3);\n  assert(s.order_of_key(1000) == 4);\n  assert(s.order_of_key(10000) == 5);\n  assert(s.order_of_key(9999999) == 6);\n\n  // Erase an entry.\n  s.erase(30);\n\n  // The order of the keys should be: 12, 100, 505, 1000, 10000.\n  assert(*s.find_by_order(0) == 12);\n  assert(*s.find_by_order(1) == 100);\n  assert(*s.find_by_order(2) == 505);\n  assert(*s.find_by_order(3) == 1000);\n  assert(*s.find_by_order(4) == 10000);\n  assert(s.find_by_order(5) == s.end());\n\n  // The order of the keys should be: 12, 100, 505, 1000, 10000.\n  assert(s.order_of_key(10) == 0);\n  assert(s.order_of_key(12) == 0);\n  assert(s.order_of_key(100) == 1);\n  assert(s.order_of_key(505) == 2);\n  assert(s.order_of_key(707) == 3);\n  assert(s.order_of_key(1000) == 3);\n  assert(s.order_of_key(1001) == 4);\n  assert(s.order_of_key(10000) == 4);\n  assert(s.order_of_key(100000) == 5);\n  assert(s.order_of_key(9999999) == 5);\n\n  return 0;\n}\n```\n存取效率都可以达到O(log(n))，不足就是程序重启后数据会丢失。还是对所有的用户积分，没必要。\n而且是有依赖，不方便扩展，实现不了复杂的需求，\n\n### 方案四 实现排序树\n\n大致实现思路如下：\n\n\n　　我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量，非叶子结点的count值总是等于其左右子结点的count值之和。\n\n\n　　以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！\n\n\n　　虽然，本算法的更新和查询都涉及到若干个操作，但如果我们为区间的from_score和to_score建立索引，这些操作都是基于键的查询和更新，不会产生表扫描，因此效率更高。另外，本算法并不依赖于关系数据模型和SQL运算，可以轻易地改造为NoSQL等其他存储方式，而基于键的操作也很容易引入缓存机制进一步优化性能。进一步，我们可以估算一下树形区间的数目大约为2,000,000，考虑每个结点的大小，整个结构只占用几十M空间。所以，我们完全可以在内存建立区间树结构，并通过user_score表在O(n)的时间内初始化区间树，然后排名的查询和更新操作都可以在内存进行。一般来讲，同样的算法，从数据库到内存算法的性能提升常常可以达到10^5以上；因此，本算法可以达到非常高的性能。\n\n\n　　算法特点\n\n\n　　优点：结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；不依赖于SQL，容易改造为NoSQL或内存数据结构。\n\n\n　　缺点：算法相对更复杂。\n\n### 方案五 实现跳表排序\n\nskip list是链表的一种特殊形式，对链表的一种优化；保证INSERT和REMOVE操作是O(logn)，而通用链表的复杂度为O(n);\n优点：实现较简单，效率基本上O(log(N))\n缺点：当达到亿级别时的数据时，性能会急剧下降\n\n### 方案六 利用redis特新实现\n其实redis底层还是使用跳表实现排序的，只是将接口都封装好了，使用接口也比较完善，稳定。\n\nredis的zset天生是用来做排行榜的、好友列表, 去重, 历史记录等业务需求。接口使用非常简单。接口非常丰富，基本上需要的实现都能满足，说明如下：\n\nZAdd/ZRem是O(log(N))，ZRangeByScore/ZRemRangeByScore是O(log(N)+M)，N是Set大小，M是结果/操作元素的个数。\n\nZSET的实现用到了两个数据结构：hash table 和 skip list(跳跃表)，其中hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) ，而skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。\n\n优点：基于redis开发，速度快；使用redis相关特性\n\n缺点：当达到亿级别时的数据时，性能会急剧下降\n\n来实现排行榜的方法很多，可以根据自己的具体需求，参考选用。\n\n## 方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算\n\n基于此，假设我们游戏内只需要排前100名，这里我们只需要维护一个100大小的数组\n1. 当元素A需要参与排序的时候，与数组中最小的积分进行比较，如果能进100名，那么将第100剔除，将A加入，并记录最小元素，这样就完成了积分上涨的情况\n2. 还有一种就是已经在前100名中元素的积分发生变化下降，那么需要在前100名后找出可以进排行榜的元素，这种情况比较麻烦，可以使用最大堆保存剩下所有用户的数据，当需要找出能替换进入排行榜的元素就非常快logn，选择特定数据结构非常重要\n3. 既然大于N的用户不需要精确排名，那么怎么样估算大概排名呢？一般做法是按照数值区间建立所若干个桶，比如我们预计要排名的那一个数据的最大值能到1W。我建立0-10， 10-100，100-1000， 1000-2000， 2000-5000， 5000-10000 这样6个桶，每个桶里面记录分值在这个桶对应的区间内，有多少个玩家。 比如\n0-10， 10人\n10-100，20人\n100-1000，30人\n1000-2000， 40人\n2000-5000， 50人\n5000-10000， 60人\n那么如果一个玩家 是 1234分，那么他的排名就超过了 （10 + 20 + 30）/ （10 + 20 + 30 + 40 + 50 + 60）这个百分比的玩家（所以桶分的越细，后面的排名越精确）\n实质就是按照分区间记录区间内元素个数，从而估算大概排名，因此数值区间越小，估算约精确。\n\n\n","slug":"各类APP排行榜实现","published":1,"updated":"2020-01-23T07:12:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzg3000nokecboy52m0y","content":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h2><ol>\n<li>查看TopN的用户排名</li>\n<li>查看自己的排名</li>\n<li>用户积分变更后，排名及时更新</li>\n</ol>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"方案一-利用MYSQL-排序\"><a href=\"#方案一-利用MYSQL-排序\" class=\"headerlink\" title=\"方案一 利用MYSQL 排序\"></a>方案一 利用MYSQL 排序</h3><p>利用MySQL来实现，存放一张用户积分表user_score<br>取前top N，自己的排名都可以通过简单的sql语句搞定。<br>算法简单，利用sql的功能，不需要其他复杂逻辑，对于数据量比较少、性能要求不高，可以使用。但是对于海量数据，性能是无法接受的。可能会导致全局锁表之类的问题。</p>\n<h3 id=\"方案二-内存数组排序\"><a href=\"#方案二-内存数组排序\" class=\"headerlink\" title=\"方案二 内存数组排序\"></a>方案二 内存数组排序</h3><p>在内存中预分配所要排名用户大小的数组，所有的积分排名变更基于此移动元素，成熟排序算法有最小&#x2F;大堆、快速排序等，这种方案优点是当数据量小的时候，简单快捷，容易实现，不需要其他任何组件支持，但是当面对海量数据的时候数组空间占用可能不太现实</p>\n<h3 id=\"方案三-利用GCC库支持\"><a href=\"#方案三-利用GCC库支持\" class=\"headerlink\" title=\"方案三 利用GCC库支持\"></a>方案三 利用GCC库支持</h3><p>具体的，用GCC的pb_ds库中有assoc_container来进行实现。<br>参考<a href=\"https://opensource.apple.com/source/llvmgcc42/llvmgcc42-2336.9/libstdc++-v3/testsuite/ext/pb_ds/example/tree_order_statistics.cc\">tree_order_statistics.cc</a>：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> pb_ds;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> pb_ds;\n\n<span class=\"hljs-comment\">// A red-black tree table storing ints and their order</span>\n<span class=\"hljs-comment\">// statistics. Note that since the tree uses</span>\n<span class=\"hljs-comment\">// tree_order_statistics_node_update as its update policy, then it</span>\n<span class=\"hljs-comment\">// includes its methods by_order and order_of_key.</span>\n<span class=\"hljs-keyword\">typedef</span>\ntree&lt;\n  <span class=\"hljs-type\">int</span>,\n  null_mapped_type,\n  less&lt;<span class=\"hljs-type\">int</span>&gt;,\n  rb_tree_tag,\n  <span class=\"hljs-comment\">// This policy updates nodes&#x27; metadata for order statistics.</span>\n  tree_order_statistics_node_update&gt;\n<span class=\"hljs-type\">set_t</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n  <span class=\"hljs-comment\">// Insert some entries into s.</span>\n  <span class=\"hljs-type\">set_t</span> s;\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">12</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">505</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">30</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">1000</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">10000</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">100</span>);\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 30, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">12</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">30</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">100</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">3</span>) == <span class=\"hljs-number\">505</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">5</span>) == <span class=\"hljs-number\">10000</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">6</span>) == s.<span class=\"hljs-built_in\">end</span>());\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 30, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">12</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">15</span>) == <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">30</span>) == <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">99</span>) == <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">100</span>) == <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">505</span>) == <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">1000</span>) == <span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10000</span>) == <span class=\"hljs-number\">5</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">9999999</span>) == <span class=\"hljs-number\">6</span>);\n\n  <span class=\"hljs-comment\">// Erase an entry.</span>\n  s.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">30</span>);\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">12</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">100</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">505</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">3</span>) == <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">10000</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">5</span>) == s.<span class=\"hljs-built_in\">end</span>());\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">12</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">100</span>) == <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">505</span>) == <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">707</span>) == <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">1000</span>) == <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">1001</span>) == <span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10000</span>) == <span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">100000</span>) == <span class=\"hljs-number\">5</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">9999999</span>) == <span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n&#125;</code></pre>\n<p>存取效率都可以达到O(log(n))，不足就是程序重启后数据会丢失。还是对所有的用户积分，没必要。<br>而且是有依赖，不方便扩展，实现不了复杂的需求，</p>\n<h3 id=\"方案四-实现排序树\"><a href=\"#方案四-实现排序树\" class=\"headerlink\" title=\"方案四 实现排序树\"></a>方案四 实现排序树</h3><p>大致实现思路如下：</p>\n<p>　　我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量，非叶子结点的count值总是等于其左右子结点的count值之和。</p>\n<p>　　以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！</p>\n<p>　　虽然，本算法的更新和查询都涉及到若干个操作，但如果我们为区间的from_score和to_score建立索引，这些操作都是基于键的查询和更新，不会产生表扫描，因此效率更高。另外，本算法并不依赖于关系数据模型和SQL运算，可以轻易地改造为NoSQL等其他存储方式，而基于键的操作也很容易引入缓存机制进一步优化性能。进一步，我们可以估算一下树形区间的数目大约为2,000,000，考虑每个结点的大小，整个结构只占用几十M空间。所以，我们完全可以在内存建立区间树结构，并通过user_score表在O(n)的时间内初始化区间树，然后排名的查询和更新操作都可以在内存进行。一般来讲，同样的算法，从数据库到内存算法的性能提升常常可以达到10^5以上；因此，本算法可以达到非常高的性能。</p>\n<p>　　算法特点</p>\n<p>　　优点：结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；不依赖于SQL，容易改造为NoSQL或内存数据结构。</p>\n<p>　　缺点：算法相对更复杂。</p>\n<h3 id=\"方案五-实现跳表排序\"><a href=\"#方案五-实现跳表排序\" class=\"headerlink\" title=\"方案五 实现跳表排序\"></a>方案五 实现跳表排序</h3><p>skip list是链表的一种特殊形式，对链表的一种优化；保证INSERT和REMOVE操作是O(logn)，而通用链表的复杂度为O(n);<br>优点：实现较简单，效率基本上O(log(N))<br>缺点：当达到亿级别时的数据时，性能会急剧下降</p>\n<h3 id=\"方案六-利用redis特新实现\"><a href=\"#方案六-利用redis特新实现\" class=\"headerlink\" title=\"方案六 利用redis特新实现\"></a>方案六 利用redis特新实现</h3><p>其实redis底层还是使用跳表实现排序的，只是将接口都封装好了，使用接口也比较完善，稳定。</p>\n<p>redis的zset天生是用来做排行榜的、好友列表, 去重, 历史记录等业务需求。接口使用非常简单。接口非常丰富，基本上需要的实现都能满足，说明如下：</p>\n<p>ZAdd&#x2F;ZRem是O(log(N))，ZRangeByScore&#x2F;ZRemRangeByScore是O(log(N)+M)，N是Set大小，M是结果&#x2F;操作元素的个数。</p>\n<p>ZSET的实现用到了两个数据结构：hash table 和 skip list(跳跃表)，其中hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) ，而skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。</p>\n<p>优点：基于redis开发，速度快；使用redis相关特性</p>\n<p>缺点：当达到亿级别时的数据时，性能会急剧下降</p>\n<p>来实现排行榜的方法很多，可以根据自己的具体需求，参考选用。</p>\n<h2 id=\"方案七-其实只需要TopN的排名，大于N的排名并不需要精确排名计算\"><a href=\"#方案七-其实只需要TopN的排名，大于N的排名并不需要精确排名计算\" class=\"headerlink\" title=\"方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算\"></a>方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算</h2><p>基于此，假设我们游戏内只需要排前100名，这里我们只需要维护一个100大小的数组</p>\n<ol>\n<li>当元素A需要参与排序的时候，与数组中最小的积分进行比较，如果能进100名，那么将第100剔除，将A加入，并记录最小元素，这样就完成了积分上涨的情况</li>\n<li>还有一种就是已经在前100名中元素的积分发生变化下降，那么需要在前100名后找出可以进排行榜的元素，这种情况比较麻烦，可以使用最大堆保存剩下所有用户的数据，当需要找出能替换进入排行榜的元素就非常快logn，选择特定数据结构非常重要</li>\n<li>既然大于N的用户不需要精确排名，那么怎么样估算大概排名呢？一般做法是按照数值区间建立所若干个桶，比如我们预计要排名的那一个数据的最大值能到1W。我建立0-10， 10-100，100-1000， 1000-2000， 2000-5000， 5000-10000 这样6个桶，每个桶里面记录分值在这个桶对应的区间内，有多少个玩家。 比如<br>0-10， 10人<br>10-100，20人<br>100-1000，30人<br>1000-2000， 40人<br>2000-5000， 50人<br>5000-10000， 60人<br>那么如果一个玩家 是 1234分，那么他的排名就超过了 （10 + 20 + 30）&#x2F; （10 + 20 + 30 + 40 + 50 + 60）这个百分比的玩家（所以桶分的越细，后面的排名越精确）<br>实质就是按照分区间记录区间内元素个数，从而估算大概排名，因此数值区间越小，估算约精确。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"需求背景\"><a href=\"#需求背景\" class=\"headerlink\" title=\"需求背景\"></a>需求背景</h2><ol>\n<li>查看TopN的用户排名</li>\n<li>查看自己的排名</li>\n<li>用户积分变更后，排名及时更新</li>\n</ol>\n<h2 id=\"实现方案\"><a href=\"#实现方案\" class=\"headerlink\" title=\"实现方案\"></a>实现方案</h2><h3 id=\"方案一-利用MYSQL-排序\"><a href=\"#方案一-利用MYSQL-排序\" class=\"headerlink\" title=\"方案一 利用MYSQL 排序\"></a>方案一 利用MYSQL 排序</h3><p>利用MySQL来实现，存放一张用户积分表user_score<br>取前top N，自己的排名都可以通过简单的sql语句搞定。<br>算法简单，利用sql的功能，不需要其他复杂逻辑，对于数据量比较少、性能要求不高，可以使用。但是对于海量数据，性能是无法接受的。可能会导致全局锁表之类的问题。</p>\n<h3 id=\"方案二-内存数组排序\"><a href=\"#方案二-内存数组排序\" class=\"headerlink\" title=\"方案二 内存数组排序\"></a>方案二 内存数组排序</h3><p>在内存中预分配所要排名用户大小的数组，所有的积分排名变更基于此移动元素，成熟排序算法有最小&#x2F;大堆、快速排序等，这种方案优点是当数据量小的时候，简单快捷，容易实现，不需要其他任何组件支持，但是当面对海量数据的时候数组空间占用可能不太现实</p>\n<h3 id=\"方案三-利用GCC库支持\"><a href=\"#方案三-利用GCC库支持\" class=\"headerlink\" title=\"方案三 利用GCC库支持\"></a>方案三 利用GCC库支持</h3><p>具体的，用GCC的pb_ds库中有assoc_container来进行实现。<br>参考<a href=\"https://opensource.apple.com/source/llvmgcc42/llvmgcc42-2336.9/libstdc++-v3/testsuite/ext/pb_ds/example/tree_order_statistics.cc\">tree_order_statistics.cc</a>：</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ext/pb_ds/assoc_container.hpp&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ext/pb_ds/tree_policy.hpp&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> pb_ds;\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> pb_ds;\n\n<span class=\"hljs-comment\">// A red-black tree table storing ints and their order</span>\n<span class=\"hljs-comment\">// statistics. Note that since the tree uses</span>\n<span class=\"hljs-comment\">// tree_order_statistics_node_update as its update policy, then it</span>\n<span class=\"hljs-comment\">// includes its methods by_order and order_of_key.</span>\n<span class=\"hljs-keyword\">typedef</span>\ntree&lt;\n  <span class=\"hljs-type\">int</span>,\n  null_mapped_type,\n  less&lt;<span class=\"hljs-type\">int</span>&gt;,\n  rb_tree_tag,\n  <span class=\"hljs-comment\">// This policy updates nodes&#x27; metadata for order statistics.</span>\n  tree_order_statistics_node_update&gt;\n<span class=\"hljs-type\">set_t</span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n  <span class=\"hljs-comment\">// Insert some entries into s.</span>\n  <span class=\"hljs-type\">set_t</span> s;\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">12</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">505</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">30</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">1000</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">10000</span>);\n  s.<span class=\"hljs-built_in\">insert</span>(<span class=\"hljs-number\">100</span>);\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 30, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">12</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">30</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">100</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">3</span>) == <span class=\"hljs-number\">505</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">5</span>) == <span class=\"hljs-number\">10000</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">6</span>) == s.<span class=\"hljs-built_in\">end</span>());\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 30, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">12</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">15</span>) == <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">30</span>) == <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">99</span>) == <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">100</span>) == <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">505</span>) == <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">1000</span>) == <span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10000</span>) == <span class=\"hljs-number\">5</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">9999999</span>) == <span class=\"hljs-number\">6</span>);\n\n  <span class=\"hljs-comment\">// Erase an entry.</span>\n  s.<span class=\"hljs-built_in\">erase</span>(<span class=\"hljs-number\">30</span>);\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">12</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">100</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">505</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">3</span>) == <span class=\"hljs-number\">1000</span>);\n  <span class=\"hljs-built_in\">assert</span>(*s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">10000</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">find_by_order</span>(<span class=\"hljs-number\">5</span>) == s.<span class=\"hljs-built_in\">end</span>());\n\n  <span class=\"hljs-comment\">// The order of the keys should be: 12, 100, 505, 1000, 10000.</span>\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">12</span>) == <span class=\"hljs-number\">0</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">100</span>) == <span class=\"hljs-number\">1</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">505</span>) == <span class=\"hljs-number\">2</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">707</span>) == <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">1000</span>) == <span class=\"hljs-number\">3</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">1001</span>) == <span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">10000</span>) == <span class=\"hljs-number\">4</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">100000</span>) == <span class=\"hljs-number\">5</span>);\n  <span class=\"hljs-built_in\">assert</span>(s.<span class=\"hljs-built_in\">order_of_key</span>(<span class=\"hljs-number\">9999999</span>) == <span class=\"hljs-number\">5</span>);\n\n  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n&#125;</code></pre>\n<p>存取效率都可以达到O(log(n))，不足就是程序重启后数据会丢失。还是对所有的用户积分，没必要。<br>而且是有依赖，不方便扩展，实现不了复杂的需求，</p>\n<h3 id=\"方案四-实现排序树\"><a href=\"#方案四-实现排序树\" class=\"headerlink\" title=\"方案四 实现排序树\"></a>方案四 实现排序树</h3><p>大致实现思路如下：</p>\n<p>　　我们可以把[0, 1,000,000)作为一级区间；再把一级区间分为两个2级区间[0, 500,000), [500,000, 1,000,000)，然后把二级区间二分为4个3级区间[0, 250,000), [250,000, 500,000), [500,000, 750,000), [750,000, 1,000,000)，依此类推，最终我们会得到1,000,000个21级区间[0,1), [1,2) … [999,999, 1,000,000)。这实际上是把区间组织成了一种平衡二叉树结构，根结点代表一级区间，每个非叶子结点有两个子结点，左子结点代表低分区间，右子结点代表高分区间。树形分区结构需要在更新时保持一种不变量，非叶子结点的count值总是等于其左右子结点的count值之和。</p>\n<p>　　以后，每次用户积分有变化所需要更新的区间数量和积分变化量有关系，积分变化越小更新的区间层次越低。总体上，每次所需要更新的区间数量是用户积分变量的log(n)级别的，也就是说如果用户积分一次变化在百万级，更新区间的数量在二十这个级别。在这种树形分区积分表的辅助下查询积分为s的用户排名，实际上是一个在区间树上由上至下、由粗到细一步步明确s所在位置的过程。比如，对于积分499,000，我们用一个初值为0的排名变量来做累加；首先，它属于1级区间的左子树[0, 500,000)，那么该用户排名应该在右子树[500,000, 1,000,000)的用户数count之后，我们把该count值累加到该用户排名变量，进入下一级区间；其次，它属于3级区间的[250,000, 500,000)，这是2级区间的右子树，所以不用累加count到排名变量，直接进入下一级区间；再次，它属于4级区间的…；直到最后我们把用户积分精确定位在21级区间[499,000, 499,001)，整个累加过程完成，得出排名！</p>\n<p>　　虽然，本算法的更新和查询都涉及到若干个操作，但如果我们为区间的from_score和to_score建立索引，这些操作都是基于键的查询和更新，不会产生表扫描，因此效率更高。另外，本算法并不依赖于关系数据模型和SQL运算，可以轻易地改造为NoSQL等其他存储方式，而基于键的操作也很容易引入缓存机制进一步优化性能。进一步，我们可以估算一下树形区间的数目大约为2,000,000，考虑每个结点的大小，整个结构只占用几十M空间。所以，我们完全可以在内存建立区间树结构，并通过user_score表在O(n)的时间内初始化区间树，然后排名的查询和更新操作都可以在内存进行。一般来讲，同样的算法，从数据库到内存算法的性能提升常常可以达到10^5以上；因此，本算法可以达到非常高的性能。</p>\n<p>　　算法特点</p>\n<p>　　优点：结构稳定，不受积分分布影响；每次查询或更新的复杂度为积分最大值的O(log(n))级别，且与用户规模无关，可以应对海量规模；不依赖于SQL，容易改造为NoSQL或内存数据结构。</p>\n<p>　　缺点：算法相对更复杂。</p>\n<h3 id=\"方案五-实现跳表排序\"><a href=\"#方案五-实现跳表排序\" class=\"headerlink\" title=\"方案五 实现跳表排序\"></a>方案五 实现跳表排序</h3><p>skip list是链表的一种特殊形式，对链表的一种优化；保证INSERT和REMOVE操作是O(logn)，而通用链表的复杂度为O(n);<br>优点：实现较简单，效率基本上O(log(N))<br>缺点：当达到亿级别时的数据时，性能会急剧下降</p>\n<h3 id=\"方案六-利用redis特新实现\"><a href=\"#方案六-利用redis特新实现\" class=\"headerlink\" title=\"方案六 利用redis特新实现\"></a>方案六 利用redis特新实现</h3><p>其实redis底层还是使用跳表实现排序的，只是将接口都封装好了，使用接口也比较完善，稳定。</p>\n<p>redis的zset天生是用来做排行榜的、好友列表, 去重, 历史记录等业务需求。接口使用非常简单。接口非常丰富，基本上需要的实现都能满足，说明如下：</p>\n<p>ZAdd&#x2F;ZRem是O(log(N))，ZRangeByScore&#x2F;ZRemRangeByScore是O(log(N)+M)，N是Set大小，M是结果&#x2F;操作元素的个数。</p>\n<p>ZSET的实现用到了两个数据结构：hash table 和 skip list(跳跃表)，其中hash table是具体使用redis中的dict来实现的，主要是为了保证查询效率为O(1) ，而skip list(跳跃表)主要是保证元素有序并能够保证INSERT和REMOVE操作是O(logn)的复杂度。</p>\n<p>优点：基于redis开发，速度快；使用redis相关特性</p>\n<p>缺点：当达到亿级别时的数据时，性能会急剧下降</p>\n<p>来实现排行榜的方法很多，可以根据自己的具体需求，参考选用。</p>\n<h2 id=\"方案七-其实只需要TopN的排名，大于N的排名并不需要精确排名计算\"><a href=\"#方案七-其实只需要TopN的排名，大于N的排名并不需要精确排名计算\" class=\"headerlink\" title=\"方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算\"></a>方案七 其实只需要TopN的排名，大于N的排名并不需要精确排名计算</h2><p>基于此，假设我们游戏内只需要排前100名，这里我们只需要维护一个100大小的数组</p>\n<ol>\n<li>当元素A需要参与排序的时候，与数组中最小的积分进行比较，如果能进100名，那么将第100剔除，将A加入，并记录最小元素，这样就完成了积分上涨的情况</li>\n<li>还有一种就是已经在前100名中元素的积分发生变化下降，那么需要在前100名后找出可以进排行榜的元素，这种情况比较麻烦，可以使用最大堆保存剩下所有用户的数据，当需要找出能替换进入排行榜的元素就非常快logn，选择特定数据结构非常重要</li>\n<li>既然大于N的用户不需要精确排名，那么怎么样估算大概排名呢？一般做法是按照数值区间建立所若干个桶，比如我们预计要排名的那一个数据的最大值能到1W。我建立0-10， 10-100，100-1000， 1000-2000， 2000-5000， 5000-10000 这样6个桶，每个桶里面记录分值在这个桶对应的区间内，有多少个玩家。 比如<br>0-10， 10人<br>10-100，20人<br>100-1000，30人<br>1000-2000， 40人<br>2000-5000， 50人<br>5000-10000， 60人<br>那么如果一个玩家 是 1234分，那么他的排名就超过了 （10 + 20 + 30）&#x2F; （10 + 20 + 30 + 40 + 50 + 60）这个百分比的玩家（所以桶分的越细，后面的排名越精确）<br>实质就是按照分区间记录区间内元素个数，从而估算大概排名，因此数值区间越小，估算约精确。</li>\n</ol>\n"},{"title":"批量转换换行符CRLF到LF","date":"2020-02-12T05:25:41.000Z","_content":"\n## 关闭Git自动转换功能\n\n```\ngit config --global core.autocrlf false\n```\n\n## CRLF转换成LF\n\n**vscode或者visual studio等一些代码编辑器仅仅支持单个文件的格式转换，以下三种方法均是支持批量转换的方法**\n\n### 第一种方法 (亲测))\n\n已经上传到`/y-server/doc/format/` 目录下 或者点击下面链接下载最新\n\n[下载dos2unix工具包](https://waterlan.home.xs4all.nl/dos2unix/dos2unix-7.4.1-win64.zip)\n\n[dos2unix文档说明](https://waterlan.home.xs4all.nl/dos2unix/zh_CN/man1/dos2unix.htm#9)\n\n结合 find(1) 和 xargs(1) 使用 dos2unix 可以递归地转换目录树中的文本文件。例如，转换当前目录的目录树中所有的 .txt 文件：\n```\ndos2unix < a.txt\ncat a.txt | dos2unix\n```\n若文件名中有空格或引号，则需要使用 find(1) 选项 -print0 及相应的 xargs(1) 选项 -0；其他情况下则可以省略它们。也可以结合 -exec 选项来使用 find(1)：\n```\nfind . -name '*.txt' -exec dos2unix {} \\;\n```\n在Windows命令提示符中，可以使用下列命令：\n```\nfor /R %G in (*.txt) do dos2unix \"%G\"\n```\nPowerShell用户可以在Windows PowerShell中使用如下命令：\n```\nget-childitem -path . -filter '*.txt' -recurse | foreach-object {dos2unix $_.Fullname}\n```\n\n### 第二种方法 (没有尝试)\n\n采用EditPlus批量转换文件格式\n\n![1](https://img-blog.csdnimg.cn/20190414011144786.png)\n![2](https://img-blog.csdnimg.cn/20190414011207506.png)\n![2](https://img-blog.csdnimg.cn/20190414011249745.png)\n\n### 第三种方法 (没有尝试)\n\n[巧妙的借助git快速批量转换crlf到lf](https://rizon.top/tech/%E8%BD%AC%E6%8D%A2crlf%E5%88%B0lf/)","source":"_posts/批量换行符转换CRLF到LF.md","raw":"---\ntitle: 批量转换换行符CRLF到LF\ndate: 2020-02-12 13:25:41\ntags: git\n---\n\n## 关闭Git自动转换功能\n\n```\ngit config --global core.autocrlf false\n```\n\n## CRLF转换成LF\n\n**vscode或者visual studio等一些代码编辑器仅仅支持单个文件的格式转换，以下三种方法均是支持批量转换的方法**\n\n### 第一种方法 (亲测))\n\n已经上传到`/y-server/doc/format/` 目录下 或者点击下面链接下载最新\n\n[下载dos2unix工具包](https://waterlan.home.xs4all.nl/dos2unix/dos2unix-7.4.1-win64.zip)\n\n[dos2unix文档说明](https://waterlan.home.xs4all.nl/dos2unix/zh_CN/man1/dos2unix.htm#9)\n\n结合 find(1) 和 xargs(1) 使用 dos2unix 可以递归地转换目录树中的文本文件。例如，转换当前目录的目录树中所有的 .txt 文件：\n```\ndos2unix < a.txt\ncat a.txt | dos2unix\n```\n若文件名中有空格或引号，则需要使用 find(1) 选项 -print0 及相应的 xargs(1) 选项 -0；其他情况下则可以省略它们。也可以结合 -exec 选项来使用 find(1)：\n```\nfind . -name '*.txt' -exec dos2unix {} \\;\n```\n在Windows命令提示符中，可以使用下列命令：\n```\nfor /R %G in (*.txt) do dos2unix \"%G\"\n```\nPowerShell用户可以在Windows PowerShell中使用如下命令：\n```\nget-childitem -path . -filter '*.txt' -recurse | foreach-object {dos2unix $_.Fullname}\n```\n\n### 第二种方法 (没有尝试)\n\n采用EditPlus批量转换文件格式\n\n![1](https://img-blog.csdnimg.cn/20190414011144786.png)\n![2](https://img-blog.csdnimg.cn/20190414011207506.png)\n![2](https://img-blog.csdnimg.cn/20190414011249745.png)\n\n### 第三种方法 (没有尝试)\n\n[巧妙的借助git快速批量转换crlf到lf](https://rizon.top/tech/%E8%BD%AC%E6%8D%A2crlf%E5%88%B0lf/)","slug":"批量换行符转换CRLF到LF","published":1,"updated":"2020-02-12T05:25:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzg5000rokec2foig6t6","content":"<h2 id=\"关闭Git自动转换功能\"><a href=\"#关闭Git自动转换功能\" class=\"headerlink\" title=\"关闭Git自动转换功能\"></a>关闭Git自动转换功能</h2><pre><code class=\"hljs angelscript\">git config --global core.<span class=\"hljs-built_in\">auto</span>crlf <span class=\"hljs-literal\">false</span></code></pre>\n\n<h2 id=\"CRLF转换成LF\"><a href=\"#CRLF转换成LF\" class=\"headerlink\" title=\"CRLF转换成LF\"></a>CRLF转换成LF</h2><p><strong>vscode或者visual studio等一些代码编辑器仅仅支持单个文件的格式转换，以下三种方法均是支持批量转换的方法</strong></p>\n<h3 id=\"第一种方法-亲测\"><a href=\"#第一种方法-亲测\" class=\"headerlink\" title=\"第一种方法 (亲测))\"></a>第一种方法 (亲测))</h3><p>已经上传到<code>/y-server/doc/format/</code> 目录下 或者点击下面链接下载最新</p>\n<p><a href=\"https://waterlan.home.xs4all.nl/dos2unix/dos2unix-7.4.1-win64.zip\">下载dos2unix工具包</a></p>\n<p><a href=\"https://waterlan.home.xs4all.nl/dos2unix/zh_CN/man1/dos2unix.htm#9\">dos2unix文档说明</a></p>\n<p>结合 find(1) 和 xargs(1) 使用 dos2unix 可以递归地转换目录树中的文本文件。例如，转换当前目录的目录树中所有的 .txt 文件：</p>\n<pre><code class=\"hljs livecodeserver\">dos2unix &lt; <span class=\"hljs-keyword\">a</span>.txt\ncat <span class=\"hljs-keyword\">a</span>.txt | dos2unix</code></pre>\n<p>若文件名中有空格或引号，则需要使用 find(1) 选项 -print0 及相应的 xargs(1) 选项 -0；其他情况下则可以省略它们。也可以结合 -exec 选项来使用 find(1)：</p>\n<pre><code class=\"hljs sqf\"><span class=\"hljs-built_in\">find</span> . -<span class=\"hljs-built_in\">name</span> <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> -<span class=\"hljs-built_in\">exec</span> dos2unix &#123;&#125; \\;</code></pre>\n<p>在Windows命令提示符中，可以使用下列命令：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-keyword\">for</span> /R %G in (*.txt) <span class=\"hljs-keyword\">do</span> dos2unix <span class=\"hljs-string\">&quot;%G&quot;</span></code></pre>\n<p>PowerShell用户可以在Windows PowerShell中使用如下命令：</p>\n<pre><code class=\"hljs dsconfig\"><span class=\"hljs-built_in\">get-childitem</span> -<span class=\"hljs-string\">path</span> . -<span class=\"hljs-string\">filter</span> <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> -<span class=\"hljs-string\">recurse</span> | <span class=\"hljs-string\">foreach-object</span> &#123;<span class=\"hljs-string\">dos2unix</span> $<span class=\"hljs-string\">_</span>.<span class=\"hljs-string\">Fullname</span>&#125;</code></pre>\n\n<h3 id=\"第二种方法-没有尝试\"><a href=\"#第二种方法-没有尝试\" class=\"headerlink\" title=\"第二种方法 (没有尝试)\"></a>第二种方法 (没有尝试)</h3><p>采用EditPlus批量转换文件格式</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190414011144786.png\" alt=\"1\"><br><img src=\"https://img-blog.csdnimg.cn/20190414011207506.png\" alt=\"2\"><br><img src=\"https://img-blog.csdnimg.cn/20190414011249745.png\" alt=\"2\"></p>\n<h3 id=\"第三种方法-没有尝试\"><a href=\"#第三种方法-没有尝试\" class=\"headerlink\" title=\"第三种方法 (没有尝试)\"></a>第三种方法 (没有尝试)</h3><p><a href=\"https://rizon.top/tech/%E8%BD%AC%E6%8D%A2crlf%E5%88%B0lf/\">巧妙的借助git快速批量转换crlf到lf</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"关闭Git自动转换功能\"><a href=\"#关闭Git自动转换功能\" class=\"headerlink\" title=\"关闭Git自动转换功能\"></a>关闭Git自动转换功能</h2><pre><code class=\"hljs angelscript\">git config --global core.<span class=\"hljs-built_in\">auto</span>crlf <span class=\"hljs-literal\">false</span></code></pre>\n\n<h2 id=\"CRLF转换成LF\"><a href=\"#CRLF转换成LF\" class=\"headerlink\" title=\"CRLF转换成LF\"></a>CRLF转换成LF</h2><p><strong>vscode或者visual studio等一些代码编辑器仅仅支持单个文件的格式转换，以下三种方法均是支持批量转换的方法</strong></p>\n<h3 id=\"第一种方法-亲测\"><a href=\"#第一种方法-亲测\" class=\"headerlink\" title=\"第一种方法 (亲测))\"></a>第一种方法 (亲测))</h3><p>已经上传到<code>/y-server/doc/format/</code> 目录下 或者点击下面链接下载最新</p>\n<p><a href=\"https://waterlan.home.xs4all.nl/dos2unix/dos2unix-7.4.1-win64.zip\">下载dos2unix工具包</a></p>\n<p><a href=\"https://waterlan.home.xs4all.nl/dos2unix/zh_CN/man1/dos2unix.htm#9\">dos2unix文档说明</a></p>\n<p>结合 find(1) 和 xargs(1) 使用 dos2unix 可以递归地转换目录树中的文本文件。例如，转换当前目录的目录树中所有的 .txt 文件：</p>\n<pre><code class=\"hljs livecodeserver\">dos2unix &lt; <span class=\"hljs-keyword\">a</span>.txt\ncat <span class=\"hljs-keyword\">a</span>.txt | dos2unix</code></pre>\n<p>若文件名中有空格或引号，则需要使用 find(1) 选项 -print0 及相应的 xargs(1) 选项 -0；其他情况下则可以省略它们。也可以结合 -exec 选项来使用 find(1)：</p>\n<pre><code class=\"hljs sqf\"><span class=\"hljs-built_in\">find</span> . -<span class=\"hljs-built_in\">name</span> <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> -<span class=\"hljs-built_in\">exec</span> dos2unix &#123;&#125; \\;</code></pre>\n<p>在Windows命令提示符中，可以使用下列命令：</p>\n<pre><code class=\"hljs perl\"><span class=\"hljs-keyword\">for</span> /R %G in (*.txt) <span class=\"hljs-keyword\">do</span> dos2unix <span class=\"hljs-string\">&quot;%G&quot;</span></code></pre>\n<p>PowerShell用户可以在Windows PowerShell中使用如下命令：</p>\n<pre><code class=\"hljs dsconfig\"><span class=\"hljs-built_in\">get-childitem</span> -<span class=\"hljs-string\">path</span> . -<span class=\"hljs-string\">filter</span> <span class=\"hljs-string\">&#x27;*.txt&#x27;</span> -<span class=\"hljs-string\">recurse</span> | <span class=\"hljs-string\">foreach-object</span> &#123;<span class=\"hljs-string\">dos2unix</span> $<span class=\"hljs-string\">_</span>.<span class=\"hljs-string\">Fullname</span>&#125;</code></pre>\n\n<h3 id=\"第二种方法-没有尝试\"><a href=\"#第二种方法-没有尝试\" class=\"headerlink\" title=\"第二种方法 (没有尝试)\"></a>第二种方法 (没有尝试)</h3><p>采用EditPlus批量转换文件格式</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20190414011144786.png\" alt=\"1\"><br><img src=\"https://img-blog.csdnimg.cn/20190414011207506.png\" alt=\"2\"><br><img src=\"https://img-blog.csdnimg.cn/20190414011249745.png\" alt=\"2\"></p>\n<h3 id=\"第三种方法-没有尝试\"><a href=\"#第三种方法-没有尝试\" class=\"headerlink\" title=\"第三种方法 (没有尝试)\"></a>第三种方法 (没有尝试)</h3><p><a href=\"https://rizon.top/tech/%E8%BD%AC%E6%8D%A2crlf%E5%88%B0lf/\">巧妙的借助git快速批量转换crlf到lf</a></p>\n"},{"title":"Timer 定时器技术分享","date":"2020-01-23T07:12:45.000Z","_content":"\n## 说点废话\n> 不管是客户端`Client`还是服务器`Server`，不论你是从事游戏行业还是互联网行业，在技术上总会涉及到定时器。虽然有的框架系统已经帮你实现，并且提供完美API供你使用，但你真的了解定时器吗？我们不仅要知道如何使用正确的Timer，还得明白定时器的实现原理，要知其所以然。  \n\n## 理解定时器\n使用者角度分类：\n1. 周期性定时器\n    1. 使用 `TCP` 长连接时，客户端需要定时向服务端发送心跳请求\n    2. 游戏内系统每日重置功能\n    3. 体力回复\n    4. ....\n   \n2. 非周期性定时器\n    1.  玩法活动定时开启、关闭\n    2.  ...\n\n**当然，大部分非周期性定时器都可以使用周期性定时器实现，即执行一次后立即调用Remove接口即可**\n\n定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：**存储一系列的任务集合，并且 `Deadline` 越接近的任务，拥有越高的执行优先级**\n\n支持以下几种操作：\n1. `Add New TimerTask` 添加新的定时器\n2. `Kill Or Remove TimerTask` 取消或者移除既有定时器任务\n3. `Run` 执行\n\n判断一个`TimerTask`是否到期，基本会采用轮询的方式，每隔一个**时间片**`tickDuration`去检查最近的任务是否到期。\n\n> **说到底，定时器还是靠线程轮询实现的。**\n\n现在知道`Timer`是靠轮询来实现的，那么中间应该采用那种数据结构呢？采用不同的数据结构实现，其性能也大不一样！\n现在主要有如下几种：`List`链表、`Heap`最小堆、时间轮、分级时间轮，其中时间轮的实质为Hash表。\n\n## 数据结构\n\n### 双向有序链表\n`AddTimer O(N) `很容易理解，按照 `expireTime` 查找合适的位置即可；`KillTimer O(1)` ，任务在 `Kill` 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除;`RunTimer O(1)`，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。\n\n### 最小堆\n最小堆指的是满足除了根节点以外的每个节点都不小于其父节点的堆。这样，堆中的最小值就存放在根节点中，并且在以某个结点为根的子树中，各节点的值都不小于该子树根节点的值。一个最小堆的例子如下图：\n![最小堆](https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image002.jpg)\n\n明显的，最小堆添加新元素或者删除节点效率为`O(lgn)`, `root`节点`expireTime`最小，执行优先级最高，因此复杂度为O(1)\n\n**如果程序中的定时器数量比较少，基于最小堆的定时器一般可以满足需求，且实现简单。**\n\n### 时间轮\n时间轮的实质为哈希环`HashTable`,每个定时器任务根据对其`expireTime`哈希，得到对应的位置`index`，复杂度为`O(1)`\n![时间轮](http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png)\n\n**性能比较：**\n| 实现方式 |\tAddTimer\t| KillTimer\t | RunTimer|\n|-------- |------------| -----------| -----------|\n| 基于链表  |\tO(1)\t| O(n)\t| O(n)|\n|基于排序链表\t|O(n)\t|O(1)\t|O(1)|\n|基于最小堆     |\tO(lgn)|\tO(lgn)|\tO(1)|\n|基于时间轮\t|O(1)\t|O(1)\t|O(1)|\n\n\n*现在看起来我们选择时间轮来实现就行了，是否这样就完事了？*\n\n## 着重分析时间轮\n\n如果需要支持的定时器范围非常的大，上面的实现方式则不能满足这样的需求。因为这样将消耗非常可观的内存，假设需要表示的定时器范围为：0 – 2^3-1ticks，则简单时间轮需要 2^32 个元素空间，这对于内存空间的使用将非常的庞大。也许可以降低定时器的精度，使得每个 Tick 表示的时间更长一些，但这样的代价是定时器的精度将大打折扣。\n\n现在的问题是，度量定时器的粒度，只能使用唯一粒度吗？想想日常生活中常遇到的水表，如下图：\n![水表](https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image004.jpg)\n\n钟表：\n![水表](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556440651&di=0c604969bfdf6b335dd78462f862743e&imgtype=jpg&er=1&src=http%3A%2F%2Famuseum.cdstm.cn%2FAMuseum%2Ftime%2F01gzsj%2Fimages%2F0102_b.jpg)\n\n分级时间轮同样如此，每级时间轮所代表的粒度精度都不一样，这样结合起来，既能够保证定时器的精度，也能以较小内存代价表示范围更大更多的定时器。\n\n**简单时间轮**： 一个齿轮，每个齿轮保存一个超时的node链表。一个齿轮表示一个时间刻度，比如钟表里面一小格代表一秒，钟表的秒针每次跳一格。假设一个刻度代表10ms，则2^32 个格子可表示1.36年，2^16个格子可表示10.9分钟。当要表示的时间范围较大时，空间复杂度会大幅增加。\n\n**分级时间轮**： 类似于水表，当小轮子里的指针转动满一圈后，上一级轮子的指针进一格。  采用五个轮子每个轮子为一个简单时间轮，大小分别为 2^8， 2^6， 2^6， 2^6， 2^6，所需空间：2^8 + 2^6 + 2^6 + 2^6 + 2^6 = 512， 可表示的范围为 0  --  2^8 * 2^6 * 2^6* 2^6* 2^6 = 2^32 。\n\n**分级时间轮简洁图**：\n![分级时间轮](http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png)\n\n*熟知的Linux系统内核，定时器实现方式就是分级时间轮*\n![Linux内核](https://images0.cnblogs.com/i/205989/201405/281755599318276.jpg)\n\n## 具体实现\nwheel_timer_mgr.h\n```cpp\nclass CWheelTimerModule;\nclass ITimerMgr;\nclass CWheelTimer;\n\ntypedef std::list<CWheelTimer*> TListTimer;\n\nenum ETimerType \n{ \n\tETIMER_ONCE, \n\tETIMER_CIRCLE \n};\n\n///定时器最小精度 1/10秒 （100毫秒）\nstatic const int  WHEEL_TIMER_MIN_PRECISION = 100;\n\n/**\n* @brief 基于分级的时间轮定时器, 精度约定为十分之一秒\n* 注意，注册的Timer精度必须为约定的精度倍数\n*/\nclass CWheelTimer\n{\npublic:\n\tCWheelTimer();\n\tCWheelTimer(CWheelTimerModule& oModule);\n\t~CWheelTimer();\n\n\t/**\n\t* @brief 启动定时器\n\t* @param nInterval: 传入的是毫秒, 约定必须是十分之一秒（100ms）的倍数\n\t* @return \n\t*/\n\tvoid Start(ITimerMgr* pITimer, unsigned int nId, unsigned nInterval, int nDelay, ETimerType eTimerType = ETIMER_CIRCLE);\n\n\t/**\n\t* @brief 停止定时器\n\t*/\n\tvoid Stop();\nprivate:\n\t/**\n\t* @brief 定时器被触发\n\t*/\n\tvoid OnTrigger(const UINT64 nNow);\n\nprivate:\n\tfriend class CWheelTimerModule;\n\n\tCWheelTimerModule&\t\tm_oModule;\n\tITimerMgr*\t\t\t\tm_pTimerMgr = nullptr;\n\tETimerType\t\t\t\tm_eTimerType;\n\tunsigned int\t\t\tm_nTimerId = 0;\n\tunsigned int\t\t\tm_nInterval = -1;    //ms\n\tunsigned long long\t\tm_llExpireTime = 0;  //ms\n\tint\t\t\t\t\t\tm_nVecIndex = 0;\n\tTListTimer::iterator\tm_listIter;\n};\n\n/**\n* @brief 定时器管理器接口， 派生类继承使用\n*/\nclass ITimerMgr\n{\npublic:\n\tvirtual\t\t  ~ITimerMgr();\n\tvirtual void  OnTimer(unsigned int nId) = 0;\n\t//interval 时间精度 ms\n\tvoid\t\t  SetTimer(unsigned int nId, int nInterval, int nDelay = 0, ETimerType eTimeType = ETIMER_CIRCLE);\n\tvoid\t\t  KillTimer(unsigned int nId);\n\tbool\t\t  IsTimerExist(unsigned int nId);;\n\nprotected:\n\tstd::unordered_map<unsigned int, CWheelTimer*> m_mapTimer;\n};\n\n/**\n* @brief 全局定时器管理模块， 负责管理所有的定时器\n*/\nclass CWheelTimerModule : public Storm::TSingleton<CWheelTimerModule>\n{\n\tfriend class Storm::TSingleton<CWheelTimerModule>;\n\tCWheelTimerModule();\npublic:\n\tvoid\t\t\tAddTimer(CWheelTimer* pTimer);\n\tvoid\t\t\tRemoveTimer(CWheelTimer* pTimer);\n\t/**\n\t* @brief 驱动所有的定时器\n\t*/\n\tvoid\t\t\tRun();\n\n\tstatic UINT64\tGetCurMillisecs();\n\t/**\n\t* @brief 修正精度 \n\t* @param nSrcTime \n\t* @return 传入的时间除以当前约定最小定时器精度\n\t*/\n\tstatic UINT64\tHandlePrecision(const UINT64 nSrcTime);\n\nprivate:\n\tint\t\t\t\t_Cascade(int nOffset, int nIndex);\n\nprivate:\n\tstd::vector<TListTimer>\t\tm_vecTimerList;\n\n\t//notice: precision=100ms not 1ms\n\tUINT64\t\t\t\t\t\tm_llCheckTime;\n};\n\n/**\n* @brief 定时器工厂 \n*/\nclass CTimerFactory: public Storm::TSingleton<CTimerFactory>, public CNoncopy\n{\n\tfriend class Storm::TSingleton<CTimerFactory>;\n\tCTimerFactory();\n\tvirtual\t\t\t~CTimerFactory();\npublic: \n\tCWheelTimer*\tCreateCTimer();\n\tvoid\t\t\tReleaseCTimer(CWheelTimer* pTimer);\nprivate:\n\n\tCSTObjectPool<CWheelTimer>    m_oCTimerPool;\n}\n```\n\nwheel_timer_mgr.cpp\n```cpp\n#if 0 \n\t#define TVN_BITS 6\n\t#define TVR_BITS 8\n\t#define TVN_SIZE (1 << TVN_BITS)\n\t#define TVR_SIZE (1 << TVR_BITS)\n\t#define TVN_MASK (TVN_SIZE - 1)\n\t#define TVR_MASK (TVR_SIZE - 1)\n\t#define OFFSET(N) (TVR_SIZE + (N) *TVN_SIZE)\n\t#define INDEX(V, N) ((V >> (TVR_BITS + (N) *TVN_BITS)) & TVN_MASK)\n#else \n\tstatic const int TVN_BITS = 6;\n\tstatic const int TVR_BITS = 8;\n\tstatic const int TVN_SIZE = (1 << TVN_BITS);\n\tstatic const int TVR_SIZE = (1 << TVR_BITS);\n\tstatic const int TVN_MASK = (TVN_SIZE - 1);\n\tstatic const int TVR_MASK = (TVR_SIZE - 1);\n\tint OFFSET(int N) { return (TVR_SIZE + (N)*TVN_SIZE); }\n\tint INDEX(unsigned long long V, int N)\n\t{\n\t\treturn ((V >> (TVR_BITS + (N)*TVN_BITS)) & TVN_MASK);\n\t}\n\n#endif\n\n\n\nCWheelTimer::CWheelTimer()\n\t:m_oModule(CWheelTimerModule::GetInstance())\n\t, m_nVecIndex(-1)\n{\n}\n\nCWheelTimer::CWheelTimer(CWheelTimerModule& oModule)\n\t: m_oModule(oModule)\n\t, m_nVecIndex(-1)\n{\n}\n\nCWheelTimer::~CWheelTimer()\n{\n\tStop();\n}\n\nvoid CWheelTimer::Start(ITimerMgr* pTimerMgr, unsigned int nId, unsigned nInterval, int nDelay, ETimerType eTimerType)\n{\n\tStop();\n\n\t//时间都修正为最小精度\n\tif (nInterval < WHEEL_TIMER_MIN_PRECISION)\n\t{\n\t\tnInterval = WHEEL_TIMER_MIN_PRECISION;\n\t}\n\n\tm_nInterval = CWheelTimerModule::HandlePrecision(nInterval);\n\tm_eTimerType = eTimerType;\n\tm_pTimerMgr = pTimerMgr;\n\tm_nTimerId = nId;\n\tm_llExpireTime = CWheelTimerModule::HandlePrecision(nDelay + CWheelTimerModule::GetCurMillisecs());\n\tm_oModule.AddTimer(this);\n}\n\n\nvoid CWheelTimer::Stop()\n{\n\tif (m_nVecIndex != -1)\n\t{\n\t\tm_oModule.RemoveTimer(this);\n\t\tm_nVecIndex = -1;\n\t}\n}\n\nvoid CWheelTimer::OnTrigger(const UINT64 nNow)\n{\n\tif (m_eTimerType == ETIMER_CIRCLE)\n\t{\n\t\tm_llExpireTime = m_nInterval + nNow;\n\t\tm_oModule.AddTimer(this);\n\t}\n\telse\n\t{\n\t\tm_nVecIndex = -1;\n\t}\n\n\tif (m_pTimerMgr != nullptr)\n\t{\n\t\tm_pTimerMgr->OnTimer(m_nTimerId);\n\t}\n}\n\n//--------------------------------------------------------------------------------------------------------\n\nCWheelTimerModule::CWheelTimerModule()\n{\n\tm_vecTimerList.resize(TVR_SIZE + 4 * TVN_SIZE);\n\tm_llCheckTime = HandlePrecision(GetCurMillisecs());\n}\n\nvoid CWheelTimerModule::AddTimer(CWheelTimer* pTimer)\n{\n\tUINT64 llExpireTime = pTimer->m_llExpireTime;\n\tINT64 llTimeDiff = pTimer->m_llExpireTime - m_llCheckTime;\n\n\tif (llTimeDiff < 0)\n\t{\n\t\tpTimer->m_nVecIndex = m_llCheckTime & TVR_MASK;\n\t}\n\telse if (llTimeDiff < TVR_SIZE)\n\t{\n\t\tpTimer->m_nVecIndex = llExpireTime & TVR_MASK;\n\t}\n\telse if (llTimeDiff < 1 << (TVR_BITS + TVN_BITS))\n\t{\n\t\tpTimer->m_nVecIndex = OFFSET(0) + INDEX(llExpireTime, 0);\n\t}\n\telse if (llTimeDiff < 1 << (TVR_BITS + 2 * TVN_BITS))\n\t{\n\t\tpTimer->m_nVecIndex = OFFSET(1) + INDEX(llExpireTime, 1);\n\t}\n\telse if (llTimeDiff < 1 << (TVR_BITS + 3 * TVN_BITS))\n\t{\n\t\tpTimer->m_nVecIndex = OFFSET(2) + INDEX(llExpireTime, 2);\n\t}\n\telse\n\t{\n\t\tif (llTimeDiff > 0xffffffffUL)\n\t\t{\n\t\t\tllTimeDiff = 0xffffffffUL;\n\t\t\tllExpireTime = llTimeDiff + m_llCheckTime;\n\t\t}\n\t\tpTimer->m_nVecIndex = OFFSET(3) + INDEX(llExpireTime, 3);\n\t}\n\n\tTListTimer& listTimer = m_vecTimerList[pTimer->m_nVecIndex];\n\tlistTimer.push_back(pTimer);\n\tpTimer->m_listIter = listTimer.end();\n\t--pTimer->m_listIter;\n}\n\nvoid CWheelTimerModule::RemoveTimer(CWheelTimer* pTimer)\n{\n\tTListTimer& listTimer = m_vecTimerList[pTimer->m_nVecIndex];\n\tlistTimer.erase(pTimer->m_listIter);\n}\n\nvoid CWheelTimerModule::Run()\n{\n\tUINT64 nNow = HandlePrecision(GetCurMillisecs());\n\twhile (m_llCheckTime <= nNow)\n\t{\n\t\t//for every tick\n\t\tint index = m_llCheckTime & TVR_MASK;\n\t\tif (!index &&\n\t\t\t!_Cascade(OFFSET(0), INDEX(m_llCheckTime, 0)) &&\n\t\t\t!_Cascade(OFFSET(1), INDEX(m_llCheckTime, 1)) &&\n\t\t\t!_Cascade(OFFSET(2), INDEX(m_llCheckTime, 2)))\n\t\t{\n\t\t\t_Cascade(OFFSET(3), INDEX(m_llCheckTime, 3));\n\t\t}\n\n\t\t\n\t\t++m_llCheckTime;\n\n\t\tTListTimer& listTimer = m_vecTimerList[index];\n\t\tTListTimer listTmp;\n\t\tlistTmp.splice(listTmp.end(), listTimer);\n\t\tfor (auto itr = listTmp.begin(); itr != listTmp.end(); ++itr)\n\t\t{\n\t\t\tauto* pTimer = *itr;\n\t\t\tif (pTimer != nullptr)\n\t\t\t{\n\t\t\t\tpTimer->OnTrigger(nNow);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint CWheelTimerModule::_Cascade(int nOffset, int nIndex)\n{\n\tTListTimer& listTimer = m_vecTimerList[nOffset + nIndex];\n\tTListTimer listTemp;\n\tlistTemp.splice(listTemp.end(), listTimer);\n\n\tfor (auto itr = listTemp.begin(); itr != listTemp.end(); ++itr)\n\t{\n\t\tauto* pTimer = *itr;\n\t\tif (pTimer != nullptr)\n\t\t{\n\t\t\tAddTimer(pTimer);\n\t\t}\n\t}\n\n\treturn nIndex;\n}\n\nUINT64 CWheelTimerModule::HandlePrecision(const UINT64 nSrcTime)\n{\n\treturn nSrcTime / WHEEL_TIMER_MIN_PRECISION;\n}\n\nUINT64 CWheelTimerModule::GetCurMillisecs()\n{\n\tauto llCurTime = CSysTime::Instance()->GetNowMliTime();\n\treturn llCurTime;\n}\n\nITimerMgr::~ITimerMgr()\n{\n\tfor (auto it : m_mapTimer)\n\t{\n\t\tif (it.second != nullptr)\n\t\t{\n\t\t\tit.second->Stop();\n\t\t\tCTimerFactory::Instance()->ReleaseCTimer(it.second);\n\t\t}\n\t}\n\tm_mapTimer.clear();\n}\n\nvoid ITimerMgr::SetTimer(unsigned int nId, int nInterval, int nDelay ,ETimerType eTimeType)\n{\n\tif (IsTimerExist(nId))\n\t{\n\t\tEXLOG_DEBUG << \"[RyzTimer]Timer Has Existed, Not Repeat Add, nId:\" << nId;\n\t\treturn;\n\t}\n\n\tCWheelTimer* pTimer = CTimerFactory::Instance()->CreateCTimer();\n\tif (nullptr == pTimer)\n\t{\n\t\treturn;\n\t}\n\n\tm_mapTimer[nId] = pTimer;\n\tpTimer->Start(this, nId, nInterval, nDelay, eTimeType);\n\tEXLOG_DEBUG << \"[RyzTimer]Add Timer nId:\" << nId << \",nInterval:\" << nInterval << \",nDelay:\" << nDelay << \",eTimeType:\" << eTimeType;\n}\n\nvoid ITimerMgr::KillTimer(unsigned int nId)\n{\n\tauto it = m_mapTimer.find(nId);\n\tif (it != m_mapTimer.end())\n\t{\n\t\t// 释放后 在TimerManager中 不会再执行 不需要做其他的操作\n\t\tit->second->Stop();\n\t\tCTimerFactory::Instance()->ReleaseCTimer(it->second);\n\t\tm_mapTimer.erase(it);\n\t}\n}\n\nbool ITimerMgr::IsTimerExist(unsigned int nId) \n{ \n\treturn m_mapTimer.find(nId) != m_mapTimer.end(); \n}\n\nCTimerFactory::CTimerFactory()\n{\n\tm_oCTimerPool.Init(32, 8);\n}\n\nCTimerFactory::~CTimerFactory()\n{\n}\n\nCWheelTimer * CTimerFactory::CreateCTimer()\n{\n\tCWheelTimer* pTimer = m_oCTimerPool.FetchObj();\n\treturn pTimer;\n}\n\nvoid CTimerFactory::ReleaseCTimer(CWheelTimer* pTimer)\n{\n\tif (nullptr != pTimer)\n\t{\n\t\tm_oCTimerPool.ReleaseObj(pTimer);\n\t}\n}\n\n\n```","source":"_posts/深入浅出时间轮Timer定时器.md","raw":"---\ntitle: Timer 定时器技术分享\ndate: 2020-01-23 15:12:45\ntags: timer\ncategories: Linux\n---\n\n## 说点废话\n> 不管是客户端`Client`还是服务器`Server`，不论你是从事游戏行业还是互联网行业，在技术上总会涉及到定时器。虽然有的框架系统已经帮你实现，并且提供完美API供你使用，但你真的了解定时器吗？我们不仅要知道如何使用正确的Timer，还得明白定时器的实现原理，要知其所以然。  \n\n## 理解定时器\n使用者角度分类：\n1. 周期性定时器\n    1. 使用 `TCP` 长连接时，客户端需要定时向服务端发送心跳请求\n    2. 游戏内系统每日重置功能\n    3. 体力回复\n    4. ....\n   \n2. 非周期性定时器\n    1.  玩法活动定时开启、关闭\n    2.  ...\n\n**当然，大部分非周期性定时器都可以使用周期性定时器实现，即执行一次后立即调用Remove接口即可**\n\n定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：**存储一系列的任务集合，并且 `Deadline` 越接近的任务，拥有越高的执行优先级**\n\n支持以下几种操作：\n1. `Add New TimerTask` 添加新的定时器\n2. `Kill Or Remove TimerTask` 取消或者移除既有定时器任务\n3. `Run` 执行\n\n判断一个`TimerTask`是否到期，基本会采用轮询的方式，每隔一个**时间片**`tickDuration`去检查最近的任务是否到期。\n\n> **说到底，定时器还是靠线程轮询实现的。**\n\n现在知道`Timer`是靠轮询来实现的，那么中间应该采用那种数据结构呢？采用不同的数据结构实现，其性能也大不一样！\n现在主要有如下几种：`List`链表、`Heap`最小堆、时间轮、分级时间轮，其中时间轮的实质为Hash表。\n\n## 数据结构\n\n### 双向有序链表\n`AddTimer O(N) `很容易理解，按照 `expireTime` 查找合适的位置即可；`KillTimer O(1)` ，任务在 `Kill` 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除;`RunTimer O(1)`，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。\n\n### 最小堆\n最小堆指的是满足除了根节点以外的每个节点都不小于其父节点的堆。这样，堆中的最小值就存放在根节点中，并且在以某个结点为根的子树中，各节点的值都不小于该子树根节点的值。一个最小堆的例子如下图：\n![最小堆](https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image002.jpg)\n\n明显的，最小堆添加新元素或者删除节点效率为`O(lgn)`, `root`节点`expireTime`最小，执行优先级最高，因此复杂度为O(1)\n\n**如果程序中的定时器数量比较少，基于最小堆的定时器一般可以满足需求，且实现简单。**\n\n### 时间轮\n时间轮的实质为哈希环`HashTable`,每个定时器任务根据对其`expireTime`哈希，得到对应的位置`index`，复杂度为`O(1)`\n![时间轮](http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png)\n\n**性能比较：**\n| 实现方式 |\tAddTimer\t| KillTimer\t | RunTimer|\n|-------- |------------| -----------| -----------|\n| 基于链表  |\tO(1)\t| O(n)\t| O(n)|\n|基于排序链表\t|O(n)\t|O(1)\t|O(1)|\n|基于最小堆     |\tO(lgn)|\tO(lgn)|\tO(1)|\n|基于时间轮\t|O(1)\t|O(1)\t|O(1)|\n\n\n*现在看起来我们选择时间轮来实现就行了，是否这样就完事了？*\n\n## 着重分析时间轮\n\n如果需要支持的定时器范围非常的大，上面的实现方式则不能满足这样的需求。因为这样将消耗非常可观的内存，假设需要表示的定时器范围为：0 – 2^3-1ticks，则简单时间轮需要 2^32 个元素空间，这对于内存空间的使用将非常的庞大。也许可以降低定时器的精度，使得每个 Tick 表示的时间更长一些，但这样的代价是定时器的精度将大打折扣。\n\n现在的问题是，度量定时器的粒度，只能使用唯一粒度吗？想想日常生活中常遇到的水表，如下图：\n![水表](https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image004.jpg)\n\n钟表：\n![水表](https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556440651&di=0c604969bfdf6b335dd78462f862743e&imgtype=jpg&er=1&src=http%3A%2F%2Famuseum.cdstm.cn%2FAMuseum%2Ftime%2F01gzsj%2Fimages%2F0102_b.jpg)\n\n分级时间轮同样如此，每级时间轮所代表的粒度精度都不一样，这样结合起来，既能够保证定时器的精度，也能以较小内存代价表示范围更大更多的定时器。\n\n**简单时间轮**： 一个齿轮，每个齿轮保存一个超时的node链表。一个齿轮表示一个时间刻度，比如钟表里面一小格代表一秒，钟表的秒针每次跳一格。假设一个刻度代表10ms，则2^32 个格子可表示1.36年，2^16个格子可表示10.9分钟。当要表示的时间范围较大时，空间复杂度会大幅增加。\n\n**分级时间轮**： 类似于水表，当小轮子里的指针转动满一圈后，上一级轮子的指针进一格。  采用五个轮子每个轮子为一个简单时间轮，大小分别为 2^8， 2^6， 2^6， 2^6， 2^6，所需空间：2^8 + 2^6 + 2^6 + 2^6 + 2^6 = 512， 可表示的范围为 0  --  2^8 * 2^6 * 2^6* 2^6* 2^6 = 2^32 。\n\n**分级时间轮简洁图**：\n![分级时间轮](http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png)\n\n*熟知的Linux系统内核，定时器实现方式就是分级时间轮*\n![Linux内核](https://images0.cnblogs.com/i/205989/201405/281755599318276.jpg)\n\n## 具体实现\nwheel_timer_mgr.h\n```cpp\nclass CWheelTimerModule;\nclass ITimerMgr;\nclass CWheelTimer;\n\ntypedef std::list<CWheelTimer*> TListTimer;\n\nenum ETimerType \n{ \n\tETIMER_ONCE, \n\tETIMER_CIRCLE \n};\n\n///定时器最小精度 1/10秒 （100毫秒）\nstatic const int  WHEEL_TIMER_MIN_PRECISION = 100;\n\n/**\n* @brief 基于分级的时间轮定时器, 精度约定为十分之一秒\n* 注意，注册的Timer精度必须为约定的精度倍数\n*/\nclass CWheelTimer\n{\npublic:\n\tCWheelTimer();\n\tCWheelTimer(CWheelTimerModule& oModule);\n\t~CWheelTimer();\n\n\t/**\n\t* @brief 启动定时器\n\t* @param nInterval: 传入的是毫秒, 约定必须是十分之一秒（100ms）的倍数\n\t* @return \n\t*/\n\tvoid Start(ITimerMgr* pITimer, unsigned int nId, unsigned nInterval, int nDelay, ETimerType eTimerType = ETIMER_CIRCLE);\n\n\t/**\n\t* @brief 停止定时器\n\t*/\n\tvoid Stop();\nprivate:\n\t/**\n\t* @brief 定时器被触发\n\t*/\n\tvoid OnTrigger(const UINT64 nNow);\n\nprivate:\n\tfriend class CWheelTimerModule;\n\n\tCWheelTimerModule&\t\tm_oModule;\n\tITimerMgr*\t\t\t\tm_pTimerMgr = nullptr;\n\tETimerType\t\t\t\tm_eTimerType;\n\tunsigned int\t\t\tm_nTimerId = 0;\n\tunsigned int\t\t\tm_nInterval = -1;    //ms\n\tunsigned long long\t\tm_llExpireTime = 0;  //ms\n\tint\t\t\t\t\t\tm_nVecIndex = 0;\n\tTListTimer::iterator\tm_listIter;\n};\n\n/**\n* @brief 定时器管理器接口， 派生类继承使用\n*/\nclass ITimerMgr\n{\npublic:\n\tvirtual\t\t  ~ITimerMgr();\n\tvirtual void  OnTimer(unsigned int nId) = 0;\n\t//interval 时间精度 ms\n\tvoid\t\t  SetTimer(unsigned int nId, int nInterval, int nDelay = 0, ETimerType eTimeType = ETIMER_CIRCLE);\n\tvoid\t\t  KillTimer(unsigned int nId);\n\tbool\t\t  IsTimerExist(unsigned int nId);;\n\nprotected:\n\tstd::unordered_map<unsigned int, CWheelTimer*> m_mapTimer;\n};\n\n/**\n* @brief 全局定时器管理模块， 负责管理所有的定时器\n*/\nclass CWheelTimerModule : public Storm::TSingleton<CWheelTimerModule>\n{\n\tfriend class Storm::TSingleton<CWheelTimerModule>;\n\tCWheelTimerModule();\npublic:\n\tvoid\t\t\tAddTimer(CWheelTimer* pTimer);\n\tvoid\t\t\tRemoveTimer(CWheelTimer* pTimer);\n\t/**\n\t* @brief 驱动所有的定时器\n\t*/\n\tvoid\t\t\tRun();\n\n\tstatic UINT64\tGetCurMillisecs();\n\t/**\n\t* @brief 修正精度 \n\t* @param nSrcTime \n\t* @return 传入的时间除以当前约定最小定时器精度\n\t*/\n\tstatic UINT64\tHandlePrecision(const UINT64 nSrcTime);\n\nprivate:\n\tint\t\t\t\t_Cascade(int nOffset, int nIndex);\n\nprivate:\n\tstd::vector<TListTimer>\t\tm_vecTimerList;\n\n\t//notice: precision=100ms not 1ms\n\tUINT64\t\t\t\t\t\tm_llCheckTime;\n};\n\n/**\n* @brief 定时器工厂 \n*/\nclass CTimerFactory: public Storm::TSingleton<CTimerFactory>, public CNoncopy\n{\n\tfriend class Storm::TSingleton<CTimerFactory>;\n\tCTimerFactory();\n\tvirtual\t\t\t~CTimerFactory();\npublic: \n\tCWheelTimer*\tCreateCTimer();\n\tvoid\t\t\tReleaseCTimer(CWheelTimer* pTimer);\nprivate:\n\n\tCSTObjectPool<CWheelTimer>    m_oCTimerPool;\n}\n```\n\nwheel_timer_mgr.cpp\n```cpp\n#if 0 \n\t#define TVN_BITS 6\n\t#define TVR_BITS 8\n\t#define TVN_SIZE (1 << TVN_BITS)\n\t#define TVR_SIZE (1 << TVR_BITS)\n\t#define TVN_MASK (TVN_SIZE - 1)\n\t#define TVR_MASK (TVR_SIZE - 1)\n\t#define OFFSET(N) (TVR_SIZE + (N) *TVN_SIZE)\n\t#define INDEX(V, N) ((V >> (TVR_BITS + (N) *TVN_BITS)) & TVN_MASK)\n#else \n\tstatic const int TVN_BITS = 6;\n\tstatic const int TVR_BITS = 8;\n\tstatic const int TVN_SIZE = (1 << TVN_BITS);\n\tstatic const int TVR_SIZE = (1 << TVR_BITS);\n\tstatic const int TVN_MASK = (TVN_SIZE - 1);\n\tstatic const int TVR_MASK = (TVR_SIZE - 1);\n\tint OFFSET(int N) { return (TVR_SIZE + (N)*TVN_SIZE); }\n\tint INDEX(unsigned long long V, int N)\n\t{\n\t\treturn ((V >> (TVR_BITS + (N)*TVN_BITS)) & TVN_MASK);\n\t}\n\n#endif\n\n\n\nCWheelTimer::CWheelTimer()\n\t:m_oModule(CWheelTimerModule::GetInstance())\n\t, m_nVecIndex(-1)\n{\n}\n\nCWheelTimer::CWheelTimer(CWheelTimerModule& oModule)\n\t: m_oModule(oModule)\n\t, m_nVecIndex(-1)\n{\n}\n\nCWheelTimer::~CWheelTimer()\n{\n\tStop();\n}\n\nvoid CWheelTimer::Start(ITimerMgr* pTimerMgr, unsigned int nId, unsigned nInterval, int nDelay, ETimerType eTimerType)\n{\n\tStop();\n\n\t//时间都修正为最小精度\n\tif (nInterval < WHEEL_TIMER_MIN_PRECISION)\n\t{\n\t\tnInterval = WHEEL_TIMER_MIN_PRECISION;\n\t}\n\n\tm_nInterval = CWheelTimerModule::HandlePrecision(nInterval);\n\tm_eTimerType = eTimerType;\n\tm_pTimerMgr = pTimerMgr;\n\tm_nTimerId = nId;\n\tm_llExpireTime = CWheelTimerModule::HandlePrecision(nDelay + CWheelTimerModule::GetCurMillisecs());\n\tm_oModule.AddTimer(this);\n}\n\n\nvoid CWheelTimer::Stop()\n{\n\tif (m_nVecIndex != -1)\n\t{\n\t\tm_oModule.RemoveTimer(this);\n\t\tm_nVecIndex = -1;\n\t}\n}\n\nvoid CWheelTimer::OnTrigger(const UINT64 nNow)\n{\n\tif (m_eTimerType == ETIMER_CIRCLE)\n\t{\n\t\tm_llExpireTime = m_nInterval + nNow;\n\t\tm_oModule.AddTimer(this);\n\t}\n\telse\n\t{\n\t\tm_nVecIndex = -1;\n\t}\n\n\tif (m_pTimerMgr != nullptr)\n\t{\n\t\tm_pTimerMgr->OnTimer(m_nTimerId);\n\t}\n}\n\n//--------------------------------------------------------------------------------------------------------\n\nCWheelTimerModule::CWheelTimerModule()\n{\n\tm_vecTimerList.resize(TVR_SIZE + 4 * TVN_SIZE);\n\tm_llCheckTime = HandlePrecision(GetCurMillisecs());\n}\n\nvoid CWheelTimerModule::AddTimer(CWheelTimer* pTimer)\n{\n\tUINT64 llExpireTime = pTimer->m_llExpireTime;\n\tINT64 llTimeDiff = pTimer->m_llExpireTime - m_llCheckTime;\n\n\tif (llTimeDiff < 0)\n\t{\n\t\tpTimer->m_nVecIndex = m_llCheckTime & TVR_MASK;\n\t}\n\telse if (llTimeDiff < TVR_SIZE)\n\t{\n\t\tpTimer->m_nVecIndex = llExpireTime & TVR_MASK;\n\t}\n\telse if (llTimeDiff < 1 << (TVR_BITS + TVN_BITS))\n\t{\n\t\tpTimer->m_nVecIndex = OFFSET(0) + INDEX(llExpireTime, 0);\n\t}\n\telse if (llTimeDiff < 1 << (TVR_BITS + 2 * TVN_BITS))\n\t{\n\t\tpTimer->m_nVecIndex = OFFSET(1) + INDEX(llExpireTime, 1);\n\t}\n\telse if (llTimeDiff < 1 << (TVR_BITS + 3 * TVN_BITS))\n\t{\n\t\tpTimer->m_nVecIndex = OFFSET(2) + INDEX(llExpireTime, 2);\n\t}\n\telse\n\t{\n\t\tif (llTimeDiff > 0xffffffffUL)\n\t\t{\n\t\t\tllTimeDiff = 0xffffffffUL;\n\t\t\tllExpireTime = llTimeDiff + m_llCheckTime;\n\t\t}\n\t\tpTimer->m_nVecIndex = OFFSET(3) + INDEX(llExpireTime, 3);\n\t}\n\n\tTListTimer& listTimer = m_vecTimerList[pTimer->m_nVecIndex];\n\tlistTimer.push_back(pTimer);\n\tpTimer->m_listIter = listTimer.end();\n\t--pTimer->m_listIter;\n}\n\nvoid CWheelTimerModule::RemoveTimer(CWheelTimer* pTimer)\n{\n\tTListTimer& listTimer = m_vecTimerList[pTimer->m_nVecIndex];\n\tlistTimer.erase(pTimer->m_listIter);\n}\n\nvoid CWheelTimerModule::Run()\n{\n\tUINT64 nNow = HandlePrecision(GetCurMillisecs());\n\twhile (m_llCheckTime <= nNow)\n\t{\n\t\t//for every tick\n\t\tint index = m_llCheckTime & TVR_MASK;\n\t\tif (!index &&\n\t\t\t!_Cascade(OFFSET(0), INDEX(m_llCheckTime, 0)) &&\n\t\t\t!_Cascade(OFFSET(1), INDEX(m_llCheckTime, 1)) &&\n\t\t\t!_Cascade(OFFSET(2), INDEX(m_llCheckTime, 2)))\n\t\t{\n\t\t\t_Cascade(OFFSET(3), INDEX(m_llCheckTime, 3));\n\t\t}\n\n\t\t\n\t\t++m_llCheckTime;\n\n\t\tTListTimer& listTimer = m_vecTimerList[index];\n\t\tTListTimer listTmp;\n\t\tlistTmp.splice(listTmp.end(), listTimer);\n\t\tfor (auto itr = listTmp.begin(); itr != listTmp.end(); ++itr)\n\t\t{\n\t\t\tauto* pTimer = *itr;\n\t\t\tif (pTimer != nullptr)\n\t\t\t{\n\t\t\t\tpTimer->OnTrigger(nNow);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint CWheelTimerModule::_Cascade(int nOffset, int nIndex)\n{\n\tTListTimer& listTimer = m_vecTimerList[nOffset + nIndex];\n\tTListTimer listTemp;\n\tlistTemp.splice(listTemp.end(), listTimer);\n\n\tfor (auto itr = listTemp.begin(); itr != listTemp.end(); ++itr)\n\t{\n\t\tauto* pTimer = *itr;\n\t\tif (pTimer != nullptr)\n\t\t{\n\t\t\tAddTimer(pTimer);\n\t\t}\n\t}\n\n\treturn nIndex;\n}\n\nUINT64 CWheelTimerModule::HandlePrecision(const UINT64 nSrcTime)\n{\n\treturn nSrcTime / WHEEL_TIMER_MIN_PRECISION;\n}\n\nUINT64 CWheelTimerModule::GetCurMillisecs()\n{\n\tauto llCurTime = CSysTime::Instance()->GetNowMliTime();\n\treturn llCurTime;\n}\n\nITimerMgr::~ITimerMgr()\n{\n\tfor (auto it : m_mapTimer)\n\t{\n\t\tif (it.second != nullptr)\n\t\t{\n\t\t\tit.second->Stop();\n\t\t\tCTimerFactory::Instance()->ReleaseCTimer(it.second);\n\t\t}\n\t}\n\tm_mapTimer.clear();\n}\n\nvoid ITimerMgr::SetTimer(unsigned int nId, int nInterval, int nDelay ,ETimerType eTimeType)\n{\n\tif (IsTimerExist(nId))\n\t{\n\t\tEXLOG_DEBUG << \"[RyzTimer]Timer Has Existed, Not Repeat Add, nId:\" << nId;\n\t\treturn;\n\t}\n\n\tCWheelTimer* pTimer = CTimerFactory::Instance()->CreateCTimer();\n\tif (nullptr == pTimer)\n\t{\n\t\treturn;\n\t}\n\n\tm_mapTimer[nId] = pTimer;\n\tpTimer->Start(this, nId, nInterval, nDelay, eTimeType);\n\tEXLOG_DEBUG << \"[RyzTimer]Add Timer nId:\" << nId << \",nInterval:\" << nInterval << \",nDelay:\" << nDelay << \",eTimeType:\" << eTimeType;\n}\n\nvoid ITimerMgr::KillTimer(unsigned int nId)\n{\n\tauto it = m_mapTimer.find(nId);\n\tif (it != m_mapTimer.end())\n\t{\n\t\t// 释放后 在TimerManager中 不会再执行 不需要做其他的操作\n\t\tit->second->Stop();\n\t\tCTimerFactory::Instance()->ReleaseCTimer(it->second);\n\t\tm_mapTimer.erase(it);\n\t}\n}\n\nbool ITimerMgr::IsTimerExist(unsigned int nId) \n{ \n\treturn m_mapTimer.find(nId) != m_mapTimer.end(); \n}\n\nCTimerFactory::CTimerFactory()\n{\n\tm_oCTimerPool.Init(32, 8);\n}\n\nCTimerFactory::~CTimerFactory()\n{\n}\n\nCWheelTimer * CTimerFactory::CreateCTimer()\n{\n\tCWheelTimer* pTimer = m_oCTimerPool.FetchObj();\n\treturn pTimer;\n}\n\nvoid CTimerFactory::ReleaseCTimer(CWheelTimer* pTimer)\n{\n\tif (nullptr != pTimer)\n\t{\n\t\tm_oCTimerPool.ReleaseObj(pTimer);\n\t}\n}\n\n\n```","slug":"深入浅出时间轮Timer定时器","published":1,"updated":"2020-01-23T07:12:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzg5000tokece4l989y0","content":"<h2 id=\"说点废话\"><a href=\"#说点废话\" class=\"headerlink\" title=\"说点废话\"></a>说点废话</h2><blockquote>\n<p>不管是客户端<code>Client</code>还是服务器<code>Server</code>，不论你是从事游戏行业还是互联网行业，在技术上总会涉及到定时器。虽然有的框架系统已经帮你实现，并且提供完美API供你使用，但你真的了解定时器吗？我们不仅要知道如何使用正确的Timer，还得明白定时器的实现原理，要知其所以然。  </p>\n</blockquote>\n<h2 id=\"理解定时器\"><a href=\"#理解定时器\" class=\"headerlink\" title=\"理解定时器\"></a>理解定时器</h2><p>使用者角度分类：</p>\n<ol>\n<li><p>周期性定时器</p>\n<ol>\n<li>使用 <code>TCP</code> 长连接时，客户端需要定时向服务端发送心跳请求</li>\n<li>游戏内系统每日重置功能</li>\n<li>体力回复</li>\n<li>….</li>\n</ol>\n</li>\n<li><p>非周期性定时器</p>\n<ol>\n<li>玩法活动定时开启、关闭</li>\n<li>…</li>\n</ol>\n</li>\n</ol>\n<p><strong>当然，大部分非周期性定时器都可以使用周期性定时器实现，即执行一次后立即调用Remove接口即可</strong></p>\n<p>定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：<strong>存储一系列的任务集合，并且 <code>Deadline</code> 越接近的任务，拥有越高的执行优先级</strong></p>\n<p>支持以下几种操作：</p>\n<ol>\n<li><code>Add New TimerTask</code> 添加新的定时器</li>\n<li><code>Kill Or Remove TimerTask</code> 取消或者移除既有定时器任务</li>\n<li><code>Run</code> 执行</li>\n</ol>\n<p>判断一个<code>TimerTask</code>是否到期，基本会采用轮询的方式，每隔一个<strong>时间片</strong><code>tickDuration</code>去检查最近的任务是否到期。</p>\n<blockquote>\n<p><strong>说到底，定时器还是靠线程轮询实现的。</strong></p>\n</blockquote>\n<p>现在知道<code>Timer</code>是靠轮询来实现的，那么中间应该采用那种数据结构呢？采用不同的数据结构实现，其性能也大不一样！<br>现在主要有如下几种：<code>List</code>链表、<code>Heap</code>最小堆、时间轮、分级时间轮，其中时间轮的实质为Hash表。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"双向有序链表\"><a href=\"#双向有序链表\" class=\"headerlink\" title=\"双向有序链表\"></a>双向有序链表</h3><p><code>AddTimer O(N) </code>很容易理解，按照 <code>expireTime</code> 查找合适的位置即可；<code>KillTimer O(1)</code> ，任务在 <code>Kill</code> 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除;<code>RunTimer O(1)</code>，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。</p>\n<h3 id=\"最小堆\"><a href=\"#最小堆\" class=\"headerlink\" title=\"最小堆\"></a>最小堆</h3><p>最小堆指的是满足除了根节点以外的每个节点都不小于其父节点的堆。这样，堆中的最小值就存放在根节点中，并且在以某个结点为根的子树中，各节点的值都不小于该子树根节点的值。一个最小堆的例子如下图：<br><img src=\"https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image002.jpg\" alt=\"最小堆\"></p>\n<p>明显的，最小堆添加新元素或者删除节点效率为<code>O(lgn)</code>, <code>root</code>节点<code>expireTime</code>最小，执行优先级最高，因此复杂度为O(1)</p>\n<p><strong>如果程序中的定时器数量比较少，基于最小堆的定时器一般可以满足需求，且实现简单。</strong></p>\n<h3 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"时间轮\"></a>时间轮</h3><p>时间轮的实质为哈希环<code>HashTable</code>,每个定时器任务根据对其<code>expireTime</code>哈希，得到对应的位置<code>index</code>，复杂度为<code>O(1)</code><br><img src=\"http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png\" alt=\"时间轮\"></p>\n<p><strong>性能比较：</strong></p>\n<table>\n<thead>\n<tr>\n<th>实现方式</th>\n<th>AddTimer</th>\n<th>KillTimer</th>\n<th>RunTimer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基于链表</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>基于排序链表</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>基于最小堆</td>\n<td>O(lgn)</td>\n<td>O(lgn)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>基于时间轮</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n</tbody></table>\n<p><em>现在看起来我们选择时间轮来实现就行了，是否这样就完事了？</em></p>\n<h2 id=\"着重分析时间轮\"><a href=\"#着重分析时间轮\" class=\"headerlink\" title=\"着重分析时间轮\"></a>着重分析时间轮</h2><p>如果需要支持的定时器范围非常的大，上面的实现方式则不能满足这样的需求。因为这样将消耗非常可观的内存，假设需要表示的定时器范围为：0 – 2^3-1ticks，则简单时间轮需要 2^32 个元素空间，这对于内存空间的使用将非常的庞大。也许可以降低定时器的精度，使得每个 Tick 表示的时间更长一些，但这样的代价是定时器的精度将大打折扣。</p>\n<p>现在的问题是，度量定时器的粒度，只能使用唯一粒度吗？想想日常生活中常遇到的水表，如下图：<br><img src=\"https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image004.jpg\" alt=\"水表\"></p>\n<p>钟表：<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556440651&di=0c604969bfdf6b335dd78462f862743e&imgtype=jpg&er=1&src=http://amuseum.cdstm.cn/AMuseum/time/01gzsj/images/0102_b.jpg\" alt=\"水表\"></p>\n<p>分级时间轮同样如此，每级时间轮所代表的粒度精度都不一样，这样结合起来，既能够保证定时器的精度，也能以较小内存代价表示范围更大更多的定时器。</p>\n<p><strong>简单时间轮</strong>： 一个齿轮，每个齿轮保存一个超时的node链表。一个齿轮表示一个时间刻度，比如钟表里面一小格代表一秒，钟表的秒针每次跳一格。假设一个刻度代表10ms，则2^32 个格子可表示1.36年，2^16个格子可表示10.9分钟。当要表示的时间范围较大时，空间复杂度会大幅增加。</p>\n<p><strong>分级时间轮</strong>： 类似于水表，当小轮子里的指针转动满一圈后，上一级轮子的指针进一格。  采用五个轮子每个轮子为一个简单时间轮，大小分别为 2^8， 2^6， 2^6， 2^6， 2^6，所需空间：2^8 + 2^6 + 2^6 + 2^6 + 2^6 &#x3D; 512， 可表示的范围为 0  –  2^8 * 2^6 * 2^6* 2^6* 2^6 &#x3D; 2^32 。</p>\n<p><strong>分级时间轮简洁图</strong>：<br><img src=\"http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png\" alt=\"分级时间轮\"></p>\n<p><em>熟知的Linux系统内核，定时器实现方式就是分级时间轮</em><br><img src=\"https://images0.cnblogs.com/i/205989/201405/281755599318276.jpg\" alt=\"Linux内核\"></p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>wheel_timer_mgr.h</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimerModule</span>;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ITimerMgr</span>;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimer</span>;\n\n<span class=\"hljs-keyword\">typedef</span> std::list&lt;CWheelTimer*&gt; TListTimer;\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">ETimerType</span> \n&#123; \n    ETIMER_ONCE, \n    ETIMER_CIRCLE \n&#125;;\n\n<span class=\"hljs-comment\">///定时器最小精度 1/10秒 （100毫秒）</span>\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>  WHEEL_TIMER_MIN_PRECISION = <span class=\"hljs-number\">100</span>;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 基于分级的时间轮定时器, 精度约定为十分之一秒</span>\n<span class=\"hljs-comment\">* 注意，注册的Timer精度必须为约定的精度倍数</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimer</span>\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">CWheelTimer</span>();\n    <span class=\"hljs-built_in\">CWheelTimer</span>(CWheelTimerModule&amp; oModule);\n    ~<span class=\"hljs-built_in\">CWheelTimer</span>();\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 启动定时器</span>\n<span class=\"hljs-comment\">    * @param nInterval: 传入的是毫秒, 约定必须是十分之一秒（100ms）的倍数</span>\n<span class=\"hljs-comment\">    * @return </span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Start</span><span class=\"hljs-params\">(ITimerMgr* pITimer, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">unsigned</span> nInterval, <span class=\"hljs-type\">int</span> nDelay, ETimerType eTimerType = ETIMER_CIRCLE)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 停止定时器</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Stop</span><span class=\"hljs-params\">()</span></span>;\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 定时器被触发</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnTrigger</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nNow)</span></span>;\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimerModule</span>;\n\n    CWheelTimerModule&amp;\t\tm_oModule;\n    ITimerMgr*\t\t\t\tm_pTimerMgr = <span class=\"hljs-literal\">nullptr</span>;\n    ETimerType\t\t\t\tm_eTimerType;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>\t\t\tm_nTimerId = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>\t\t\tm_nInterval = <span class=\"hljs-number\">-1</span>;    <span class=\"hljs-comment\">//ms</span>\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span>\t\tm_llExpireTime = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">//ms</span>\n    <span class=\"hljs-type\">int</span>\t\t\t\t\t\tm_nVecIndex = <span class=\"hljs-number\">0</span>;\n    TListTimer::iterator\tm_listIter;\n&#125;;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 定时器管理器接口， 派生类继承使用</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ITimerMgr</span>\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-keyword\">virtual</span>\t\t  ~<span class=\"hljs-built_in\">ITimerMgr</span>();\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">OnTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span> </span>= <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">//interval 时间精度 ms</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t  <span class=\"hljs-title\">SetTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">int</span> nInterval, <span class=\"hljs-type\">int</span> nDelay = <span class=\"hljs-number\">0</span>, ETimerType eTimeType = ETIMER_CIRCLE)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t  <span class=\"hljs-title\">KillTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span>\t\t  <span class=\"hljs-title\">IsTimerExist</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>;;\n\n<span class=\"hljs-keyword\">protected</span>:\n    std::unordered_map&lt;<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>, CWheelTimer*&gt; m_mapTimer;\n&#125;;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 全局定时器管理模块， 负责管理所有的定时器</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimerModule</span> : <span class=\"hljs-keyword\">public</span> Storm::TSingleton&lt;CWheelTimerModule&gt;\n&#123;\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Storm</span>::TSingleton&lt;CWheelTimerModule&gt;;\n    <span class=\"hljs-built_in\">CWheelTimerModule</span>();\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">AddTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">RemoveTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 驱动所有的定时器</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">Run</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> UINT64\t<span class=\"hljs-title\">GetCurMillisecs</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 修正精度 </span>\n<span class=\"hljs-comment\">    * @param nSrcTime </span>\n<span class=\"hljs-comment\">    * @return 传入的时间除以当前约定最小定时器精度</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> UINT64\t<span class=\"hljs-title\">HandlePrecision</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nSrcTime)</span></span>;\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-type\">int</span>\t\t\t\t_Cascade(<span class=\"hljs-type\">int</span> nOffset, <span class=\"hljs-type\">int</span> nIndex);\n\n<span class=\"hljs-keyword\">private</span>:\n    std::vector&lt;TListTimer&gt;\t\tm_vecTimerList;\n\n    <span class=\"hljs-comment\">//notice: precision=100ms not 1ms</span>\n    UINT64\t\t\t\t\t\tm_llCheckTime;\n&#125;;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 定时器工厂 </span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CTimerFactory</span>: <span class=\"hljs-keyword\">public</span> Storm::TSingleton&lt;CTimerFactory&gt;, <span class=\"hljs-keyword\">public</span> CNoncopy\n&#123;\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Storm</span>::TSingleton&lt;CTimerFactory&gt;;\n    <span class=\"hljs-built_in\">CTimerFactory</span>();\n    <span class=\"hljs-keyword\">virtual</span>\t\t\t~<span class=\"hljs-built_in\">CTimerFactory</span>();\n<span class=\"hljs-keyword\">public</span>: \n    <span class=\"hljs-function\">CWheelTimer*\t<span class=\"hljs-title\">CreateCTimer</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">ReleaseCTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>;\n<span class=\"hljs-keyword\">private</span>:\n\n    CSTObjectPool&lt;CWheelTimer&gt;    m_oCTimerPool;\n&#125;</code></pre>\n\n<p>wheel_timer_mgr.cpp</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> 0 </span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVN_BITS 6</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVR_BITS 8</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVN_SIZE (1 &lt;&lt; TVN_BITS)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVR_SIZE (1 &lt;&lt; TVR_BITS)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVN_MASK (TVN_SIZE - 1)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVR_MASK (TVR_SIZE - 1)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> OFFSET(N) (TVR_SIZE + (N) *TVN_SIZE)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INDEX(V, N) ((V &gt;&gt; (TVR_BITS + (N) *TVN_BITS)) &amp; TVN_MASK)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span> </span>\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVN_BITS = <span class=\"hljs-number\">6</span>;\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVR_BITS = <span class=\"hljs-number\">8</span>;\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVN_SIZE = (<span class=\"hljs-number\">1</span> &lt;&lt; TVN_BITS);\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVR_SIZE = (<span class=\"hljs-number\">1</span> &lt;&lt; TVR_BITS);\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVN_MASK = (TVN_SIZE - <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVR_MASK = (TVR_SIZE - <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">OFFSET</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> N)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> (TVR_SIZE + (N)*TVN_SIZE); &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">INDEX</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> V, <span class=\"hljs-type\">int</span> N)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> ((V &gt;&gt; (TVR_BITS + (N)*TVN_BITS)) &amp; TVN_MASK);\n    &#125;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n\n\nCWheelTimer::<span class=\"hljs-built_in\">CWheelTimer</span>()\n    :<span class=\"hljs-built_in\">m_oModule</span>(CWheelTimerModule::<span class=\"hljs-built_in\">GetInstance</span>())\n    , <span class=\"hljs-built_in\">m_nVecIndex</span>(<span class=\"hljs-number\">-1</span>)\n&#123;\n&#125;\n\nCWheelTimer::<span class=\"hljs-built_in\">CWheelTimer</span>(CWheelTimerModule&amp; oModule)\n    : <span class=\"hljs-built_in\">m_oModule</span>(oModule)\n    , <span class=\"hljs-built_in\">m_nVecIndex</span>(<span class=\"hljs-number\">-1</span>)\n&#123;\n&#125;\n\nCWheelTimer::~<span class=\"hljs-built_in\">CWheelTimer</span>()\n&#123;\n    <span class=\"hljs-built_in\">Stop</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimer::Start</span><span class=\"hljs-params\">(ITimerMgr* pTimerMgr, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">unsigned</span> nInterval, <span class=\"hljs-type\">int</span> nDelay, ETimerType eTimerType)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-built_in\">Stop</span>();\n\n    <span class=\"hljs-comment\">//时间都修正为最小精度</span>\n    <span class=\"hljs-keyword\">if</span> (nInterval &lt; WHEEL_TIMER_MIN_PRECISION)\n    &#123;\n        nInterval = WHEEL_TIMER_MIN_PRECISION;\n    &#125;\n\n    m_nInterval = CWheelTimerModule::<span class=\"hljs-built_in\">HandlePrecision</span>(nInterval);\n    m_eTimerType = eTimerType;\n    m_pTimerMgr = pTimerMgr;\n    m_nTimerId = nId;\n    m_llExpireTime = CWheelTimerModule::<span class=\"hljs-built_in\">HandlePrecision</span>(nDelay + CWheelTimerModule::<span class=\"hljs-built_in\">GetCurMillisecs</span>());\n    m_oModule.<span class=\"hljs-built_in\">AddTimer</span>(<span class=\"hljs-keyword\">this</span>);\n&#125;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimer::Stop</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (m_nVecIndex != <span class=\"hljs-number\">-1</span>)\n    &#123;\n        m_oModule.<span class=\"hljs-built_in\">RemoveTimer</span>(<span class=\"hljs-keyword\">this</span>);\n        m_nVecIndex = <span class=\"hljs-number\">-1</span>;\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimer::OnTrigger</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nNow)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (m_eTimerType == ETIMER_CIRCLE)\n    &#123;\n        m_llExpireTime = m_nInterval + nNow;\n        m_oModule.<span class=\"hljs-built_in\">AddTimer</span>(<span class=\"hljs-keyword\">this</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        m_nVecIndex = <span class=\"hljs-number\">-1</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (m_pTimerMgr != <span class=\"hljs-literal\">nullptr</span>)\n    &#123;\n        m_pTimerMgr-&gt;<span class=\"hljs-built_in\">OnTimer</span>(m_nTimerId);\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">//--------------------------------------------------------------------------------------------------------</span>\n\nCWheelTimerModule::<span class=\"hljs-built_in\">CWheelTimerModule</span>()\n&#123;\n    m_vecTimerList.<span class=\"hljs-built_in\">resize</span>(TVR_SIZE + <span class=\"hljs-number\">4</span> * TVN_SIZE);\n    m_llCheckTime = <span class=\"hljs-built_in\">HandlePrecision</span>(<span class=\"hljs-built_in\">GetCurMillisecs</span>());\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimerModule::AddTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    UINT64 llExpireTime = pTimer-&gt;m_llExpireTime;\n    INT64 llTimeDiff = pTimer-&gt;m_llExpireTime - m_llCheckTime;\n\n    <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">0</span>)\n    &#123;\n        pTimer-&gt;m_nVecIndex = m_llCheckTime &amp; TVR_MASK;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; TVR_SIZE)\n    &#123;\n        pTimer-&gt;m_nVecIndex = llExpireTime &amp; TVR_MASK;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">1</span> &lt;&lt; (TVR_BITS + TVN_BITS))\n    &#123;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">0</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">1</span> &lt;&lt; (TVR_BITS + <span class=\"hljs-number\">2</span> * TVN_BITS))\n    &#123;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">1</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">1</span> &lt;&lt; (TVR_BITS + <span class=\"hljs-number\">3</span> * TVN_BITS))\n    &#123;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">2</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">2</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-keyword\">if</span> (llTimeDiff &gt; <span class=\"hljs-number\">0xffffffff</span>UL)\n        &#123;\n            llTimeDiff = <span class=\"hljs-number\">0xffffffff</span>UL;\n            llExpireTime = llTimeDiff + m_llCheckTime;\n        &#125;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">3</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">3</span>);\n    &#125;\n\n    TListTimer&amp; listTimer = m_vecTimerList[pTimer-&gt;m_nVecIndex];\n    listTimer.<span class=\"hljs-built_in\">push_back</span>(pTimer);\n    pTimer-&gt;m_listIter = listTimer.<span class=\"hljs-built_in\">end</span>();\n    --pTimer-&gt;m_listIter;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimerModule::RemoveTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    TListTimer&amp; listTimer = m_vecTimerList[pTimer-&gt;m_nVecIndex];\n    listTimer.<span class=\"hljs-built_in\">erase</span>(pTimer-&gt;m_listIter);\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimerModule::Run</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    UINT64 nNow = <span class=\"hljs-built_in\">HandlePrecision</span>(<span class=\"hljs-built_in\">GetCurMillisecs</span>());\n    <span class=\"hljs-keyword\">while</span> (m_llCheckTime &lt;= nNow)\n    &#123;\n        <span class=\"hljs-comment\">//for every tick</span>\n        <span class=\"hljs-type\">int</span> index = m_llCheckTime &amp; TVR_MASK;\n        <span class=\"hljs-keyword\">if</span> (!index &amp;&amp;\n            !_Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">0</span>)) &amp;&amp;\n            !_Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">1</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">1</span>)) &amp;&amp;\n            !_Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">2</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">2</span>)))\n        &#123;\n            _Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">3</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">3</span>));\n        &#125;\n\n        \n        ++m_llCheckTime;\n\n        TListTimer&amp; listTimer = m_vecTimerList[index];\n        TListTimer listTmp;\n        listTmp.<span class=\"hljs-built_in\">splice</span>(listTmp.<span class=\"hljs-built_in\">end</span>(), listTimer);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> itr = listTmp.<span class=\"hljs-built_in\">begin</span>(); itr != listTmp.<span class=\"hljs-built_in\">end</span>(); ++itr)\n        &#123;\n            <span class=\"hljs-keyword\">auto</span>* pTimer = *itr;\n            <span class=\"hljs-keyword\">if</span> (pTimer != <span class=\"hljs-literal\">nullptr</span>)\n            &#123;\n                pTimer-&gt;<span class=\"hljs-built_in\">OnTrigger</span>(nNow);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"hljs-type\">int</span> CWheelTimerModule::_Cascade(<span class=\"hljs-type\">int</span> nOffset, <span class=\"hljs-type\">int</span> nIndex)\n&#123;\n    TListTimer&amp; listTimer = m_vecTimerList[nOffset + nIndex];\n    TListTimer listTemp;\n    listTemp.<span class=\"hljs-built_in\">splice</span>(listTemp.<span class=\"hljs-built_in\">end</span>(), listTimer);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> itr = listTemp.<span class=\"hljs-built_in\">begin</span>(); itr != listTemp.<span class=\"hljs-built_in\">end</span>(); ++itr)\n    &#123;\n        <span class=\"hljs-keyword\">auto</span>* pTimer = *itr;\n        <span class=\"hljs-keyword\">if</span> (pTimer != <span class=\"hljs-literal\">nullptr</span>)\n        &#123;\n            <span class=\"hljs-built_in\">AddTimer</span>(pTimer);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> nIndex;\n&#125;\n\n<span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">CWheelTimerModule::HandlePrecision</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nSrcTime)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">return</span> nSrcTime / WHEEL_TIMER_MIN_PRECISION;\n&#125;\n\n<span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">CWheelTimerModule::GetCurMillisecs</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">auto</span> llCurTime = CSysTime::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">GetNowMliTime</span>();\n    <span class=\"hljs-keyword\">return</span> llCurTime;\n&#125;\n\nITimerMgr::~<span class=\"hljs-built_in\">ITimerMgr</span>()\n&#123;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : m_mapTimer)\n    &#123;\n        <span class=\"hljs-keyword\">if</span> (it.second != <span class=\"hljs-literal\">nullptr</span>)\n        &#123;\n            it.second-&gt;<span class=\"hljs-built_in\">Stop</span>();\n            CTimerFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">ReleaseCTimer</span>(it.second);\n        &#125;\n    &#125;\n    m_mapTimer.<span class=\"hljs-built_in\">clear</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ITimerMgr::SetTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">int</span> nInterval, <span class=\"hljs-type\">int</span> nDelay ,ETimerType eTimeType)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">IsTimerExist</span>(nId))\n    &#123;\n        EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzTimer]Timer Has Existed, Not Repeat Add, nId:&quot;</span> &lt;&lt; nId;\n        <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    CWheelTimer* pTimer = CTimerFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">CreateCTimer</span>();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">nullptr</span> == pTimer)\n    &#123;\n        <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    m_mapTimer[nId] = pTimer;\n    pTimer-&gt;<span class=\"hljs-built_in\">Start</span>(<span class=\"hljs-keyword\">this</span>, nId, nInterval, nDelay, eTimeType);\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzTimer]Add Timer nId:&quot;</span> &lt;&lt; nId &lt;&lt; <span class=\"hljs-string\">&quot;,nInterval:&quot;</span> &lt;&lt; nInterval &lt;&lt; <span class=\"hljs-string\">&quot;,nDelay:&quot;</span> &lt;&lt; nDelay &lt;&lt; <span class=\"hljs-string\">&quot;,eTimeType:&quot;</span> &lt;&lt; eTimeType;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ITimerMgr::KillTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">auto</span> it = m_mapTimer.<span class=\"hljs-built_in\">find</span>(nId);\n    <span class=\"hljs-keyword\">if</span> (it != m_mapTimer.<span class=\"hljs-built_in\">end</span>())\n    &#123;\n        <span class=\"hljs-comment\">// 释放后 在TimerManager中 不会再执行 不需要做其他的操作</span>\n        it-&gt;second-&gt;<span class=\"hljs-built_in\">Stop</span>();\n        CTimerFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">ReleaseCTimer</span>(it-&gt;second);\n        m_mapTimer.<span class=\"hljs-built_in\">erase</span>(it);\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">ITimerMgr::IsTimerExist</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span> </span>\n<span class=\"hljs-function\"></span>&#123; \n    <span class=\"hljs-keyword\">return</span> m_mapTimer.<span class=\"hljs-built_in\">find</span>(nId) != m_mapTimer.<span class=\"hljs-built_in\">end</span>(); \n&#125;\n\nCTimerFactory::<span class=\"hljs-built_in\">CTimerFactory</span>()\n&#123;\n    m_oCTimerPool.<span class=\"hljs-built_in\">Init</span>(<span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">8</span>);\n&#125;\n\nCTimerFactory::~<span class=\"hljs-built_in\">CTimerFactory</span>()\n&#123;\n&#125;\n\n<span class=\"hljs-function\">CWheelTimer * <span class=\"hljs-title\">CTimerFactory::CreateCTimer</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CWheelTimer* pTimer = m_oCTimerPool.<span class=\"hljs-built_in\">FetchObj</span>();\n    <span class=\"hljs-keyword\">return</span> pTimer;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CTimerFactory::ReleaseCTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">nullptr</span> != pTimer)\n    &#123;\n        m_oCTimerPool.<span class=\"hljs-built_in\">ReleaseObj</span>(pTimer);\n    &#125;\n&#125;\n\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"说点废话\"><a href=\"#说点废话\" class=\"headerlink\" title=\"说点废话\"></a>说点废话</h2><blockquote>\n<p>不管是客户端<code>Client</code>还是服务器<code>Server</code>，不论你是从事游戏行业还是互联网行业，在技术上总会涉及到定时器。虽然有的框架系统已经帮你实现，并且提供完美API供你使用，但你真的了解定时器吗？我们不仅要知道如何使用正确的Timer，还得明白定时器的实现原理，要知其所以然。  </p>\n</blockquote>\n<h2 id=\"理解定时器\"><a href=\"#理解定时器\" class=\"headerlink\" title=\"理解定时器\"></a>理解定时器</h2><p>使用者角度分类：</p>\n<ol>\n<li><p>周期性定时器</p>\n<ol>\n<li>使用 <code>TCP</code> 长连接时，客户端需要定时向服务端发送心跳请求</li>\n<li>游戏内系统每日重置功能</li>\n<li>体力回复</li>\n<li>….</li>\n</ol>\n</li>\n<li><p>非周期性定时器</p>\n<ol>\n<li>玩法活动定时开启、关闭</li>\n<li>…</li>\n</ol>\n</li>\n</ol>\n<p><strong>当然，大部分非周期性定时器都可以使用周期性定时器实现，即执行一次后立即调用Remove接口即可</strong></p>\n<p>定时器像水和空气一般，普遍存在于各个场景中，一般定时任务的形式表现为：经过固定时间后触发、按照固定频率周期性触发、在某个时刻触发。定时器是什么？可以理解为这样一个数据结构：<strong>存储一系列的任务集合，并且 <code>Deadline</code> 越接近的任务，拥有越高的执行优先级</strong></p>\n<p>支持以下几种操作：</p>\n<ol>\n<li><code>Add New TimerTask</code> 添加新的定时器</li>\n<li><code>Kill Or Remove TimerTask</code> 取消或者移除既有定时器任务</li>\n<li><code>Run</code> 执行</li>\n</ol>\n<p>判断一个<code>TimerTask</code>是否到期，基本会采用轮询的方式，每隔一个<strong>时间片</strong><code>tickDuration</code>去检查最近的任务是否到期。</p>\n<blockquote>\n<p><strong>说到底，定时器还是靠线程轮询实现的。</strong></p>\n</blockquote>\n<p>现在知道<code>Timer</code>是靠轮询来实现的，那么中间应该采用那种数据结构呢？采用不同的数据结构实现，其性能也大不一样！<br>现在主要有如下几种：<code>List</code>链表、<code>Heap</code>最小堆、时间轮、分级时间轮，其中时间轮的实质为Hash表。</p>\n<h2 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h2><h3 id=\"双向有序链表\"><a href=\"#双向有序链表\" class=\"headerlink\" title=\"双向有序链表\"></a>双向有序链表</h3><p><code>AddTimer O(N) </code>很容易理解，按照 <code>expireTime</code> 查找合适的位置即可；<code>KillTimer O(1)</code> ，任务在 <code>Kill</code> 时，会持有自己节点的引用，所以不需要查找其在链表中所在的位置，即可实现当前节点的删除;<code>RunTimer O(1)</code>，由于整个双向链表是基于 expireTime 有序的，所以调度器只需要轮询第一个任务即可。</p>\n<h3 id=\"最小堆\"><a href=\"#最小堆\" class=\"headerlink\" title=\"最小堆\"></a>最小堆</h3><p>最小堆指的是满足除了根节点以外的每个节点都不小于其父节点的堆。这样，堆中的最小值就存放在根节点中，并且在以某个结点为根的子树中，各节点的值都不小于该子树根节点的值。一个最小堆的例子如下图：<br><img src=\"https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image002.jpg\" alt=\"最小堆\"></p>\n<p>明显的，最小堆添加新元素或者删除节点效率为<code>O(lgn)</code>, <code>root</code>节点<code>expireTime</code>最小，执行优先级最高，因此复杂度为O(1)</p>\n<p><strong>如果程序中的定时器数量比较少，基于最小堆的定时器一般可以满足需求，且实现简单。</strong></p>\n<h3 id=\"时间轮\"><a href=\"#时间轮\" class=\"headerlink\" title=\"时间轮\"></a>时间轮</h3><p>时间轮的实质为哈希环<code>HashTable</code>,每个定时器任务根据对其<code>expireTime</code>哈希，得到对应的位置<code>index</code>，复杂度为<code>O(1)</code><br><img src=\"http://kirito.iocoder.cn/201807171109599678a80c-075a-40ee-b25f-10fd82c1025c.png\" alt=\"时间轮\"></p>\n<p><strong>性能比较：</strong></p>\n<table>\n<thead>\n<tr>\n<th>实现方式</th>\n<th>AddTimer</th>\n<th>KillTimer</th>\n<th>RunTimer</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>基于链表</td>\n<td>O(1)</td>\n<td>O(n)</td>\n<td>O(n)</td>\n</tr>\n<tr>\n<td>基于排序链表</td>\n<td>O(n)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>基于最小堆</td>\n<td>O(lgn)</td>\n<td>O(lgn)</td>\n<td>O(1)</td>\n</tr>\n<tr>\n<td>基于时间轮</td>\n<td>O(1)</td>\n<td>O(1)</td>\n<td>O(1)</td>\n</tr>\n</tbody></table>\n<p><em>现在看起来我们选择时间轮来实现就行了，是否这样就完事了？</em></p>\n<h2 id=\"着重分析时间轮\"><a href=\"#着重分析时间轮\" class=\"headerlink\" title=\"着重分析时间轮\"></a>着重分析时间轮</h2><p>如果需要支持的定时器范围非常的大，上面的实现方式则不能满足这样的需求。因为这样将消耗非常可观的内存，假设需要表示的定时器范围为：0 – 2^3-1ticks，则简单时间轮需要 2^32 个元素空间，这对于内存空间的使用将非常的庞大。也许可以降低定时器的精度，使得每个 Tick 表示的时间更长一些，但这样的代价是定时器的精度将大打折扣。</p>\n<p>现在的问题是，度量定时器的粒度，只能使用唯一粒度吗？想想日常生活中常遇到的水表，如下图：<br><img src=\"https://www.ibm.com/developerworks/cn/linux/l-cn-timers/image004.jpg\" alt=\"水表\"></p>\n<p>钟表：<br><img src=\"https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1556440651&di=0c604969bfdf6b335dd78462f862743e&imgtype=jpg&er=1&src=http://amuseum.cdstm.cn/AMuseum/time/01gzsj/images/0102_b.jpg\" alt=\"水表\"></p>\n<p>分级时间轮同样如此，每级时间轮所代表的粒度精度都不一样，这样结合起来，既能够保证定时器的精度，也能以较小内存代价表示范围更大更多的定时器。</p>\n<p><strong>简单时间轮</strong>： 一个齿轮，每个齿轮保存一个超时的node链表。一个齿轮表示一个时间刻度，比如钟表里面一小格代表一秒，钟表的秒针每次跳一格。假设一个刻度代表10ms，则2^32 个格子可表示1.36年，2^16个格子可表示10.9分钟。当要表示的时间范围较大时，空间复杂度会大幅增加。</p>\n<p><strong>分级时间轮</strong>： 类似于水表，当小轮子里的指针转动满一圈后，上一级轮子的指针进一格。  采用五个轮子每个轮子为一个简单时间轮，大小分别为 2^8， 2^6， 2^6， 2^6， 2^6，所需空间：2^8 + 2^6 + 2^6 + 2^6 + 2^6 &#x3D; 512， 可表示的范围为 0  –  2^8 * 2^6 * 2^6* 2^6* 2^6 &#x3D; 2^32 。</p>\n<p><strong>分级时间轮简洁图</strong>：<br><img src=\"http://kirito.iocoder.cn/7f03c027b1de345a0b1e57239d73de74.png\" alt=\"分级时间轮\"></p>\n<p><em>熟知的Linux系统内核，定时器实现方式就是分级时间轮</em><br><img src=\"https://images0.cnblogs.com/i/205989/201405/281755599318276.jpg\" alt=\"Linux内核\"></p>\n<h2 id=\"具体实现\"><a href=\"#具体实现\" class=\"headerlink\" title=\"具体实现\"></a>具体实现</h2><p>wheel_timer_mgr.h</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimerModule</span>;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ITimerMgr</span>;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimer</span>;\n\n<span class=\"hljs-keyword\">typedef</span> std::list&lt;CWheelTimer*&gt; TListTimer;\n\n<span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">ETimerType</span> \n&#123; \n    ETIMER_ONCE, \n    ETIMER_CIRCLE \n&#125;;\n\n<span class=\"hljs-comment\">///定时器最小精度 1/10秒 （100毫秒）</span>\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>  WHEEL_TIMER_MIN_PRECISION = <span class=\"hljs-number\">100</span>;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 基于分级的时间轮定时器, 精度约定为十分之一秒</span>\n<span class=\"hljs-comment\">* 注意，注册的Timer精度必须为约定的精度倍数</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimer</span>\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">CWheelTimer</span>();\n    <span class=\"hljs-built_in\">CWheelTimer</span>(CWheelTimerModule&amp; oModule);\n    ~<span class=\"hljs-built_in\">CWheelTimer</span>();\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 启动定时器</span>\n<span class=\"hljs-comment\">    * @param nInterval: 传入的是毫秒, 约定必须是十分之一秒（100ms）的倍数</span>\n<span class=\"hljs-comment\">    * @return </span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Start</span><span class=\"hljs-params\">(ITimerMgr* pITimer, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">unsigned</span> nInterval, <span class=\"hljs-type\">int</span> nDelay, ETimerType eTimerType = ETIMER_CIRCLE)</span></span>;\n\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 停止定时器</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Stop</span><span class=\"hljs-params\">()</span></span>;\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 定时器被触发</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnTrigger</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nNow)</span></span>;\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimerModule</span>;\n\n    CWheelTimerModule&amp;\t\tm_oModule;\n    ITimerMgr*\t\t\t\tm_pTimerMgr = <span class=\"hljs-literal\">nullptr</span>;\n    ETimerType\t\t\t\tm_eTimerType;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>\t\t\tm_nTimerId = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>\t\t\tm_nInterval = <span class=\"hljs-number\">-1</span>;    <span class=\"hljs-comment\">//ms</span>\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span>\t\tm_llExpireTime = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">//ms</span>\n    <span class=\"hljs-type\">int</span>\t\t\t\t\t\tm_nVecIndex = <span class=\"hljs-number\">0</span>;\n    TListTimer::iterator\tm_listIter;\n&#125;;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 定时器管理器接口， 派生类继承使用</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ITimerMgr</span>\n&#123;\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-keyword\">virtual</span>\t\t  ~<span class=\"hljs-built_in\">ITimerMgr</span>();\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>  <span class=\"hljs-title\">OnTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span> </span>= <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">//interval 时间精度 ms</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t  <span class=\"hljs-title\">SetTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">int</span> nInterval, <span class=\"hljs-type\">int</span> nDelay = <span class=\"hljs-number\">0</span>, ETimerType eTimeType = ETIMER_CIRCLE)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t  <span class=\"hljs-title\">KillTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">bool</span>\t\t  <span class=\"hljs-title\">IsTimerExist</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>;;\n\n<span class=\"hljs-keyword\">protected</span>:\n    std::unordered_map&lt;<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span>, CWheelTimer*&gt; m_mapTimer;\n&#125;;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 全局定时器管理模块， 负责管理所有的定时器</span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CWheelTimerModule</span> : <span class=\"hljs-keyword\">public</span> Storm::TSingleton&lt;CWheelTimerModule&gt;\n&#123;\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Storm</span>::TSingleton&lt;CWheelTimerModule&gt;;\n    <span class=\"hljs-built_in\">CWheelTimerModule</span>();\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">AddTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">RemoveTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 驱动所有的定时器</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">Run</span><span class=\"hljs-params\">()</span></span>;\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> UINT64\t<span class=\"hljs-title\">GetCurMillisecs</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">    * @brief 修正精度 </span>\n<span class=\"hljs-comment\">    * @param nSrcTime </span>\n<span class=\"hljs-comment\">    * @return 传入的时间除以当前约定最小定时器精度</span>\n<span class=\"hljs-comment\">    */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> UINT64\t<span class=\"hljs-title\">HandlePrecision</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nSrcTime)</span></span>;\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-type\">int</span>\t\t\t\t_Cascade(<span class=\"hljs-type\">int</span> nOffset, <span class=\"hljs-type\">int</span> nIndex);\n\n<span class=\"hljs-keyword\">private</span>:\n    std::vector&lt;TListTimer&gt;\t\tm_vecTimerList;\n\n    <span class=\"hljs-comment\">//notice: precision=100ms not 1ms</span>\n    UINT64\t\t\t\t\t\tm_llCheckTime;\n&#125;;\n\n<span class=\"hljs-comment\">/**</span>\n<span class=\"hljs-comment\">* @brief 定时器工厂 </span>\n<span class=\"hljs-comment\">*/</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CTimerFactory</span>: <span class=\"hljs-keyword\">public</span> Storm::TSingleton&lt;CTimerFactory&gt;, <span class=\"hljs-keyword\">public</span> CNoncopy\n&#123;\n    <span class=\"hljs-keyword\">friend</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Storm</span>::TSingleton&lt;CTimerFactory&gt;;\n    <span class=\"hljs-built_in\">CTimerFactory</span>();\n    <span class=\"hljs-keyword\">virtual</span>\t\t\t~<span class=\"hljs-built_in\">CTimerFactory</span>();\n<span class=\"hljs-keyword\">public</span>: \n    <span class=\"hljs-function\">CWheelTimer*\t<span class=\"hljs-title\">CreateCTimer</span><span class=\"hljs-params\">()</span></span>;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span>\t\t\t<span class=\"hljs-title\">ReleaseCTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>;\n<span class=\"hljs-keyword\">private</span>:\n\n    CSTObjectPool&lt;CWheelTimer&gt;    m_oCTimerPool;\n&#125;</code></pre>\n\n<p>wheel_timer_mgr.cpp</p>\n<pre><code class=\"hljs cpp\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> 0 </span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVN_BITS 6</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVR_BITS 8</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVN_SIZE (1 &lt;&lt; TVN_BITS)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVR_SIZE (1 &lt;&lt; TVR_BITS)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVN_MASK (TVN_SIZE - 1)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> TVR_MASK (TVR_SIZE - 1)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> OFFSET(N) (TVR_SIZE + (N) *TVN_SIZE)</span>\n    <span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INDEX(V, N) ((V &gt;&gt; (TVR_BITS + (N) *TVN_BITS)) &amp; TVN_MASK)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span> </span>\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVN_BITS = <span class=\"hljs-number\">6</span>;\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVR_BITS = <span class=\"hljs-number\">8</span>;\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVN_SIZE = (<span class=\"hljs-number\">1</span> &lt;&lt; TVN_BITS);\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVR_SIZE = (<span class=\"hljs-number\">1</span> &lt;&lt; TVR_BITS);\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVN_MASK = (TVN_SIZE - <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> TVR_MASK = (TVR_SIZE - <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">OFFSET</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> N)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> (TVR_SIZE + (N)*TVN_SIZE); &#125;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">INDEX</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> V, <span class=\"hljs-type\">int</span> N)</span></span>\n<span class=\"hljs-function\">    </span>&#123;\n        <span class=\"hljs-keyword\">return</span> ((V &gt;&gt; (TVR_BITS + (N)*TVN_BITS)) &amp; TVN_MASK);\n    &#125;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n\n\nCWheelTimer::<span class=\"hljs-built_in\">CWheelTimer</span>()\n    :<span class=\"hljs-built_in\">m_oModule</span>(CWheelTimerModule::<span class=\"hljs-built_in\">GetInstance</span>())\n    , <span class=\"hljs-built_in\">m_nVecIndex</span>(<span class=\"hljs-number\">-1</span>)\n&#123;\n&#125;\n\nCWheelTimer::<span class=\"hljs-built_in\">CWheelTimer</span>(CWheelTimerModule&amp; oModule)\n    : <span class=\"hljs-built_in\">m_oModule</span>(oModule)\n    , <span class=\"hljs-built_in\">m_nVecIndex</span>(<span class=\"hljs-number\">-1</span>)\n&#123;\n&#125;\n\nCWheelTimer::~<span class=\"hljs-built_in\">CWheelTimer</span>()\n&#123;\n    <span class=\"hljs-built_in\">Stop</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimer::Start</span><span class=\"hljs-params\">(ITimerMgr* pTimerMgr, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">unsigned</span> nInterval, <span class=\"hljs-type\">int</span> nDelay, ETimerType eTimerType)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-built_in\">Stop</span>();\n\n    <span class=\"hljs-comment\">//时间都修正为最小精度</span>\n    <span class=\"hljs-keyword\">if</span> (nInterval &lt; WHEEL_TIMER_MIN_PRECISION)\n    &#123;\n        nInterval = WHEEL_TIMER_MIN_PRECISION;\n    &#125;\n\n    m_nInterval = CWheelTimerModule::<span class=\"hljs-built_in\">HandlePrecision</span>(nInterval);\n    m_eTimerType = eTimerType;\n    m_pTimerMgr = pTimerMgr;\n    m_nTimerId = nId;\n    m_llExpireTime = CWheelTimerModule::<span class=\"hljs-built_in\">HandlePrecision</span>(nDelay + CWheelTimerModule::<span class=\"hljs-built_in\">GetCurMillisecs</span>());\n    m_oModule.<span class=\"hljs-built_in\">AddTimer</span>(<span class=\"hljs-keyword\">this</span>);\n&#125;\n\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimer::Stop</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (m_nVecIndex != <span class=\"hljs-number\">-1</span>)\n    &#123;\n        m_oModule.<span class=\"hljs-built_in\">RemoveTimer</span>(<span class=\"hljs-keyword\">this</span>);\n        m_nVecIndex = <span class=\"hljs-number\">-1</span>;\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimer::OnTrigger</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nNow)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (m_eTimerType == ETIMER_CIRCLE)\n    &#123;\n        m_llExpireTime = m_nInterval + nNow;\n        m_oModule.<span class=\"hljs-built_in\">AddTimer</span>(<span class=\"hljs-keyword\">this</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        m_nVecIndex = <span class=\"hljs-number\">-1</span>;\n    &#125;\n\n    <span class=\"hljs-keyword\">if</span> (m_pTimerMgr != <span class=\"hljs-literal\">nullptr</span>)\n    &#123;\n        m_pTimerMgr-&gt;<span class=\"hljs-built_in\">OnTimer</span>(m_nTimerId);\n    &#125;\n&#125;\n\n<span class=\"hljs-comment\">//--------------------------------------------------------------------------------------------------------</span>\n\nCWheelTimerModule::<span class=\"hljs-built_in\">CWheelTimerModule</span>()\n&#123;\n    m_vecTimerList.<span class=\"hljs-built_in\">resize</span>(TVR_SIZE + <span class=\"hljs-number\">4</span> * TVN_SIZE);\n    m_llCheckTime = <span class=\"hljs-built_in\">HandlePrecision</span>(<span class=\"hljs-built_in\">GetCurMillisecs</span>());\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimerModule::AddTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    UINT64 llExpireTime = pTimer-&gt;m_llExpireTime;\n    INT64 llTimeDiff = pTimer-&gt;m_llExpireTime - m_llCheckTime;\n\n    <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">0</span>)\n    &#123;\n        pTimer-&gt;m_nVecIndex = m_llCheckTime &amp; TVR_MASK;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; TVR_SIZE)\n    &#123;\n        pTimer-&gt;m_nVecIndex = llExpireTime &amp; TVR_MASK;\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">1</span> &lt;&lt; (TVR_BITS + TVN_BITS))\n    &#123;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">0</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">0</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">1</span> &lt;&lt; (TVR_BITS + <span class=\"hljs-number\">2</span> * TVN_BITS))\n    &#123;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">1</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">1</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (llTimeDiff &lt; <span class=\"hljs-number\">1</span> &lt;&lt; (TVR_BITS + <span class=\"hljs-number\">3</span> * TVN_BITS))\n    &#123;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">2</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">2</span>);\n    &#125;\n    <span class=\"hljs-keyword\">else</span>\n    &#123;\n        <span class=\"hljs-keyword\">if</span> (llTimeDiff &gt; <span class=\"hljs-number\">0xffffffff</span>UL)\n        &#123;\n            llTimeDiff = <span class=\"hljs-number\">0xffffffff</span>UL;\n            llExpireTime = llTimeDiff + m_llCheckTime;\n        &#125;\n        pTimer-&gt;m_nVecIndex = <span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">3</span>) + <span class=\"hljs-built_in\">INDEX</span>(llExpireTime, <span class=\"hljs-number\">3</span>);\n    &#125;\n\n    TListTimer&amp; listTimer = m_vecTimerList[pTimer-&gt;m_nVecIndex];\n    listTimer.<span class=\"hljs-built_in\">push_back</span>(pTimer);\n    pTimer-&gt;m_listIter = listTimer.<span class=\"hljs-built_in\">end</span>();\n    --pTimer-&gt;m_listIter;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimerModule::RemoveTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    TListTimer&amp; listTimer = m_vecTimerList[pTimer-&gt;m_nVecIndex];\n    listTimer.<span class=\"hljs-built_in\">erase</span>(pTimer-&gt;m_listIter);\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CWheelTimerModule::Run</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    UINT64 nNow = <span class=\"hljs-built_in\">HandlePrecision</span>(<span class=\"hljs-built_in\">GetCurMillisecs</span>());\n    <span class=\"hljs-keyword\">while</span> (m_llCheckTime &lt;= nNow)\n    &#123;\n        <span class=\"hljs-comment\">//for every tick</span>\n        <span class=\"hljs-type\">int</span> index = m_llCheckTime &amp; TVR_MASK;\n        <span class=\"hljs-keyword\">if</span> (!index &amp;&amp;\n            !_Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">0</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">0</span>)) &amp;&amp;\n            !_Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">1</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">1</span>)) &amp;&amp;\n            !_Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">2</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">2</span>)))\n        &#123;\n            _Cascade(<span class=\"hljs-built_in\">OFFSET</span>(<span class=\"hljs-number\">3</span>), <span class=\"hljs-built_in\">INDEX</span>(m_llCheckTime, <span class=\"hljs-number\">3</span>));\n        &#125;\n\n        \n        ++m_llCheckTime;\n\n        TListTimer&amp; listTimer = m_vecTimerList[index];\n        TListTimer listTmp;\n        listTmp.<span class=\"hljs-built_in\">splice</span>(listTmp.<span class=\"hljs-built_in\">end</span>(), listTimer);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> itr = listTmp.<span class=\"hljs-built_in\">begin</span>(); itr != listTmp.<span class=\"hljs-built_in\">end</span>(); ++itr)\n        &#123;\n            <span class=\"hljs-keyword\">auto</span>* pTimer = *itr;\n            <span class=\"hljs-keyword\">if</span> (pTimer != <span class=\"hljs-literal\">nullptr</span>)\n            &#123;\n                pTimer-&gt;<span class=\"hljs-built_in\">OnTrigger</span>(nNow);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n<span class=\"hljs-type\">int</span> CWheelTimerModule::_Cascade(<span class=\"hljs-type\">int</span> nOffset, <span class=\"hljs-type\">int</span> nIndex)\n&#123;\n    TListTimer&amp; listTimer = m_vecTimerList[nOffset + nIndex];\n    TListTimer listTemp;\n    listTemp.<span class=\"hljs-built_in\">splice</span>(listTemp.<span class=\"hljs-built_in\">end</span>(), listTimer);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> itr = listTemp.<span class=\"hljs-built_in\">begin</span>(); itr != listTemp.<span class=\"hljs-built_in\">end</span>(); ++itr)\n    &#123;\n        <span class=\"hljs-keyword\">auto</span>* pTimer = *itr;\n        <span class=\"hljs-keyword\">if</span> (pTimer != <span class=\"hljs-literal\">nullptr</span>)\n        &#123;\n            <span class=\"hljs-built_in\">AddTimer</span>(pTimer);\n        &#125;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> nIndex;\n&#125;\n\n<span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">CWheelTimerModule::HandlePrecision</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> UINT64 nSrcTime)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">return</span> nSrcTime / WHEEL_TIMER_MIN_PRECISION;\n&#125;\n\n<span class=\"hljs-function\">UINT64 <span class=\"hljs-title\">CWheelTimerModule::GetCurMillisecs</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">auto</span> llCurTime = CSysTime::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">GetNowMliTime</span>();\n    <span class=\"hljs-keyword\">return</span> llCurTime;\n&#125;\n\nITimerMgr::~<span class=\"hljs-built_in\">ITimerMgr</span>()\n&#123;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : m_mapTimer)\n    &#123;\n        <span class=\"hljs-keyword\">if</span> (it.second != <span class=\"hljs-literal\">nullptr</span>)\n        &#123;\n            it.second-&gt;<span class=\"hljs-built_in\">Stop</span>();\n            CTimerFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">ReleaseCTimer</span>(it.second);\n        &#125;\n    &#125;\n    m_mapTimer.<span class=\"hljs-built_in\">clear</span>();\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ITimerMgr::SetTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId, <span class=\"hljs-type\">int</span> nInterval, <span class=\"hljs-type\">int</span> nDelay ,ETimerType eTimeType)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">IsTimerExist</span>(nId))\n    &#123;\n        EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzTimer]Timer Has Existed, Not Repeat Add, nId:&quot;</span> &lt;&lt; nId;\n        <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    CWheelTimer* pTimer = CTimerFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">CreateCTimer</span>();\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">nullptr</span> == pTimer)\n    &#123;\n        <span class=\"hljs-keyword\">return</span>;\n    &#125;\n\n    m_mapTimer[nId] = pTimer;\n    pTimer-&gt;<span class=\"hljs-built_in\">Start</span>(<span class=\"hljs-keyword\">this</span>, nId, nInterval, nDelay, eTimeType);\n    EXLOG_DEBUG &lt;&lt; <span class=\"hljs-string\">&quot;[RyzTimer]Add Timer nId:&quot;</span> &lt;&lt; nId &lt;&lt; <span class=\"hljs-string\">&quot;,nInterval:&quot;</span> &lt;&lt; nInterval &lt;&lt; <span class=\"hljs-string\">&quot;,nDelay:&quot;</span> &lt;&lt; nDelay &lt;&lt; <span class=\"hljs-string\">&quot;,eTimeType:&quot;</span> &lt;&lt; eTimeType;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">ITimerMgr::KillTimer</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">auto</span> it = m_mapTimer.<span class=\"hljs-built_in\">find</span>(nId);\n    <span class=\"hljs-keyword\">if</span> (it != m_mapTimer.<span class=\"hljs-built_in\">end</span>())\n    &#123;\n        <span class=\"hljs-comment\">// 释放后 在TimerManager中 不会再执行 不需要做其他的操作</span>\n        it-&gt;second-&gt;<span class=\"hljs-built_in\">Stop</span>();\n        CTimerFactory::<span class=\"hljs-built_in\">Instance</span>()-&gt;<span class=\"hljs-built_in\">ReleaseCTimer</span>(it-&gt;second);\n        m_mapTimer.<span class=\"hljs-built_in\">erase</span>(it);\n    &#125;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">ITimerMgr::IsTimerExist</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> nId)</span> </span>\n<span class=\"hljs-function\"></span>&#123; \n    <span class=\"hljs-keyword\">return</span> m_mapTimer.<span class=\"hljs-built_in\">find</span>(nId) != m_mapTimer.<span class=\"hljs-built_in\">end</span>(); \n&#125;\n\nCTimerFactory::<span class=\"hljs-built_in\">CTimerFactory</span>()\n&#123;\n    m_oCTimerPool.<span class=\"hljs-built_in\">Init</span>(<span class=\"hljs-number\">32</span>, <span class=\"hljs-number\">8</span>);\n&#125;\n\nCTimerFactory::~<span class=\"hljs-built_in\">CTimerFactory</span>()\n&#123;\n&#125;\n\n<span class=\"hljs-function\">CWheelTimer * <span class=\"hljs-title\">CTimerFactory::CreateCTimer</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    CWheelTimer* pTimer = m_oCTimerPool.<span class=\"hljs-built_in\">FetchObj</span>();\n    <span class=\"hljs-keyword\">return</span> pTimer;\n&#125;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">CTimerFactory::ReleaseCTimer</span><span class=\"hljs-params\">(CWheelTimer* pTimer)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">nullptr</span> != pTimer)\n    &#123;\n        m_oCTimerPool.<span class=\"hljs-built_in\">ReleaseObj</span>(pTimer);\n    &#125;\n&#125;\n\n</code></pre>"},{"title":"网易互娱面试总结","date":"2020-01-23T00:12:45.000Z","_content":"\n## 现场二面技术总监面试\n这个人看起来挺和善的，实际上还是有一套的，让你写代码，然后眼睛编译给你指出错误，然后修改，然后他就去玩手机了...\n1. linux env multi-thread gdb debug 多线程调试 (回答对一半)\n\t首先介绍下基本命令\n\t- `info threads` 显示当前可以调试的所有线程，gdb会为每一个线程分配一个唯一ID，利用这个唯一Id可以切换到这个线程上下文环境中，并且前面有`*`标识的是当前调试的线程\n\t\t![](http:\\\\genge.cc\\wp-content\\uploads\\2018\\09\\cfd3fadfb7b7fd387f68feb079e1a99a.png)\n\t- `thread ID` 切换调试的线程为指定ID的线程。这个Id是gdb为每个线程分配的，并不是操作系统分配的PID，可以通过`info threads`命令查看\n\t- `break xx.cpp:123 thread all` 在所有线程中相应的行上设置断点\n\t- `break apply ID1 ID2 cmd` 让一个或者多个线程执行gdb命令cmd\n\t- `break apply all cmd` 让所有被调试线程执行GDB命令command\n\t- `set print thread-events` **设置线程创建提醒**  当运行过程总产生新线程的时候会打印\n\t- `set scheduler-locking off|on|step` 这个是重点，经常被问到，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。\n\t  - off 不锁定任何线程，也就是所有线程都执行，这是默认值。\n\t  - on 只有当前被调试程序会执行。.\n\t  - step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。该模式是对single-stepping模式的优化。此模式会阻止其他线程在当前线程单步调试时，抢占当前线。因此调试的焦点不会被以外的改变。其他线程不可能抢占当前的调试线程。其他线程只有下列情况下会重新获得运行的机会：当你‘next’一个函数调用的时候。当你使用诸如‘continue’、‘until‘、’finish‘命令的时候。其他线程遇到设置好的断点的时候。\n\n- 调试C++或者C的宏\n\t在编译程序的时候，加上`-ggdb3`参数，这样就可以调试宏\n\t- `info macro –` 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。\n\t- `macro – `你可以查看宏展开的样子。\n- 关联源文件\n\t- 如果在编译情况下加上`-g`参数，那么就可以包含debug信息，否者gdb找不到符号表\n\t- 可以使用`directory`命令来设置源文件的目录\n\t\t![](http:\\\\genge.cc\\wp-content\\uploads\\2018\\09\\942cbce8346b6e1ef65a32ea8c1919a9.png)\n- 条件断点\n\t基本语法` break  [where] if [condition]` 尤其是在一个循环或递归中，或是要监视某个变量。注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。\n- 添加参数\n\t1. gdb命令行的 –args 参数\n\t2. gdb环境中 set args命令。\n- 设置变量\n\t1. 可以直接使用set命令 设置上下文环境变量值，可以模拟一些很难在测试中出现的情况，以防未来程序出错\n\t2. 声明变量，然后使用，语法为`$name = 1`\n- X命令\n\t平时我们一般使用p命令打印参数值，但是这个命令必须指定变量名，不知道变量名的时候，我们可以使用X命令\n\t1. x\\x 以十六进制输出\n\t2. x\\d 以十进制输出\n\t3. x\\c 以单字符输出\n\t4. x\\i  反汇编 – 通常，我们会使用 x\\10i $ip-20 来查看当前的汇编（$ip是指令寄存器）\n\t5. x\\s 以字符串输出\n- command命令  把一组命令录制下来打包成‘宏’\n\t![](http:\\\\genge.cc\\wp-content\\uploads\\2018\\09\\1bc671b5484282a324ff2d3b68863cb7.png)\n\n2. 循环队列判空 (OK)\n\t有三种方式处理这种问题\n\t1. 队列Queue结构中保存一个计数器count表示当前队列元素个数（最简单粗暴），但count等于队列cap的时候就队列满，count为0的时候队列空\n\t2. **少用一个元素空间**，约定以“队列头指针front在队尾指针rear的下一个位置上”作为队列“满”状态的标志。这种方法比较常用，但是面试官不让用.... front指向队首元素，rear指向队尾元素的下一个元素。即：\n\t\t- 队空时： front=rear\n\t\t- 队满时： (rear+1)%maxsize=front\n\t3. 还有一个比较取巧的办法，优化第一种方案：使用一个状态flag变量，初始值为0，但入队成功置flag = 1，当出队成功设置flag = 0。我们可以使用 `front == rear && flag` 表示队列满（在入队操作之后导致front=rear），可以使用`front == rear && ！flag`表示队列空（出队后导致f==r，显然是队列空）\n\t\n3. 单向队列反转 (OK) 很简单\n\n```cpp\n\nstruct Node\n{\n    int data;\n    Node * next;\n};\n\nNode* reverse_list(Node* head)\n{\n    if(head == nullptr) return head;\n\n    Node* node = nullptr;\n    node = head;\n    head = head->next;\n    node = nullptr;\n\n    while(head != nullptr)\n    {\n        Node* next = head->next;\n        head->next = node;\n        node = head;\n        head = next;\n    }\n\n    return node;\n}\n\n```\n\n## 现场面一面回忆总结\n估计是小组长之类的面试官吧，去之前我还特意看下自己的衣装是否整洁，这个面试官感觉是从`工地`上回来的，衣服上很脏，典型程序员面孔，他问的问题算是比较全面\n操作系统（linux）、数据库（mysql）、算法、数据结构、计算机网络基础、网络编程、语言基础（C++语言）、并发、以及具体业务设计，还有项目基本介绍，游戏服务器架构简单介绍\n\n常见模块实现\n1. 定时器实现方式目前应用比较多的有时间轮和最小堆方式 ， 优缺点其实就是算法复杂度：\n\t实现方式\tStartTimer\tStopTimer\tPerTickBookkeeping\n\t基于链表\t \tO(1)\t\tO(n)\t\tO(n)\n\t基于排序链表\tO(n)\t\tO(1)\t\tO(1)\n\t基于最小堆\t\tO(lgn)\t\tO(1)\t\tO(1)\n\t基于时间轮\t\tO(1)\t\tO(1)\t\tO(1)\nhttps:\\\\www.ibm.com\\developerworks\\cn\\linux\\l-cn-timers\\\n\n2. 斐波那契数 多种实现\n   1. 递归 最简单 粗暴  效率最低  存在大量重复计算\n   2. 循环叠加  算法复杂度为O（n）\n   3. 申请额外数组保存结果 去除重复计算 空间换时间\n   4. 利用数学公式推导，矩阵相乘推导公式，算法复杂度为O（logn）  效率最高\n\t{f(n), f(n-1), f(n-1), f(n-2)} ={1, 1, 1,0}n-1\n\t{f(n), f(n-1), f(n-1), f(n-2)}\n    详情见 https:\\\\www.cnblogs.com\\python27\\archive\\2011\\11\\25\\2261980.html\n   5. 通项公式  这个实在是牛逼  一个公式搞定...   不是数学系  这些方法确实想不出 只能记忆\n   ```cpp\n   int Fibonacci(int n)\n\t{\n\t\tdouble tmp=sqrt(double(5));\n\t\treturn int((pow((1+tmp)\\2,n)-pow((1-tmp)\\2,n))\\tmp);\n\t}\n\n\t```\n\t6. 定理\n   ```cpp\n   int Fibonacci(int n)\n\t{\n\t\tif(n==0)return 0;\n\t\tif(n==1||n==2)return 1;    \\\\当n>=3时，n>n\\2+1\n\t\tint x=Fibonacci(n\\2);\n\t\tint y=Fibonacci(n\\2+1);\n\t\tif(n&1)return x*x+y*y;\n\t\treturn x*(2*y-x);\n\t}\n\t```\n3. 敏感字过滤算法\n   1. 正则匹配  面试官一般不会让你用这个 因为要匹配的内容太多  写正则表达式就很烦...  效率还不高  KMP算法 太慢 不能用\n   2. 自己当时想到的一张方法为字典树TrieTree  这个方法太耗空间 时间复杂度为O(key_max_len) 很多生产环境确实是用这个实现的，别名有限状态机 DFA：DFA即Deterministic Finite Automaton，也就是确定有穷自动机\n   3. 其他什么优化算法 其实也不用\n\n4. 数据库\n   1. 数据库事务特性 \n        ACID  原子性  一致性  隔离性  持久性dura\n        \n   2. 事务隔离级别 \n  \n\t\t\t隔离级别               脏读（Dirty Read）          不可重复读（NonRepeatable Read）     幻读（Phantom Read） \n\n\t\t未提交读（Read uncommitted）        可能                            可能                       可能\n\n\t\t已提交读（Read committed）          不可能                          可能                       可能\n\n\t\t可重复读（Repeatable read）         不可能                          不可能                     可能\n\n\t\t可串行化（Serializable ）           不可能                          不可能                     不可能\n\n\t\t·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据（事务之间关系）\n\t\t·提交读(Read Committed)：只能读取到已经提交的数据。**Oracle等多数数据库默认都是该级别** (不重复读) （事务之间关系）\n\t\t·可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，**InnoDB默认级别**。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 （事务内部）\n\t\t·串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞\t\t\n\t\t可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。\n\t\t可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据（提交读）。\n\t\tMySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。\n\t\t总结:[MySQL 四种事务隔离级的说明 - jyzhou - 博客园](http:\\\\www.cnblogs.com\\zhoujinyi\\p\\3437475.html)\n\t\t四个级别逐渐增强，每个级别解决一个问题。事务级别越高,性能越差,大多数环境read committed 可以用.记住4个隔离级别的特点(上面的例子);<http:\\\\www.cnblogs.com\\zhoujinyi\\p\\3437475.html>\n   3. 事务实现原理\n\thttps:\\\\draveness.me\\mysql-transaction 介绍事务ACID的火滚日志实现 https:\\\\www.cnblogs.com\\wy123\\p\\8365234.html 具体日志格式\n   4. innodb和myisam存储引擎的区别 https:\\\\blog.csdn.net\\xifeijian\\article\\details\\20316775\n\t  - MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。\n\t  - InnoDB不支持FULLTEXT类型的索引。\n\t  - InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。\n\t  - 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。\n\t  - 细节可以看链接 https:\\\\blog.csdn.net\\xifeijian\\article\\details\\20316775和下面一个介绍\n\t  - https:\\\\www.jianshu.com\\p\\a957b18ba40d \n   5. 对于like查询啥时候会用到索引 http:\\\\thephper.com\\?p=142\n   >  like 不能用索引？ 这个确实不知道 难受\n\t尽量减少like，但不是绝对不可用，”xxxx%” 是可以用到索引的，\n\t想象一下，你在看一本成语词典，目录是按成语拼音顺序建立，查询需求是，你想找以 “一”字开头的成语（”一%“），和你想找包含一字的成语（“%一%”）\n\t除了like，以下操作符也可用到索引：\n\t<，<=，=，>，>=，BETWEEN，IN\n\t<>，not in ，！=则不行\n\n   6. 索引类型\n\t https:\\\\segmentfault.com\\q\\1010000003832312           http:\\\\blog.codinglabs.org\\articles\\theory-of-mysql-index.html","source":"_posts/网易互娱面试总结.md","raw":"---\ntitle: 网易互娱面试总结\ndate: 2020-01-23 8:12:45\ntags: 面试\n---\n\n## 现场二面技术总监面试\n这个人看起来挺和善的，实际上还是有一套的，让你写代码，然后眼睛编译给你指出错误，然后修改，然后他就去玩手机了...\n1. linux env multi-thread gdb debug 多线程调试 (回答对一半)\n\t首先介绍下基本命令\n\t- `info threads` 显示当前可以调试的所有线程，gdb会为每一个线程分配一个唯一ID，利用这个唯一Id可以切换到这个线程上下文环境中，并且前面有`*`标识的是当前调试的线程\n\t\t![](http:\\\\genge.cc\\wp-content\\uploads\\2018\\09\\cfd3fadfb7b7fd387f68feb079e1a99a.png)\n\t- `thread ID` 切换调试的线程为指定ID的线程。这个Id是gdb为每个线程分配的，并不是操作系统分配的PID，可以通过`info threads`命令查看\n\t- `break xx.cpp:123 thread all` 在所有线程中相应的行上设置断点\n\t- `break apply ID1 ID2 cmd` 让一个或者多个线程执行gdb命令cmd\n\t- `break apply all cmd` 让所有被调试线程执行GDB命令command\n\t- `set print thread-events` **设置线程创建提醒**  当运行过程总产生新线程的时候会打印\n\t- `set scheduler-locking off|on|step` 这个是重点，经常被问到，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。\n\t  - off 不锁定任何线程，也就是所有线程都执行，这是默认值。\n\t  - on 只有当前被调试程序会执行。.\n\t  - step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。该模式是对single-stepping模式的优化。此模式会阻止其他线程在当前线程单步调试时，抢占当前线。因此调试的焦点不会被以外的改变。其他线程不可能抢占当前的调试线程。其他线程只有下列情况下会重新获得运行的机会：当你‘next’一个函数调用的时候。当你使用诸如‘continue’、‘until‘、’finish‘命令的时候。其他线程遇到设置好的断点的时候。\n\n- 调试C++或者C的宏\n\t在编译程序的时候，加上`-ggdb3`参数，这样就可以调试宏\n\t- `info macro –` 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。\n\t- `macro – `你可以查看宏展开的样子。\n- 关联源文件\n\t- 如果在编译情况下加上`-g`参数，那么就可以包含debug信息，否者gdb找不到符号表\n\t- 可以使用`directory`命令来设置源文件的目录\n\t\t![](http:\\\\genge.cc\\wp-content\\uploads\\2018\\09\\942cbce8346b6e1ef65a32ea8c1919a9.png)\n- 条件断点\n\t基本语法` break  [where] if [condition]` 尤其是在一个循环或递归中，或是要监视某个变量。注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。\n- 添加参数\n\t1. gdb命令行的 –args 参数\n\t2. gdb环境中 set args命令。\n- 设置变量\n\t1. 可以直接使用set命令 设置上下文环境变量值，可以模拟一些很难在测试中出现的情况，以防未来程序出错\n\t2. 声明变量，然后使用，语法为`$name = 1`\n- X命令\n\t平时我们一般使用p命令打印参数值，但是这个命令必须指定变量名，不知道变量名的时候，我们可以使用X命令\n\t1. x\\x 以十六进制输出\n\t2. x\\d 以十进制输出\n\t3. x\\c 以单字符输出\n\t4. x\\i  反汇编 – 通常，我们会使用 x\\10i $ip-20 来查看当前的汇编（$ip是指令寄存器）\n\t5. x\\s 以字符串输出\n- command命令  把一组命令录制下来打包成‘宏’\n\t![](http:\\\\genge.cc\\wp-content\\uploads\\2018\\09\\1bc671b5484282a324ff2d3b68863cb7.png)\n\n2. 循环队列判空 (OK)\n\t有三种方式处理这种问题\n\t1. 队列Queue结构中保存一个计数器count表示当前队列元素个数（最简单粗暴），但count等于队列cap的时候就队列满，count为0的时候队列空\n\t2. **少用一个元素空间**，约定以“队列头指针front在队尾指针rear的下一个位置上”作为队列“满”状态的标志。这种方法比较常用，但是面试官不让用.... front指向队首元素，rear指向队尾元素的下一个元素。即：\n\t\t- 队空时： front=rear\n\t\t- 队满时： (rear+1)%maxsize=front\n\t3. 还有一个比较取巧的办法，优化第一种方案：使用一个状态flag变量，初始值为0，但入队成功置flag = 1，当出队成功设置flag = 0。我们可以使用 `front == rear && flag` 表示队列满（在入队操作之后导致front=rear），可以使用`front == rear && ！flag`表示队列空（出队后导致f==r，显然是队列空）\n\t\n3. 单向队列反转 (OK) 很简单\n\n```cpp\n\nstruct Node\n{\n    int data;\n    Node * next;\n};\n\nNode* reverse_list(Node* head)\n{\n    if(head == nullptr) return head;\n\n    Node* node = nullptr;\n    node = head;\n    head = head->next;\n    node = nullptr;\n\n    while(head != nullptr)\n    {\n        Node* next = head->next;\n        head->next = node;\n        node = head;\n        head = next;\n    }\n\n    return node;\n}\n\n```\n\n## 现场面一面回忆总结\n估计是小组长之类的面试官吧，去之前我还特意看下自己的衣装是否整洁，这个面试官感觉是从`工地`上回来的，衣服上很脏，典型程序员面孔，他问的问题算是比较全面\n操作系统（linux）、数据库（mysql）、算法、数据结构、计算机网络基础、网络编程、语言基础（C++语言）、并发、以及具体业务设计，还有项目基本介绍，游戏服务器架构简单介绍\n\n常见模块实现\n1. 定时器实现方式目前应用比较多的有时间轮和最小堆方式 ， 优缺点其实就是算法复杂度：\n\t实现方式\tStartTimer\tStopTimer\tPerTickBookkeeping\n\t基于链表\t \tO(1)\t\tO(n)\t\tO(n)\n\t基于排序链表\tO(n)\t\tO(1)\t\tO(1)\n\t基于最小堆\t\tO(lgn)\t\tO(1)\t\tO(1)\n\t基于时间轮\t\tO(1)\t\tO(1)\t\tO(1)\nhttps:\\\\www.ibm.com\\developerworks\\cn\\linux\\l-cn-timers\\\n\n2. 斐波那契数 多种实现\n   1. 递归 最简单 粗暴  效率最低  存在大量重复计算\n   2. 循环叠加  算法复杂度为O（n）\n   3. 申请额外数组保存结果 去除重复计算 空间换时间\n   4. 利用数学公式推导，矩阵相乘推导公式，算法复杂度为O（logn）  效率最高\n\t{f(n), f(n-1), f(n-1), f(n-2)} ={1, 1, 1,0}n-1\n\t{f(n), f(n-1), f(n-1), f(n-2)}\n    详情见 https:\\\\www.cnblogs.com\\python27\\archive\\2011\\11\\25\\2261980.html\n   5. 通项公式  这个实在是牛逼  一个公式搞定...   不是数学系  这些方法确实想不出 只能记忆\n   ```cpp\n   int Fibonacci(int n)\n\t{\n\t\tdouble tmp=sqrt(double(5));\n\t\treturn int((pow((1+tmp)\\2,n)-pow((1-tmp)\\2,n))\\tmp);\n\t}\n\n\t```\n\t6. 定理\n   ```cpp\n   int Fibonacci(int n)\n\t{\n\t\tif(n==0)return 0;\n\t\tif(n==1||n==2)return 1;    \\\\当n>=3时，n>n\\2+1\n\t\tint x=Fibonacci(n\\2);\n\t\tint y=Fibonacci(n\\2+1);\n\t\tif(n&1)return x*x+y*y;\n\t\treturn x*(2*y-x);\n\t}\n\t```\n3. 敏感字过滤算法\n   1. 正则匹配  面试官一般不会让你用这个 因为要匹配的内容太多  写正则表达式就很烦...  效率还不高  KMP算法 太慢 不能用\n   2. 自己当时想到的一张方法为字典树TrieTree  这个方法太耗空间 时间复杂度为O(key_max_len) 很多生产环境确实是用这个实现的，别名有限状态机 DFA：DFA即Deterministic Finite Automaton，也就是确定有穷自动机\n   3. 其他什么优化算法 其实也不用\n\n4. 数据库\n   1. 数据库事务特性 \n        ACID  原子性  一致性  隔离性  持久性dura\n        \n   2. 事务隔离级别 \n  \n\t\t\t隔离级别               脏读（Dirty Read）          不可重复读（NonRepeatable Read）     幻读（Phantom Read） \n\n\t\t未提交读（Read uncommitted）        可能                            可能                       可能\n\n\t\t已提交读（Read committed）          不可能                          可能                       可能\n\n\t\t可重复读（Repeatable read）         不可能                          不可能                     可能\n\n\t\t可串行化（Serializable ）           不可能                          不可能                     不可能\n\n\t\t·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据（事务之间关系）\n\t\t·提交读(Read Committed)：只能读取到已经提交的数据。**Oracle等多数数据库默认都是该级别** (不重复读) （事务之间关系）\n\t\t·可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，**InnoDB默认级别**。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 （事务内部）\n\t\t·串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞\t\t\n\t\t可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。\n\t\t可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据（提交读）。\n\t\tMySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。\n\t\t总结:[MySQL 四种事务隔离级的说明 - jyzhou - 博客园](http:\\\\www.cnblogs.com\\zhoujinyi\\p\\3437475.html)\n\t\t四个级别逐渐增强，每个级别解决一个问题。事务级别越高,性能越差,大多数环境read committed 可以用.记住4个隔离级别的特点(上面的例子);<http:\\\\www.cnblogs.com\\zhoujinyi\\p\\3437475.html>\n   3. 事务实现原理\n\thttps:\\\\draveness.me\\mysql-transaction 介绍事务ACID的火滚日志实现 https:\\\\www.cnblogs.com\\wy123\\p\\8365234.html 具体日志格式\n   4. innodb和myisam存储引擎的区别 https:\\\\blog.csdn.net\\xifeijian\\article\\details\\20316775\n\t  - MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。\n\t  - InnoDB不支持FULLTEXT类型的索引。\n\t  - InnoDB 中不保存表的具体行数，也就是说，执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的。\n\t  - 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。\n\t  - 细节可以看链接 https:\\\\blog.csdn.net\\xifeijian\\article\\details\\20316775和下面一个介绍\n\t  - https:\\\\www.jianshu.com\\p\\a957b18ba40d \n   5. 对于like查询啥时候会用到索引 http:\\\\thephper.com\\?p=142\n   >  like 不能用索引？ 这个确实不知道 难受\n\t尽量减少like，但不是绝对不可用，”xxxx%” 是可以用到索引的，\n\t想象一下，你在看一本成语词典，目录是按成语拼音顺序建立，查询需求是，你想找以 “一”字开头的成语（”一%“），和你想找包含一字的成语（“%一%”）\n\t除了like，以下操作符也可用到索引：\n\t<，<=，=，>，>=，BETWEEN，IN\n\t<>，not in ，！=则不行\n\n   6. 索引类型\n\t https:\\\\segmentfault.com\\q\\1010000003832312           http:\\\\blog.codinglabs.org\\articles\\theory-of-mysql-index.html","slug":"网易互娱面试总结","published":1,"updated":"2020-01-23T00:12:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzg6000xokec92o05anm","content":"<h2 id=\"现场二面技术总监面试\"><a href=\"#现场二面技术总监面试\" class=\"headerlink\" title=\"现场二面技术总监面试\"></a>现场二面技术总监面试</h2><p>这个人看起来挺和善的，实际上还是有一套的，让你写代码，然后眼睛编译给你指出错误，然后修改，然后他就去玩手机了…</p>\n<ol>\n<li>linux env multi-thread gdb debug 多线程调试 (回答对一半)<br> 首先介绍下基本命令<ul>\n<li><code>info threads</code> 显示当前可以调试的所有线程，gdb会为每一个线程分配一个唯一ID，利用这个唯一Id可以切换到这个线程上下文环境中，并且前面有<code>*</code>标识的是当前调试的线程<br>  <img src=\"http://genge.cc/wp-content/uploads/2018/09/cfd3fadfb7b7fd387f68feb079e1a99a.png\"></li>\n<li><code>thread ID</code> 切换调试的线程为指定ID的线程。这个Id是gdb为每个线程分配的，并不是操作系统分配的PID，可以通过<code>info threads</code>命令查看</li>\n<li><code>break xx.cpp:123 thread all</code> 在所有线程中相应的行上设置断点</li>\n<li><code>break apply ID1 ID2 cmd</code> 让一个或者多个线程执行gdb命令cmd</li>\n<li><code>break apply all cmd</code> 让所有被调试线程执行GDB命令command</li>\n<li><code>set print thread-events</code> <strong>设置线程创建提醒</strong>  当运行过程总产生新线程的时候会打印</li>\n<li><code>set scheduler-locking off|on|step</code> 这个是重点，经常被问到，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。<ul>\n<li>off 不锁定任何线程，也就是所有线程都执行，这是默认值。</li>\n<li>on 只有当前被调试程序会执行。.</li>\n<li>step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。该模式是对single-stepping模式的优化。此模式会阻止其他线程在当前线程单步调试时，抢占当前线。因此调试的焦点不会被以外的改变。其他线程不可能抢占当前的调试线程。其他线程只有下列情况下会重新获得运行的机会：当你‘next’一个函数调用的时候。当你使用诸如‘continue’、‘until‘、’finish‘命令的时候。其他线程遇到设置好的断点的时候。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>调试C++或者C的宏<br>  在编译程序的时候，加上<code>-ggdb3</code>参数，这样就可以调试宏<ul>\n<li><code>info macro –</code> 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。</li>\n<li><code>macro – </code>你可以查看宏展开的样子。</li>\n</ul>\n</li>\n<li>关联源文件<ul>\n<li>如果在编译情况下加上<code>-g</code>参数，那么就可以包含debug信息，否者gdb找不到符号表</li>\n<li>可以使用<code>directory</code>命令来设置源文件的目录<br>  <img src=\"http://genge.cc/wp-content/uploads/2018/09/942cbce8346b6e1ef65a32ea8c1919a9.png\"></li>\n</ul>\n</li>\n<li>条件断点<br>  基本语法<code> break  [where] if [condition]</code> 尤其是在一个循环或递归中，或是要监视某个变量。注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。</li>\n<li>添加参数<ol>\n<li>gdb命令行的 –args 参数</li>\n<li>gdb环境中 set args命令。</li>\n</ol>\n</li>\n<li>设置变量<ol>\n<li>可以直接使用set命令 设置上下文环境变量值，可以模拟一些很难在测试中出现的情况，以防未来程序出错</li>\n<li>声明变量，然后使用，语法为<code>$name = 1</code></li>\n</ol>\n</li>\n<li>X命令<br>  平时我们一般使用p命令打印参数值，但是这个命令必须指定变量名，不知道变量名的时候，我们可以使用X命令<ol>\n<li>x\\x 以十六进制输出</li>\n<li>x\\d 以十进制输出</li>\n<li>x\\c 以单字符输出</li>\n<li>x\\i  反汇编 – 通常，我们会使用 x\\10i $ip-20 来查看当前的汇编（$ip是指令寄存器）</li>\n<li>x\\s 以字符串输出</li>\n</ol>\n</li>\n<li>command命令  把一组命令录制下来打包成‘宏’<br>  <img src=\"http://genge.cc/wp-content/uploads/2018/09/1bc671b5484282a324ff2d3b68863cb7.png\"></li>\n</ul>\n<ol start=\"2\">\n<li><p>循环队列判空 (OK)<br> 有三种方式处理这种问题</p>\n<ol>\n<li>队列Queue结构中保存一个计数器count表示当前队列元素个数（最简单粗暴），但count等于队列cap的时候就队列满，count为0的时候队列空</li>\n<li><strong>少用一个元素空间</strong>，约定以“队列头指针front在队尾指针rear的下一个位置上”作为队列“满”状态的标志。这种方法比较常用，但是面试官不让用…. front指向队首元素，rear指向队尾元素的下一个元素。即：<ul>\n<li>队空时： front&#x3D;rear</li>\n<li>队满时： (rear+1)%maxsize&#x3D;front</li>\n</ul>\n</li>\n<li>还有一个比较取巧的办法，优化第一种方案：使用一个状态flag变量，初始值为0，但入队成功置flag &#x3D; 1，当出队成功设置flag &#x3D; 0。我们可以使用 <code>front == rear &amp;&amp; flag</code> 表示队列满（在入队操作之后导致front&#x3D;rear），可以使用<code>front == rear &amp;&amp; ！flag</code>表示队列空（出队后导致f&#x3D;&#x3D;r，显然是队列空）</li>\n</ol>\n</li>\n<li><p>单向队列反转 (OK) 很简单</p>\n</li>\n</ol>\n<pre><code class=\"hljs cpp\">\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>\n&#123;\n    <span class=\"hljs-type\">int</span> data;\n    Node * next;\n&#125;;\n\n<span class=\"hljs-function\">Node* <span class=\"hljs-title\">reverse_list</span><span class=\"hljs-params\">(Node* head)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span>(head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> head;\n\n    Node* node = <span class=\"hljs-literal\">nullptr</span>;\n    node = head;\n    head = head-&gt;next;\n    node = <span class=\"hljs-literal\">nullptr</span>;\n\n    <span class=\"hljs-keyword\">while</span>(head != <span class=\"hljs-literal\">nullptr</span>)\n    &#123;\n        Node* next = head-&gt;next;\n        head-&gt;next = node;\n        node = head;\n        head = next;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> node;\n&#125;\n</code></pre>\n\n<h2 id=\"现场面一面回忆总结\"><a href=\"#现场面一面回忆总结\" class=\"headerlink\" title=\"现场面一面回忆总结\"></a>现场面一面回忆总结</h2><p>估计是小组长之类的面试官吧，去之前我还特意看下自己的衣装是否整洁，这个面试官感觉是从<code>工地</code>上回来的，衣服上很脏，典型程序员面孔，他问的问题算是比较全面<br>操作系统（linux）、数据库（mysql）、算法、数据结构、计算机网络基础、网络编程、语言基础（C++语言）、并发、以及具体业务设计，还有项目基本介绍，游戏服务器架构简单介绍</p>\n<p>常见模块实现</p>\n<ol>\n<li><p>定时器实现方式目前应用比较多的有时间轮和最小堆方式 ， 优缺点其实就是算法复杂度：<br> 实现方式\tStartTimer\tStopTimer\tPerTickBookkeeping<br> 基于链表\t \tO(1)\t\tO(n)\t\tO(n)<br> 基于排序链表\tO(n)\t\tO(1)\t\tO(1)<br> 基于最小堆\t\tO(lgn)\t\tO(1)\t\tO(1)<br> 基于时间轮\t\tO(1)\t\tO(1)\t\tO(1)<br>https:\\<a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-timers/\">www.ibm.com\\developerworks\\cn\\linux\\l-cn-timers\\</a></p>\n</li>\n<li><p>斐波那契数 多种实现</p>\n<ol>\n<li>递归 最简单 粗暴  效率最低  存在大量重复计算</li>\n<li>循环叠加  算法复杂度为O（n）</li>\n<li>申请额外数组保存结果 去除重复计算 空间换时间</li>\n<li>利用数学公式推导，矩阵相乘推导公式，算法复杂度为O（logn）  效率最高<br> {f(n), f(n-1), f(n-1), f(n-2)} &#x3D;{1, 1, 1,0}n-1<br> {f(n), f(n-1), f(n-1), f(n-2)}<br> 详情见 https:\\<a href=\"http://www.cnblogs.com/python27/archive/2011/11/25/2261980.html\">www.cnblogs.com\\python27\\archive\\2011\\11\\25\\2261980.html</a></li>\n<li>通项公式  这个实在是牛逼  一个公式搞定…   不是数学系  这些方法确实想不出 只能记忆<pre><code class=\"hljs cpp\">  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Fibonacci</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">double</span> tmp=<span class=\"hljs-built_in\">sqrt</span>(<span class=\"hljs-built_in\">double</span>(<span class=\"hljs-number\">5</span>));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>((<span class=\"hljs-built_in\">pow</span>((<span class=\"hljs-number\">1</span>+tmp)\\<span class=\"hljs-number\">2</span>,n)-<span class=\"hljs-built_in\">pow</span>((<span class=\"hljs-number\">1</span>-tmp)\\<span class=\"hljs-number\">2</span>,n))\\tmp);\n&#125;\n</code></pre></li>\n<li>定理<pre><code class=\"hljs cpp\">  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Fibonacci</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">1</span>||n==<span class=\"hljs-number\">2</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;    \\\\当n&gt;=<span class=\"hljs-number\">3</span>时，n&gt;n\\<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-type\">int</span> x=<span class=\"hljs-built_in\">Fibonacci</span>(n\\<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-type\">int</span> y=<span class=\"hljs-built_in\">Fibonacci</span>(n\\<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">if</span>(n&amp;<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> x*x+y*y;\n    <span class=\"hljs-keyword\">return</span> x*(<span class=\"hljs-number\">2</span>*y-x);\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>敏感字过滤算法</p>\n<ol>\n<li>正则匹配  面试官一般不会让你用这个 因为要匹配的内容太多  写正则表达式就很烦…  效率还不高  KMP算法 太慢 不能用</li>\n<li>自己当时想到的一张方法为字典树TrieTree  这个方法太耗空间 时间复杂度为O(key_max_len) 很多生产环境确实是用这个实现的，别名有限状态机 DFA：DFA即Deterministic Finite Automaton，也就是确定有穷自动机</li>\n<li>其他什么优化算法 其实也不用</li>\n</ol>\n</li>\n<li><p>数据库</p>\n<ol>\n<li><p>数据库事务特性<br>  ACID  原子性  一致性  隔离性  持久性dura</p>\n</li>\n<li><p>事务隔离级别 </p>\n<pre><code>  隔离级别               脏读（Dirty Read）          不可重复读（NonRepeatable Read）     幻读（Phantom Read） \n</code></pre>\n<p>  未提交读（Read uncommitted）        可能                            可能                       可能</p>\n<p>  已提交读（Read committed）          不可能                          可能                       可能</p>\n<p>  可重复读（Repeatable read）         不可能                          不可能                     可能</p>\n<p>  可串行化（Serializable ）           不可能                          不可能                     不可能</p>\n<p>  ·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据（事务之间关系）<br>  ·提交读(Read Committed)：只能读取到已经提交的数据。<strong>Oracle等多数数据库默认都是该级别</strong> (不重复读) （事务之间关系）<br>  ·可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，<strong>InnoDB默认级别</strong>。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 （事务内部）<br>  ·串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞\t\t<br>  可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。<br>  可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据（提交读）。<br>  MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。<br>  总结:<a href=\"http://www.cnblogs.com/zhoujinyi/p/3437475.html\">MySQL 四种事务隔离级的说明 - jyzhou - 博客园</a><br>  四个级别逐渐增强，每个级别解决一个问题。事务级别越高,性能越差,大多数环境read committed 可以用.记住4个隔离级别的特点(上面的例子);<a href=\"http://www.cnblogs.com/zhoujinyi/p/3437475.html\">http:\\\\www.cnblogs.com\\zhoujinyi\\p\\3437475.html</a></p>\n</li>\n<li><p>事务实现原理<br> https:\\draveness.me\\mysql-transaction 介绍事务ACID的火滚日志实现 https:\\<a href=\"http://www.cnblogs.com/wy123/p/8365234.html\">www.cnblogs.com\\wy123\\p\\8365234.html</a> 具体日志格式</p>\n</li>\n<li><p>innodb和myisam存储引擎的区别 https:\\blog.csdn.net\\xifeijian\\article\\details\\20316775</p>\n<ul>\n<li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</li>\n<li>InnoDB不支持FULLTEXT类型的索引。</li>\n<li>InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</li>\n<li>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</li>\n<li>细节可以看链接 https:\\blog.csdn.net\\xifeijian\\article\\details\\20316775和下面一个介绍</li>\n<li>https:\\<a href=\"http://www.jianshu.com/p/a957b18ba40d\">www.jianshu.com\\p\\a957b18ba40d</a></li>\n</ul>\n</li>\n<li><p>对于like查询啥时候会用到索引 http:\\thephper.com?p&#x3D;142</p>\n<blockquote>\n<p> like 不能用索引？ 这个确实不知道 难受<br> 尽量减少like，但不是绝对不可用，”xxxx%” 是可以用到索引的，<br> 想象一下，你在看一本成语词典，目录是按成语拼音顺序建立，查询需求是，你想找以 “一”字开头的成语（”一%“），和你想找包含一字的成语（“%一%”）<br> 除了like，以下操作符也可用到索引：<br> &lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN<br> &lt;&gt;，not in ，！&#x3D;则不行</p>\n</blockquote>\n</li>\n<li><p>索引类型<br>  https:\\segmentfault.com\\q\\1010000003832312           http:\\blog.codinglabs.org\\articles\\theory-of-mysql-index.html</p>\n</li>\n</ol>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"现场二面技术总监面试\"><a href=\"#现场二面技术总监面试\" class=\"headerlink\" title=\"现场二面技术总监面试\"></a>现场二面技术总监面试</h2><p>这个人看起来挺和善的，实际上还是有一套的，让你写代码，然后眼睛编译给你指出错误，然后修改，然后他就去玩手机了…</p>\n<ol>\n<li>linux env multi-thread gdb debug 多线程调试 (回答对一半)<br> 首先介绍下基本命令<ul>\n<li><code>info threads</code> 显示当前可以调试的所有线程，gdb会为每一个线程分配一个唯一ID，利用这个唯一Id可以切换到这个线程上下文环境中，并且前面有<code>*</code>标识的是当前调试的线程<br>  <img src=\"http://genge.cc/wp-content/uploads/2018/09/cfd3fadfb7b7fd387f68feb079e1a99a.png\"></li>\n<li><code>thread ID</code> 切换调试的线程为指定ID的线程。这个Id是gdb为每个线程分配的，并不是操作系统分配的PID，可以通过<code>info threads</code>命令查看</li>\n<li><code>break xx.cpp:123 thread all</code> 在所有线程中相应的行上设置断点</li>\n<li><code>break apply ID1 ID2 cmd</code> 让一个或者多个线程执行gdb命令cmd</li>\n<li><code>break apply all cmd</code> 让所有被调试线程执行GDB命令command</li>\n<li><code>set print thread-events</code> <strong>设置线程创建提醒</strong>  当运行过程总产生新线程的时候会打印</li>\n<li><code>set scheduler-locking off|on|step</code> 这个是重点，经常被问到，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。<ul>\n<li>off 不锁定任何线程，也就是所有线程都执行，这是默认值。</li>\n<li>on 只有当前被调试程序会执行。.</li>\n<li>step 在单步的时候，除了next过一个函数的情况(熟悉情况的人可能知道，这其实是一个设置断点然后continue的行为)以外，只有当前线程会执行。该模式是对single-stepping模式的优化。此模式会阻止其他线程在当前线程单步调试时，抢占当前线。因此调试的焦点不会被以外的改变。其他线程不可能抢占当前的调试线程。其他线程只有下列情况下会重新获得运行的机会：当你‘next’一个函数调用的时候。当你使用诸如‘continue’、‘until‘、’finish‘命令的时候。其他线程遇到设置好的断点的时候。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li>调试C++或者C的宏<br>  在编译程序的时候，加上<code>-ggdb3</code>参数，这样就可以调试宏<ul>\n<li><code>info macro –</code> 你可以查看这个宏在哪些文件里被引用了，以及宏定义是什么样的。</li>\n<li><code>macro – </code>你可以查看宏展开的样子。</li>\n</ul>\n</li>\n<li>关联源文件<ul>\n<li>如果在编译情况下加上<code>-g</code>参数，那么就可以包含debug信息，否者gdb找不到符号表</li>\n<li>可以使用<code>directory</code>命令来设置源文件的目录<br>  <img src=\"http://genge.cc/wp-content/uploads/2018/09/942cbce8346b6e1ef65a32ea8c1919a9.png\"></li>\n</ul>\n</li>\n<li>条件断点<br>  基本语法<code> break  [where] if [condition]</code> 尤其是在一个循环或递归中，或是要监视某个变量。注意，这个设置是在GDB中的，只不过每经过那个断点时GDB会帮你检查一下条件是否满足。</li>\n<li>添加参数<ol>\n<li>gdb命令行的 –args 参数</li>\n<li>gdb环境中 set args命令。</li>\n</ol>\n</li>\n<li>设置变量<ol>\n<li>可以直接使用set命令 设置上下文环境变量值，可以模拟一些很难在测试中出现的情况，以防未来程序出错</li>\n<li>声明变量，然后使用，语法为<code>$name = 1</code></li>\n</ol>\n</li>\n<li>X命令<br>  平时我们一般使用p命令打印参数值，但是这个命令必须指定变量名，不知道变量名的时候，我们可以使用X命令<ol>\n<li>x\\x 以十六进制输出</li>\n<li>x\\d 以十进制输出</li>\n<li>x\\c 以单字符输出</li>\n<li>x\\i  反汇编 – 通常，我们会使用 x\\10i $ip-20 来查看当前的汇编（$ip是指令寄存器）</li>\n<li>x\\s 以字符串输出</li>\n</ol>\n</li>\n<li>command命令  把一组命令录制下来打包成‘宏’<br>  <img src=\"http://genge.cc/wp-content/uploads/2018/09/1bc671b5484282a324ff2d3b68863cb7.png\"></li>\n</ul>\n<ol start=\"2\">\n<li><p>循环队列判空 (OK)<br> 有三种方式处理这种问题</p>\n<ol>\n<li>队列Queue结构中保存一个计数器count表示当前队列元素个数（最简单粗暴），但count等于队列cap的时候就队列满，count为0的时候队列空</li>\n<li><strong>少用一个元素空间</strong>，约定以“队列头指针front在队尾指针rear的下一个位置上”作为队列“满”状态的标志。这种方法比较常用，但是面试官不让用…. front指向队首元素，rear指向队尾元素的下一个元素。即：<ul>\n<li>队空时： front&#x3D;rear</li>\n<li>队满时： (rear+1)%maxsize&#x3D;front</li>\n</ul>\n</li>\n<li>还有一个比较取巧的办法，优化第一种方案：使用一个状态flag变量，初始值为0，但入队成功置flag &#x3D; 1，当出队成功设置flag &#x3D; 0。我们可以使用 <code>front == rear &amp;&amp; flag</code> 表示队列满（在入队操作之后导致front&#x3D;rear），可以使用<code>front == rear &amp;&amp; ！flag</code>表示队列空（出队后导致f&#x3D;&#x3D;r，显然是队列空）</li>\n</ol>\n</li>\n<li><p>单向队列反转 (OK) 很简单</p>\n</li>\n</ol>\n<pre><code class=\"hljs cpp\">\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>\n&#123;\n    <span class=\"hljs-type\">int</span> data;\n    Node * next;\n&#125;;\n\n<span class=\"hljs-function\">Node* <span class=\"hljs-title\">reverse_list</span><span class=\"hljs-params\">(Node* head)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span>(head == <span class=\"hljs-literal\">nullptr</span>) <span class=\"hljs-keyword\">return</span> head;\n\n    Node* node = <span class=\"hljs-literal\">nullptr</span>;\n    node = head;\n    head = head-&gt;next;\n    node = <span class=\"hljs-literal\">nullptr</span>;\n\n    <span class=\"hljs-keyword\">while</span>(head != <span class=\"hljs-literal\">nullptr</span>)\n    &#123;\n        Node* next = head-&gt;next;\n        head-&gt;next = node;\n        node = head;\n        head = next;\n    &#125;\n\n    <span class=\"hljs-keyword\">return</span> node;\n&#125;\n</code></pre>\n\n<h2 id=\"现场面一面回忆总结\"><a href=\"#现场面一面回忆总结\" class=\"headerlink\" title=\"现场面一面回忆总结\"></a>现场面一面回忆总结</h2><p>估计是小组长之类的面试官吧，去之前我还特意看下自己的衣装是否整洁，这个面试官感觉是从<code>工地</code>上回来的，衣服上很脏，典型程序员面孔，他问的问题算是比较全面<br>操作系统（linux）、数据库（mysql）、算法、数据结构、计算机网络基础、网络编程、语言基础（C++语言）、并发、以及具体业务设计，还有项目基本介绍，游戏服务器架构简单介绍</p>\n<p>常见模块实现</p>\n<ol>\n<li><p>定时器实现方式目前应用比较多的有时间轮和最小堆方式 ， 优缺点其实就是算法复杂度：<br> 实现方式\tStartTimer\tStopTimer\tPerTickBookkeeping<br> 基于链表\t \tO(1)\t\tO(n)\t\tO(n)<br> 基于排序链表\tO(n)\t\tO(1)\t\tO(1)<br> 基于最小堆\t\tO(lgn)\t\tO(1)\t\tO(1)<br> 基于时间轮\t\tO(1)\t\tO(1)\t\tO(1)<br>https:\\<a href=\"http://www.ibm.com/developerworks/cn/linux/l-cn-timers/\">www.ibm.com\\developerworks\\cn\\linux\\l-cn-timers\\</a></p>\n</li>\n<li><p>斐波那契数 多种实现</p>\n<ol>\n<li>递归 最简单 粗暴  效率最低  存在大量重复计算</li>\n<li>循环叠加  算法复杂度为O（n）</li>\n<li>申请额外数组保存结果 去除重复计算 空间换时间</li>\n<li>利用数学公式推导，矩阵相乘推导公式，算法复杂度为O（logn）  效率最高<br> {f(n), f(n-1), f(n-1), f(n-2)} &#x3D;{1, 1, 1,0}n-1<br> {f(n), f(n-1), f(n-1), f(n-2)}<br> 详情见 https:\\<a href=\"http://www.cnblogs.com/python27/archive/2011/11/25/2261980.html\">www.cnblogs.com\\python27\\archive\\2011\\11\\25\\2261980.html</a></li>\n<li>通项公式  这个实在是牛逼  一个公式搞定…   不是数学系  这些方法确实想不出 只能记忆<pre><code class=\"hljs cpp\">  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Fibonacci</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-type\">double</span> tmp=<span class=\"hljs-built_in\">sqrt</span>(<span class=\"hljs-built_in\">double</span>(<span class=\"hljs-number\">5</span>));\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">int</span>((<span class=\"hljs-built_in\">pow</span>((<span class=\"hljs-number\">1</span>+tmp)\\<span class=\"hljs-number\">2</span>,n)-<span class=\"hljs-built_in\">pow</span>((<span class=\"hljs-number\">1</span>-tmp)\\<span class=\"hljs-number\">2</span>,n))\\tmp);\n&#125;\n</code></pre></li>\n<li>定理<pre><code class=\"hljs cpp\">  <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">Fibonacci</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span></span>\n<span class=\"hljs-function\"></span>&#123;\n    <span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">0</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">if</span>(n==<span class=\"hljs-number\">1</span>||n==<span class=\"hljs-number\">2</span>)<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;    \\\\当n&gt;=<span class=\"hljs-number\">3</span>时，n&gt;n\\<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-type\">int</span> x=<span class=\"hljs-built_in\">Fibonacci</span>(n\\<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-type\">int</span> y=<span class=\"hljs-built_in\">Fibonacci</span>(n\\<span class=\"hljs-number\">2</span>+<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">if</span>(n&amp;<span class=\"hljs-number\">1</span>)<span class=\"hljs-keyword\">return</span> x*x+y*y;\n    <span class=\"hljs-keyword\">return</span> x*(<span class=\"hljs-number\">2</span>*y-x);\n&#125;</code></pre></li>\n</ol>\n</li>\n<li><p>敏感字过滤算法</p>\n<ol>\n<li>正则匹配  面试官一般不会让你用这个 因为要匹配的内容太多  写正则表达式就很烦…  效率还不高  KMP算法 太慢 不能用</li>\n<li>自己当时想到的一张方法为字典树TrieTree  这个方法太耗空间 时间复杂度为O(key_max_len) 很多生产环境确实是用这个实现的，别名有限状态机 DFA：DFA即Deterministic Finite Automaton，也就是确定有穷自动机</li>\n<li>其他什么优化算法 其实也不用</li>\n</ol>\n</li>\n<li><p>数据库</p>\n<ol>\n<li><p>数据库事务特性<br>  ACID  原子性  一致性  隔离性  持久性dura</p>\n</li>\n<li><p>事务隔离级别 </p>\n<pre><code>  隔离级别               脏读（Dirty Read）          不可重复读（NonRepeatable Read）     幻读（Phantom Read） \n</code></pre>\n<p>  未提交读（Read uncommitted）        可能                            可能                       可能</p>\n<p>  已提交读（Read committed）          不可能                          可能                       可能</p>\n<p>  可重复读（Repeatable read）         不可能                          不可能                     可能</p>\n<p>  可串行化（Serializable ）           不可能                          不可能                     不可能</p>\n<p>  ·未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据（事务之间关系）<br>  ·提交读(Read Committed)：只能读取到已经提交的数据。<strong>Oracle等多数数据库默认都是该级别</strong> (不重复读) （事务之间关系）<br>  ·可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，<strong>InnoDB默认级别</strong>。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读 （事务内部）<br>  ·串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞\t\t<br>  可重复读和提交读是矛盾的。在同一个事务里，如果保证了可重复读，就会看不到其他事务的提交，违背了提交读；如果保证了提交读，就会导致前后两次读到的结果不一致，违背了可重复读。<br>  可以这么讲，InnoDB提供了这样的机制，在默认的可重复读的隔离级别里，可以使用加锁读去查询最新的数据（提交读）。<br>  MySQL InnoDB的可重复读并不保证避免幻读，需要应用使用加锁读来保证。而这个加锁度使用到的机制就是next-key locks。<br>  总结:<a href=\"http://www.cnblogs.com/zhoujinyi/p/3437475.html\">MySQL 四种事务隔离级的说明 - jyzhou - 博客园</a><br>  四个级别逐渐增强，每个级别解决一个问题。事务级别越高,性能越差,大多数环境read committed 可以用.记住4个隔离级别的特点(上面的例子);<a href=\"http://www.cnblogs.com/zhoujinyi/p/3437475.html\">http:\\\\www.cnblogs.com\\zhoujinyi\\p\\3437475.html</a></p>\n</li>\n<li><p>事务实现原理<br> https:\\draveness.me\\mysql-transaction 介绍事务ACID的火滚日志实现 https:\\<a href=\"http://www.cnblogs.com/wy123/p/8365234.html\">www.cnblogs.com\\wy123\\p\\8365234.html</a> 具体日志格式</p>\n</li>\n<li><p>innodb和myisam存储引擎的区别 https:\\blog.csdn.net\\xifeijian\\article\\details\\20316775</p>\n<ul>\n<li>MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持，MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快，但是不提供事务支持，而InnoDB提供事务支持以及外部键等高级数据库功能。</li>\n<li>InnoDB不支持FULLTEXT类型的索引。</li>\n<li>InnoDB 中不保存表的具体行数，也就是说，执行select count(<em>) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含 where条件时，两种表的操作是一样的。</li>\n<li>对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。</li>\n<li>细节可以看链接 https:\\blog.csdn.net\\xifeijian\\article\\details\\20316775和下面一个介绍</li>\n<li>https:\\<a href=\"http://www.jianshu.com/p/a957b18ba40d\">www.jianshu.com\\p\\a957b18ba40d</a></li>\n</ul>\n</li>\n<li><p>对于like查询啥时候会用到索引 http:\\thephper.com?p&#x3D;142</p>\n<blockquote>\n<p> like 不能用索引？ 这个确实不知道 难受<br> 尽量减少like，但不是绝对不可用，”xxxx%” 是可以用到索引的，<br> 想象一下，你在看一本成语词典，目录是按成语拼音顺序建立，查询需求是，你想找以 “一”字开头的成语（”一%“），和你想找包含一字的成语（“%一%”）<br> 除了like，以下操作符也可用到索引：<br> &lt;，&lt;&#x3D;，&#x3D;，&gt;，&gt;&#x3D;，BETWEEN，IN<br> &lt;&gt;，not in ，！&#x3D;则不行</p>\n</blockquote>\n</li>\n<li><p>索引类型<br>  https:\\segmentfault.com\\q\\1010000003832312           http:\\blog.codinglabs.org\\articles\\theory-of-mysql-index.html</p>\n</li>\n</ol>\n</li>\n</ol>\n"},{"title":"Redis Guide 使用手册","date":"2020-07-10T10:28:44.000Z","_content":"\n# Redis 数据结构与应用\n\n## 普通字符串\n\n### SET 命令\n\n1. SET KEY VALUE 设置\n2. NX 不存在才设置  可用于实现分布式锁\n3. XX 存在才设置\n\n### GET 命令\n\n1. GET KEY 返回 VALUE 值  \n2. GETSET 返回旧 OLD_VALUE 值 , 并且设置新 NEW_VALUE\n\n### MSET 命令\n\n1. MSET KEY1 VALUE1 [ KEY2 VALUE2 ...] 一次设置多个键值对\n\n### MGET 命令\n\n1. MGET KEY1 [ KEY2 ...] 一次设置多个键值对\n   返回VALUE列表, 这在批量获取多个键值对的时候非常实用, 业务层不用做封装\n\n### MSETNX 命令\n\n1.  MSETNX KEY VALUE [ KEY2 VALUE2 ...] \n   设置多个键值对, 这是一个原子操作, 当且仅当所有KEY都不存在的时候才会成功\n\n### STRLEN 命令\n\n1. STRLEN KEY 获取值的字节长度\n\n### GETRANGE 命令\n\n1. GETRANGE KEY start end \n   根据指定索引范围设置值，相当于取值的子串\n\n### SETRANGE 命令\n\n1. SETRANGE KEY startIndex substitute \n   根据指定开始索引，开始替换新串substitute; 当startIndex大于值长度(len - 1), redis会自动扩展值长度，并且填充空字节(\\x00)\n\n### APPEND 命令\n\n1. APPEND KEY suffix 对值进行追加操作, 并返回新串长度\n   当KEY不存在, 那么APPEND命令等价于SET操作\n\n### INCRBY DECRBY 命令\n\n1. INCRBY/DECRBY KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减\n   当KEY不存在，那么会被初始化为0，然后再进行操作\n\n### INCR DECR 命令\n\n1. INCR/DECR KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减1\n   当KEY不存在，那么会被初始化为0，然后再进行操作\n\n### INCRBYFLOAT 命令\n\n1. INCRBYFLOAT KEY incrment， 命令与INCRBY无差别，主要是针对的是浮点数\n   但是没有DECRBYFLOAT命令，可以通过设置incrment为负数来实现减法\n   INCRBYFLOAT 命令对值的格式更加宽松，那么值是整数的时候，命令与INCRBY等同，存储的值也会是整数\n   注意Redis在处理浮点数的时候，小数位长度是有限制，最长为17位，对于大部分应用是足够的\n\n\n## 散列\n\n### 结构\n\n|   KEY      |       FIELD       |         VALUE        |\n|  :----:    |      :----:       |      :----:          |\n|article     |     title         |     \"Hello World\"    |\n|            |     content       |     \"son of bitch\"   |\n|            |     author        |     genge            |\n|            |     created_at    |     2010-10-10       |\n\n### HSET 命令\n\n1. HSET HASHKEY FIELD VALUE\n   如果key或者field不存在, 那么会创建，返回值为1\n   如果field存在, 那么会更新，返回值为0\n\n### HSETNX 命令\n\n1. HSETNX HASH FIELD VALUE\n   只在字段不存在的时候设置值，返回值为1，设置失败返回0\n\n### HGET 命令\n\n1. HGET HASH FIELD VALUE\n   获取字段值\n\n### HINCRBY or HINCRFLOATBY\n\n1. HINCRBY HASH FIELD INCRMENT 对数值进行加减\n\n\n### HSTRLEN 命令\n\n1. HSTRLEN HASH FIELD 获取字段值长度\n\n### HEXISTS 命令\n\n1. 检查字段值是否存在\n\n### HDEL 命令\n\n1. HDEL HASH FILED 删除字段\n\n### HLEN 命令\n\n1. HLEN HASH 获取散列表字段个数\n\n### HMSET/HMGET 系列命令\n\n1. 效果同MSET/MGET\n\n### HKEYS/HVALS/HGETALL 命令\n\n1. 获取散列表中所有字段FIELD\n2. 获取散列表中所有VALUE\n3. 获取散列表中所有FIELD和VALUE\n   格式为数组： FIELD1:VALUE1:FILED2:VALUE2......\n\n## List列表结构\n\n### Redis List列表是一种线性的有序结构\n\n### LPUSH 命令\n\n1. LPUSH KEY VALUE0 [ VALUE1 VALUE2 ...]  返回推入会列表元素个数\n   向列表左端新增n个VALUE, 'L' 表示是left 而不是 list\n\n### RPUSH 命令\n\n1. RPUSH KEY VALUE0 [ VALUE1 VALUE2 ...] 返回推入会列表元素个数\n   向列表右端新增n个VALUE, 'R' 表示是right\n\n### RPUSHX/LPUSHX 命令\n\n1. 与上两个命令同，但是在列表KEY不存在的时候的结果不一样，这两个命令在列表KEY不存在的时候会推入失败， 返回0\n\n### LPOP/RPOP\n\n1. LPOP/RPOP LISTKEY 弹出最左边/右边的元素， 返回POP后的元素\n\n### RPOPLPUSH 命令\n\n1. RPOPLPUSH source target 返回被弹出的元素值\n   将源source列表最右端元素弹出，插入到目标target列表最左端\n   其中source和target可以相同，即将列表首尾对调\n   当source 为空时，执行会失败，返回空\n\n### LLEN 命令\n\n1. 获取列表长度\n\n### LINDEX 命令\n\n1. LINDEX list index 获取列表指定索引元素\n   index为正数： 左端为0， 范围为 0 -- N-1\n   index为负数： 右端为-1， 范围为 -N -- -1\n\n### LRANGE 命令\n\n1. 获取指定索引范围内的所有元素\n   LRANGE list start end\n   LRANGE list 0 -1 获取全部元素\n   当start和end都超出范围时，将会返回空列表；当只有一个超出时，Redis会对超出的索引进行修正，开始索引超出会被修正为0，结束索引会被修正为-1\n\n### LSET 命令\n\n1. LSET list index new_value\n   对列表指定索引元素值更新\n\n### LINSERT 命令\n\n1. LINSERT list BEFORE/AFTER target_element new_element\n\n### LTRIM 裁剪\n\n1. LTRIM list start index 删除索引范围外所有元素\n\n### LREM 移除\n\n1. LREM list count element  返回被移除的元素数量\n   - 如果count等于0，那么命令将会移除list中所有值等于element的元素\n   - 如果count等于正数，那么命令会从左端开始扫描，移除列表中值为element的count个元素\n   - 如果count等于负数，那么命令会从右端开始扫描，移除列表中值为element的abs(count)个元素\n\n### BLPOP 阻塞式左端弹出\n\n1. BLPOP list1 [ list2 list3 ...] timeout\n   - 命令会按照传入的列表从左至右挨个检查是否为空，如果发现某个列表不为空，那么执行LPOP操作，返回值为两个元素的数组，第一个元素是被弹出的列表list名，第二个元素是被弹出的元素值；\n   - 如果当前传入的所有list为空，那么Redis将会阻塞等待直至timeout超时，返回空值，超时时间单位为秒，设置为0时表示会一直等待\n   - 如果当前有多个客户端因为某个列表空而阻塞，那么按照先阻塞先服务原则进行唤醒\n   - 这个命令只会当前Redis客户端\n\n### BRPOP 命令 与上同\n\n### BRPOPLPUSH 阻塞式弹出和推入操作 与上同\n\n1. 可用于实现带有阻塞式的消息队列\n\n## 无序集合Set\n\n### 数据结构\n\n说明无序集合，集合中元素不重复\n\n### SADD 命令\n\nSADD set element [ element ...]\n\n返回值为新增元素个数，会去重\n\n### SREM 命令\n\nSREM set element [element ...]\n移除一个或多个元素，返回真实移除元素的个数\n\n### SMOVE 命令\n\n`SMOVE source target element` 将指定元素从source移除，并且加入到目标集合，当source中不存在element的时候会返回失败\n\n### SMEMBERS 命令\n\n`SMEMBERS set` 获取集合所有元素\n\n### SCARD 命令\n\n1. `SCARD set` 获取集合元素个数\n\n### SISMEMBER 命令\n\n1. `SISMEMBER set element` 判断指定元素是否存在集合中\n\n### SRANDMEMBER 命令\n\n1. `SRANDMEMBER SET [count]` 随机获取集合汇总count个元素，count默认值为1\n\n2. count为正数时候，返回随机不重复的min(count, SCARD) 个元素，属于不放回随机抽取\n3. count为负数的时候，随机的机制发生变化，属于放回随机抽取，也就是说返回集合有可能出现重复的元素\n\n### SPOP 命令\n\n1. `SPOP set [count]` 随机的重集中移除count个元素，返回被移除的元素集合\n\n### SINTER/SINTERSTORE 命令\n\n1. `SINTER set [set]` 求多个集合的交集\n\n2. `SINTER dest_set set [set ]` 求多个集合的交集，并将结果存储到新的集合中，返回新集合的元素个数\n\n### SUNION/SUNIONSTORE 命令\n\n1. 并集, 含义同上\n\n### SDIFF/SDIFFSTORE 命令\n\n1. 差集，含义同上\n2. 集合操作都非常消耗性能，可能导致Redis主线程阻塞\n\n## 有序集合Sorted SET\n\n### 对应数据结构\n\n1. 同时具有有序和集合的性质\n2. 每个元素都由一个成员和一个与成员相关联的分值score组成\n3. 排行榜最佳实现\n\n`sorted set`\n|score   | member  |\n|:----:  |  :----: |\n| 1 | genge |\n| 3 | apple |\n| 7 | inuby |\n| 7 | oiuby |\n| 19| qwmok |\n\n### ZADD 命令\n\n1. `ZADD sorted_set [CH] score element [score element]` 向有序集合中添加元素\n2. 默认返回新添加元素的个数，当命令带 CH 的时候返回修改元素的个数\n\n### ZREM 命令\n\n1. `ZREM sorted_set member [member]`  移除指定元素  返回真实被移除的元素个数\n\n### ZSCORE 命令\n\n1. `ZSCORE sorted_set member` 获取指定元素的分值\n\n### ZINCRBY 命令\n\n1. `ZINCRBY sorted_set increment_score memeber` 对指定元素的分值加减\n2. 当member不存在的时候，命令等同于ZADD\n\n### ZCARD 命令\n\n1. 获取有序集合元素个数\n\n### ZRANK/ZREVRANK 命令\n\n1. `ZRANK sorted_set member` 指定元素的的正排名 （从小到大）\n2. `ZREVRANK sorted_set member` 指定元素的的排名 （从大到小）\n\n### ZRANGE / ZREVRANGE 命令\n\n1. 获取指定范围内成员 `ZRANGE/ZREVRANGE sorted_set start end`\n2. start 和 end均可接受负值, 含义是排名\n3. `ZRANGE/ZREVRANGE sorted_set start end WITHSCORES` 会返回分值和元素值\n\n### ZRANGEBYSCORE/ZREVRANGEBYSCORE 命令\n\n1. `ZRANGEBYSCORE/ZREVRANGEBYSCORE sorted_set min max/max min` 获取指定范围分数内的成员\n2. `WITHSCORES` 可以附带返回分数值\n3. `LIMIT offset count` 可以限制返回元素的数量， offset为起止偏移量，count为最大返回数量\n4. `(min (max` 使用左括号的表示开区间，默认是闭区间\n5. `-inf +inf`来表示负无穷和正无穷\n\n### ZCOUNT 命令\n\n1. `ZCOUNT sorted_set min max` 获取指定分值范围内的成员数量\n2. 和上面的RAGNE命令相同，都支持开闭区间无穷等设置\n\n### ZREMRANGEBYRANK 命令\n\n1. `ZREMRANGEBYRANK sorted_set start end` 根据给定的排名区间来移除成员\n2. 参数支持负值，表示倒数排名\n\n### ZREMRANGEBYSCORE 命令\n\n1. `ZREMRANGEBYSCORE sorted_set start end` 根据给定的分数区间来移除成员\n2. 和上面的RAGNE命令相同，都支持开闭区间无穷等设置\n\n### ZINTERSTORE/ZUNIONSTORE 命令\n\n1. `ZINTERSTORE/ZUNIONSTORE destination numbers sorted_set [sorted_set ]` 求多个集合的交集和并集\n2. numbers为sorted_set 参数的个数\n3. 返回交集元素或者并集元素个数\n4. 集合元素的分值是由两个集合分值的和\n5. `[AGGREGATE SUM/MIN/MAX]` 可以通过设置聚合函数来控制分值(求和/最小值/最大值)\n6. `[WEIGHTS w1 w2 w3]` 可以为每个集合设置权重，这样计算方式将会是分值乘以权重再相加\n7. 除此之外，还可以接受集合（非有序）来执行命令，此时score默认都是1，还可以带WEIGHTS\n\n### ZEANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT/ZREMRANGEBYLEX 系列命令\n\n1. 以上所有命令格式雷同，都是处理当有序集合中分数全部相当的情况min和max分别指定是字典字母\n2. `ZEANGEBYLEX sorted_set min max`\n3. 比如`ZEANGEBYLEX sorted_set - +`返回所有成员，`[a (t` 返回字典大于等于a并且小于t的所有成员\n4. 逆序/成员个数/移除操作都是类似的\n\n### ZPOPMAX/ZPOPMIN 命令\n\n1. 弹出分值最高或者最低分值的元素\n2. 返回成员和分值\n3. `ZPOPMAX sorted_set [count]`可以通过 count 来指定最多移除的成员数量，默认为1\n4. Redis5.0  以上版本才支持\n\n### BZPOPMIN/BZPOPMAX 命令\n\n1. 阻塞式的最小或最大的弹出操作, 可以接受多个集合参数，进行遍历检测\n2. `BZPOPMIN/BZPOPMAX sorted_set [sorted_set ] timeout`\n3. timeout 为 0 表示无限阻塞等待\n\n## HperLogLog\n\n### HperLogLog数据结构\n\n1. 神奇的HyperLogLog算法<http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html>\n2. Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure <http://content.research.neustar.biz/blog/hll.html>\n3. 这是一个专门解决大数据计数器消耗太多内存问题的一个概率算法，只需要12k就可以统计2^64个元素\n4. 当然这不是精确统计，存在误差，数据量大的时候误差有的时候是允许的，可容允的\n\n### PFADD 命令\n\n1. `PFADD hperloglog element [element]` 新增元素\n2. 当新增元素是的统计基数值发生变化就返回1，否则反正0\n\n### PFCOUNT 命令\n\n1. `PFCOUNT hyperloglog [hyperloglog ...]` 计算集合的近视基数\n2. 当参数为多个时候，计算方式为：首先求多个集合的并集，然后对并集求近视基数\n\n### PFMERGE 命令\n\n1. `PFMERGE destination hyperloglog [hyperloglog ...]`  对多个hyperloglog集合求并集，然后将结果存在dest中\n\n2. PFCOUNT 其实是有调用PFMERGE命令的\n\n## 位图\n\n### 位图结构\n\n1. Redis位图bitmap是由多个二进制位组成的数组，数组中每一位都有与之对应的偏移量(索引)\n\n2. BITMAP 图\n\n|index|0|1|2|3|\n|-|-|-|-|-|\n|位|1|0|0|1｜\n\n### SETBIT 命令\n\n1. `SETBIT bitmap offset value` 设置指定偏移位的值\n2. 返回指定偏移量旧值，默认为0\n3. bitmap默认按照字节扩展\n4. offset只能为正值\n\n### GETBIT 命令\n\n1. `GETBIT bitmap offset`获取指定位置的值\n\n### BITCOUNT 命令\n\n1. `BITCOUNT bitmap` 统计位图中1的个数\n2. `BITCOUNT bitmap start end`  返回指定字节范围内1的个数，注意start和end为字节偏移量，并不是位offset， 可以使用负数作为参数\n\n### BITPOS 命令\n\n1. `BITPOS bitmap value` 查询bitmap中第一个被设置为value值的位置\n2. `BITPOS bitmap value [start end]`  在指定范围内查找，但是返回的offset是基于整个bigmap的偏移\n3. start和end可以为负值\n\n### BITOP 命令\n\n1. `BITOP OP result_key bitmap [bitmap ...]` 对多个bitmap数组执行op操作，将结果存储在result中\n2. op可以是 AND / OR /XOR / NOT\n\n### BITFIELD 命令\n\n1. `BITFIELD bitmap SET type offset value` 根据位偏移来设置bitmap中值value，其中type是指定value的类型，比如i8：8位有符号，u16：16位无符号等\n2. offset 可以换成 #index， 这样可以以字节位来索引具体位置，然后设置值\n3. 可以同时执行多个set命令\n4. `BITFIELD bitmap GET type offset/#index` 获取对应的值，同样的也可以同时执行多个GET\n5. `BITFIELD bitmap INCRYBY type offset/#index increment` 对指定范围值加减操作\n6. `BITFIELD bitmap [OVERFLOW WRAP/SAT/FAIL] INCRYBY type offset/#index increment` 可以用来处理加减法结果溢出的情况，分别为环绕/饱和运算/失败\n\n### BITMAP STRING\n\n1. 可以把二进制数组当作是字符串来操作\n2. GET 命令来获取二进制数组值，返回值为二进制字符串\n3. STRLEN 可以得到二进制字符串的长度\n4. GETRANGE 获取指定范围的二进制字符串\n\n## GEO位置服务\n\n### GEOADD 命令\n\n1. `GEOADD location_set longitude latitude name [longitude latitude name]` 添加一个或者多个位置坐标（经纬度）\n2. 当执行的是添加的，那么返回添加的位置个数；如果是更新那么返回0\n\n### GEOPOS 命令\n\n1. `GEOPOS location_set name [name ...]`  获取指定位置的经纬度\n2. 返回值是数组，其中数组元素为二元数组，第一项为经度，第二项为纬度\n\n### GEODIST 命令\n\n1. `GEODIST location_set name1 name2` 计算俩个位置的直线距离\n2. 默认单位为米，可以通过`[unit]` 来指定单位m/km/mi英里/ft英寸\n\n### GEORADIUS 命令\n\n1. `GEORADIUS location_set longitude latitude radius unit`  获取指定位置为中心点，radius半径内所有的地点\n2. `WITHDIST` 加上这个后缀参数，可以返回地点和地点与中心位置的直线距离\n3. `WITHCOORD`  返回地点和地点坐标\n4. `[ASD|DESC]` 对返回的结果排序\n5. `[COUNT n]`  限制返回地点的数量\n6. 可以同时指定多个可选参数\n\n### GEORADIUSBYMEMBER 命令\n\n1. `longitude latitude` 参数换成 `name`地名\n\n### GEOHASH 命令\n\n1. 获取指定位置的GEOhash值，GEOhash值是经纬度转换而来，并且可以通过GEohash来计算得到经纬度\n2. 在上面的两个命令中都可以指定`WITHHASH`  来返回GEOHASH 而非 经纬度\n\n### GEO数据内部存储结构\n\n1. 为有序集合，因此可以使用ZSORTED来操作数据，其中score为Geohash值\n\n## Stream流\n\n","source":"_posts/Redis-Guide.md","raw":"---\ntitle: 'Redis Guide 使用手册'\ndate: 2020-07-10 18:28:44\ntags: Redis\ncategories: Redis\n---\n\n# Redis 数据结构与应用\n\n## 普通字符串\n\n### SET 命令\n\n1. SET KEY VALUE 设置\n2. NX 不存在才设置  可用于实现分布式锁\n3. XX 存在才设置\n\n### GET 命令\n\n1. GET KEY 返回 VALUE 值  \n2. GETSET 返回旧 OLD_VALUE 值 , 并且设置新 NEW_VALUE\n\n### MSET 命令\n\n1. MSET KEY1 VALUE1 [ KEY2 VALUE2 ...] 一次设置多个键值对\n\n### MGET 命令\n\n1. MGET KEY1 [ KEY2 ...] 一次设置多个键值对\n   返回VALUE列表, 这在批量获取多个键值对的时候非常实用, 业务层不用做封装\n\n### MSETNX 命令\n\n1.  MSETNX KEY VALUE [ KEY2 VALUE2 ...] \n   设置多个键值对, 这是一个原子操作, 当且仅当所有KEY都不存在的时候才会成功\n\n### STRLEN 命令\n\n1. STRLEN KEY 获取值的字节长度\n\n### GETRANGE 命令\n\n1. GETRANGE KEY start end \n   根据指定索引范围设置值，相当于取值的子串\n\n### SETRANGE 命令\n\n1. SETRANGE KEY startIndex substitute \n   根据指定开始索引，开始替换新串substitute; 当startIndex大于值长度(len - 1), redis会自动扩展值长度，并且填充空字节(\\x00)\n\n### APPEND 命令\n\n1. APPEND KEY suffix 对值进行追加操作, 并返回新串长度\n   当KEY不存在, 那么APPEND命令等价于SET操作\n\n### INCRBY DECRBY 命令\n\n1. INCRBY/DECRBY KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减\n   当KEY不存在，那么会被初始化为0，然后再进行操作\n\n### INCR DECR 命令\n\n1. INCR/DECR KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减1\n   当KEY不存在，那么会被初始化为0，然后再进行操作\n\n### INCRBYFLOAT 命令\n\n1. INCRBYFLOAT KEY incrment， 命令与INCRBY无差别，主要是针对的是浮点数\n   但是没有DECRBYFLOAT命令，可以通过设置incrment为负数来实现减法\n   INCRBYFLOAT 命令对值的格式更加宽松，那么值是整数的时候，命令与INCRBY等同，存储的值也会是整数\n   注意Redis在处理浮点数的时候，小数位长度是有限制，最长为17位，对于大部分应用是足够的\n\n\n## 散列\n\n### 结构\n\n|   KEY      |       FIELD       |         VALUE        |\n|  :----:    |      :----:       |      :----:          |\n|article     |     title         |     \"Hello World\"    |\n|            |     content       |     \"son of bitch\"   |\n|            |     author        |     genge            |\n|            |     created_at    |     2010-10-10       |\n\n### HSET 命令\n\n1. HSET HASHKEY FIELD VALUE\n   如果key或者field不存在, 那么会创建，返回值为1\n   如果field存在, 那么会更新，返回值为0\n\n### HSETNX 命令\n\n1. HSETNX HASH FIELD VALUE\n   只在字段不存在的时候设置值，返回值为1，设置失败返回0\n\n### HGET 命令\n\n1. HGET HASH FIELD VALUE\n   获取字段值\n\n### HINCRBY or HINCRFLOATBY\n\n1. HINCRBY HASH FIELD INCRMENT 对数值进行加减\n\n\n### HSTRLEN 命令\n\n1. HSTRLEN HASH FIELD 获取字段值长度\n\n### HEXISTS 命令\n\n1. 检查字段值是否存在\n\n### HDEL 命令\n\n1. HDEL HASH FILED 删除字段\n\n### HLEN 命令\n\n1. HLEN HASH 获取散列表字段个数\n\n### HMSET/HMGET 系列命令\n\n1. 效果同MSET/MGET\n\n### HKEYS/HVALS/HGETALL 命令\n\n1. 获取散列表中所有字段FIELD\n2. 获取散列表中所有VALUE\n3. 获取散列表中所有FIELD和VALUE\n   格式为数组： FIELD1:VALUE1:FILED2:VALUE2......\n\n## List列表结构\n\n### Redis List列表是一种线性的有序结构\n\n### LPUSH 命令\n\n1. LPUSH KEY VALUE0 [ VALUE1 VALUE2 ...]  返回推入会列表元素个数\n   向列表左端新增n个VALUE, 'L' 表示是left 而不是 list\n\n### RPUSH 命令\n\n1. RPUSH KEY VALUE0 [ VALUE1 VALUE2 ...] 返回推入会列表元素个数\n   向列表右端新增n个VALUE, 'R' 表示是right\n\n### RPUSHX/LPUSHX 命令\n\n1. 与上两个命令同，但是在列表KEY不存在的时候的结果不一样，这两个命令在列表KEY不存在的时候会推入失败， 返回0\n\n### LPOP/RPOP\n\n1. LPOP/RPOP LISTKEY 弹出最左边/右边的元素， 返回POP后的元素\n\n### RPOPLPUSH 命令\n\n1. RPOPLPUSH source target 返回被弹出的元素值\n   将源source列表最右端元素弹出，插入到目标target列表最左端\n   其中source和target可以相同，即将列表首尾对调\n   当source 为空时，执行会失败，返回空\n\n### LLEN 命令\n\n1. 获取列表长度\n\n### LINDEX 命令\n\n1. LINDEX list index 获取列表指定索引元素\n   index为正数： 左端为0， 范围为 0 -- N-1\n   index为负数： 右端为-1， 范围为 -N -- -1\n\n### LRANGE 命令\n\n1. 获取指定索引范围内的所有元素\n   LRANGE list start end\n   LRANGE list 0 -1 获取全部元素\n   当start和end都超出范围时，将会返回空列表；当只有一个超出时，Redis会对超出的索引进行修正，开始索引超出会被修正为0，结束索引会被修正为-1\n\n### LSET 命令\n\n1. LSET list index new_value\n   对列表指定索引元素值更新\n\n### LINSERT 命令\n\n1. LINSERT list BEFORE/AFTER target_element new_element\n\n### LTRIM 裁剪\n\n1. LTRIM list start index 删除索引范围外所有元素\n\n### LREM 移除\n\n1. LREM list count element  返回被移除的元素数量\n   - 如果count等于0，那么命令将会移除list中所有值等于element的元素\n   - 如果count等于正数，那么命令会从左端开始扫描，移除列表中值为element的count个元素\n   - 如果count等于负数，那么命令会从右端开始扫描，移除列表中值为element的abs(count)个元素\n\n### BLPOP 阻塞式左端弹出\n\n1. BLPOP list1 [ list2 list3 ...] timeout\n   - 命令会按照传入的列表从左至右挨个检查是否为空，如果发现某个列表不为空，那么执行LPOP操作，返回值为两个元素的数组，第一个元素是被弹出的列表list名，第二个元素是被弹出的元素值；\n   - 如果当前传入的所有list为空，那么Redis将会阻塞等待直至timeout超时，返回空值，超时时间单位为秒，设置为0时表示会一直等待\n   - 如果当前有多个客户端因为某个列表空而阻塞，那么按照先阻塞先服务原则进行唤醒\n   - 这个命令只会当前Redis客户端\n\n### BRPOP 命令 与上同\n\n### BRPOPLPUSH 阻塞式弹出和推入操作 与上同\n\n1. 可用于实现带有阻塞式的消息队列\n\n## 无序集合Set\n\n### 数据结构\n\n说明无序集合，集合中元素不重复\n\n### SADD 命令\n\nSADD set element [ element ...]\n\n返回值为新增元素个数，会去重\n\n### SREM 命令\n\nSREM set element [element ...]\n移除一个或多个元素，返回真实移除元素的个数\n\n### SMOVE 命令\n\n`SMOVE source target element` 将指定元素从source移除，并且加入到目标集合，当source中不存在element的时候会返回失败\n\n### SMEMBERS 命令\n\n`SMEMBERS set` 获取集合所有元素\n\n### SCARD 命令\n\n1. `SCARD set` 获取集合元素个数\n\n### SISMEMBER 命令\n\n1. `SISMEMBER set element` 判断指定元素是否存在集合中\n\n### SRANDMEMBER 命令\n\n1. `SRANDMEMBER SET [count]` 随机获取集合汇总count个元素，count默认值为1\n\n2. count为正数时候，返回随机不重复的min(count, SCARD) 个元素，属于不放回随机抽取\n3. count为负数的时候，随机的机制发生变化，属于放回随机抽取，也就是说返回集合有可能出现重复的元素\n\n### SPOP 命令\n\n1. `SPOP set [count]` 随机的重集中移除count个元素，返回被移除的元素集合\n\n### SINTER/SINTERSTORE 命令\n\n1. `SINTER set [set]` 求多个集合的交集\n\n2. `SINTER dest_set set [set ]` 求多个集合的交集，并将结果存储到新的集合中，返回新集合的元素个数\n\n### SUNION/SUNIONSTORE 命令\n\n1. 并集, 含义同上\n\n### SDIFF/SDIFFSTORE 命令\n\n1. 差集，含义同上\n2. 集合操作都非常消耗性能，可能导致Redis主线程阻塞\n\n## 有序集合Sorted SET\n\n### 对应数据结构\n\n1. 同时具有有序和集合的性质\n2. 每个元素都由一个成员和一个与成员相关联的分值score组成\n3. 排行榜最佳实现\n\n`sorted set`\n|score   | member  |\n|:----:  |  :----: |\n| 1 | genge |\n| 3 | apple |\n| 7 | inuby |\n| 7 | oiuby |\n| 19| qwmok |\n\n### ZADD 命令\n\n1. `ZADD sorted_set [CH] score element [score element]` 向有序集合中添加元素\n2. 默认返回新添加元素的个数，当命令带 CH 的时候返回修改元素的个数\n\n### ZREM 命令\n\n1. `ZREM sorted_set member [member]`  移除指定元素  返回真实被移除的元素个数\n\n### ZSCORE 命令\n\n1. `ZSCORE sorted_set member` 获取指定元素的分值\n\n### ZINCRBY 命令\n\n1. `ZINCRBY sorted_set increment_score memeber` 对指定元素的分值加减\n2. 当member不存在的时候，命令等同于ZADD\n\n### ZCARD 命令\n\n1. 获取有序集合元素个数\n\n### ZRANK/ZREVRANK 命令\n\n1. `ZRANK sorted_set member` 指定元素的的正排名 （从小到大）\n2. `ZREVRANK sorted_set member` 指定元素的的排名 （从大到小）\n\n### ZRANGE / ZREVRANGE 命令\n\n1. 获取指定范围内成员 `ZRANGE/ZREVRANGE sorted_set start end`\n2. start 和 end均可接受负值, 含义是排名\n3. `ZRANGE/ZREVRANGE sorted_set start end WITHSCORES` 会返回分值和元素值\n\n### ZRANGEBYSCORE/ZREVRANGEBYSCORE 命令\n\n1. `ZRANGEBYSCORE/ZREVRANGEBYSCORE sorted_set min max/max min` 获取指定范围分数内的成员\n2. `WITHSCORES` 可以附带返回分数值\n3. `LIMIT offset count` 可以限制返回元素的数量， offset为起止偏移量，count为最大返回数量\n4. `(min (max` 使用左括号的表示开区间，默认是闭区间\n5. `-inf +inf`来表示负无穷和正无穷\n\n### ZCOUNT 命令\n\n1. `ZCOUNT sorted_set min max` 获取指定分值范围内的成员数量\n2. 和上面的RAGNE命令相同，都支持开闭区间无穷等设置\n\n### ZREMRANGEBYRANK 命令\n\n1. `ZREMRANGEBYRANK sorted_set start end` 根据给定的排名区间来移除成员\n2. 参数支持负值，表示倒数排名\n\n### ZREMRANGEBYSCORE 命令\n\n1. `ZREMRANGEBYSCORE sorted_set start end` 根据给定的分数区间来移除成员\n2. 和上面的RAGNE命令相同，都支持开闭区间无穷等设置\n\n### ZINTERSTORE/ZUNIONSTORE 命令\n\n1. `ZINTERSTORE/ZUNIONSTORE destination numbers sorted_set [sorted_set ]` 求多个集合的交集和并集\n2. numbers为sorted_set 参数的个数\n3. 返回交集元素或者并集元素个数\n4. 集合元素的分值是由两个集合分值的和\n5. `[AGGREGATE SUM/MIN/MAX]` 可以通过设置聚合函数来控制分值(求和/最小值/最大值)\n6. `[WEIGHTS w1 w2 w3]` 可以为每个集合设置权重，这样计算方式将会是分值乘以权重再相加\n7. 除此之外，还可以接受集合（非有序）来执行命令，此时score默认都是1，还可以带WEIGHTS\n\n### ZEANGEBYLEX/ZREVRANGEBYLEX/ZLEXCOUNT/ZREMRANGEBYLEX 系列命令\n\n1. 以上所有命令格式雷同，都是处理当有序集合中分数全部相当的情况min和max分别指定是字典字母\n2. `ZEANGEBYLEX sorted_set min max`\n3. 比如`ZEANGEBYLEX sorted_set - +`返回所有成员，`[a (t` 返回字典大于等于a并且小于t的所有成员\n4. 逆序/成员个数/移除操作都是类似的\n\n### ZPOPMAX/ZPOPMIN 命令\n\n1. 弹出分值最高或者最低分值的元素\n2. 返回成员和分值\n3. `ZPOPMAX sorted_set [count]`可以通过 count 来指定最多移除的成员数量，默认为1\n4. Redis5.0  以上版本才支持\n\n### BZPOPMIN/BZPOPMAX 命令\n\n1. 阻塞式的最小或最大的弹出操作, 可以接受多个集合参数，进行遍历检测\n2. `BZPOPMIN/BZPOPMAX sorted_set [sorted_set ] timeout`\n3. timeout 为 0 表示无限阻塞等待\n\n## HperLogLog\n\n### HperLogLog数据结构\n\n1. 神奇的HyperLogLog算法<http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html>\n2. Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure <http://content.research.neustar.biz/blog/hll.html>\n3. 这是一个专门解决大数据计数器消耗太多内存问题的一个概率算法，只需要12k就可以统计2^64个元素\n4. 当然这不是精确统计，存在误差，数据量大的时候误差有的时候是允许的，可容允的\n\n### PFADD 命令\n\n1. `PFADD hperloglog element [element]` 新增元素\n2. 当新增元素是的统计基数值发生变化就返回1，否则反正0\n\n### PFCOUNT 命令\n\n1. `PFCOUNT hyperloglog [hyperloglog ...]` 计算集合的近视基数\n2. 当参数为多个时候，计算方式为：首先求多个集合的并集，然后对并集求近视基数\n\n### PFMERGE 命令\n\n1. `PFMERGE destination hyperloglog [hyperloglog ...]`  对多个hyperloglog集合求并集，然后将结果存在dest中\n\n2. PFCOUNT 其实是有调用PFMERGE命令的\n\n## 位图\n\n### 位图结构\n\n1. Redis位图bitmap是由多个二进制位组成的数组，数组中每一位都有与之对应的偏移量(索引)\n\n2. BITMAP 图\n\n|index|0|1|2|3|\n|-|-|-|-|-|\n|位|1|0|0|1｜\n\n### SETBIT 命令\n\n1. `SETBIT bitmap offset value` 设置指定偏移位的值\n2. 返回指定偏移量旧值，默认为0\n3. bitmap默认按照字节扩展\n4. offset只能为正值\n\n### GETBIT 命令\n\n1. `GETBIT bitmap offset`获取指定位置的值\n\n### BITCOUNT 命令\n\n1. `BITCOUNT bitmap` 统计位图中1的个数\n2. `BITCOUNT bitmap start end`  返回指定字节范围内1的个数，注意start和end为字节偏移量，并不是位offset， 可以使用负数作为参数\n\n### BITPOS 命令\n\n1. `BITPOS bitmap value` 查询bitmap中第一个被设置为value值的位置\n2. `BITPOS bitmap value [start end]`  在指定范围内查找，但是返回的offset是基于整个bigmap的偏移\n3. start和end可以为负值\n\n### BITOP 命令\n\n1. `BITOP OP result_key bitmap [bitmap ...]` 对多个bitmap数组执行op操作，将结果存储在result中\n2. op可以是 AND / OR /XOR / NOT\n\n### BITFIELD 命令\n\n1. `BITFIELD bitmap SET type offset value` 根据位偏移来设置bitmap中值value，其中type是指定value的类型，比如i8：8位有符号，u16：16位无符号等\n2. offset 可以换成 #index， 这样可以以字节位来索引具体位置，然后设置值\n3. 可以同时执行多个set命令\n4. `BITFIELD bitmap GET type offset/#index` 获取对应的值，同样的也可以同时执行多个GET\n5. `BITFIELD bitmap INCRYBY type offset/#index increment` 对指定范围值加减操作\n6. `BITFIELD bitmap [OVERFLOW WRAP/SAT/FAIL] INCRYBY type offset/#index increment` 可以用来处理加减法结果溢出的情况，分别为环绕/饱和运算/失败\n\n### BITMAP STRING\n\n1. 可以把二进制数组当作是字符串来操作\n2. GET 命令来获取二进制数组值，返回值为二进制字符串\n3. STRLEN 可以得到二进制字符串的长度\n4. GETRANGE 获取指定范围的二进制字符串\n\n## GEO位置服务\n\n### GEOADD 命令\n\n1. `GEOADD location_set longitude latitude name [longitude latitude name]` 添加一个或者多个位置坐标（经纬度）\n2. 当执行的是添加的，那么返回添加的位置个数；如果是更新那么返回0\n\n### GEOPOS 命令\n\n1. `GEOPOS location_set name [name ...]`  获取指定位置的经纬度\n2. 返回值是数组，其中数组元素为二元数组，第一项为经度，第二项为纬度\n\n### GEODIST 命令\n\n1. `GEODIST location_set name1 name2` 计算俩个位置的直线距离\n2. 默认单位为米，可以通过`[unit]` 来指定单位m/km/mi英里/ft英寸\n\n### GEORADIUS 命令\n\n1. `GEORADIUS location_set longitude latitude radius unit`  获取指定位置为中心点，radius半径内所有的地点\n2. `WITHDIST` 加上这个后缀参数，可以返回地点和地点与中心位置的直线距离\n3. `WITHCOORD`  返回地点和地点坐标\n4. `[ASD|DESC]` 对返回的结果排序\n5. `[COUNT n]`  限制返回地点的数量\n6. 可以同时指定多个可选参数\n\n### GEORADIUSBYMEMBER 命令\n\n1. `longitude latitude` 参数换成 `name`地名\n\n### GEOHASH 命令\n\n1. 获取指定位置的GEOhash值，GEOhash值是经纬度转换而来，并且可以通过GEohash来计算得到经纬度\n2. 在上面的两个命令中都可以指定`WITHHASH`  来返回GEOHASH 而非 经纬度\n\n### GEO数据内部存储结构\n\n1. 为有序集合，因此可以使用ZSORTED来操作数据，其中score为Geohash值\n\n## Stream流\n\n","slug":"Redis-Guide","published":1,"updated":"2020-07-10T10:28:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzge001nokec9nv46k0p","content":"<h1 id=\"Redis-数据结构与应用\"><a href=\"#Redis-数据结构与应用\" class=\"headerlink\" title=\"Redis 数据结构与应用\"></a>Redis 数据结构与应用</h1><h2 id=\"普通字符串\"><a href=\"#普通字符串\" class=\"headerlink\" title=\"普通字符串\"></a>普通字符串</h2><h3 id=\"SET-命令\"><a href=\"#SET-命令\" class=\"headerlink\" title=\"SET 命令\"></a>SET 命令</h3><ol>\n<li>SET KEY VALUE 设置</li>\n<li>NX 不存在才设置  可用于实现分布式锁</li>\n<li>XX 存在才设置</li>\n</ol>\n<h3 id=\"GET-命令\"><a href=\"#GET-命令\" class=\"headerlink\" title=\"GET 命令\"></a>GET 命令</h3><ol>\n<li>GET KEY 返回 VALUE 值  </li>\n<li>GETSET 返回旧 OLD_VALUE 值 , 并且设置新 NEW_VALUE</li>\n</ol>\n<h3 id=\"MSET-命令\"><a href=\"#MSET-命令\" class=\"headerlink\" title=\"MSET 命令\"></a>MSET 命令</h3><ol>\n<li>MSET KEY1 VALUE1 [ KEY2 VALUE2 …] 一次设置多个键值对</li>\n</ol>\n<h3 id=\"MGET-命令\"><a href=\"#MGET-命令\" class=\"headerlink\" title=\"MGET 命令\"></a>MGET 命令</h3><ol>\n<li>MGET KEY1 [ KEY2 …] 一次设置多个键值对<br>返回VALUE列表, 这在批量获取多个键值对的时候非常实用, 业务层不用做封装</li>\n</ol>\n<h3 id=\"MSETNX-命令\"><a href=\"#MSETNX-命令\" class=\"headerlink\" title=\"MSETNX 命令\"></a>MSETNX 命令</h3><ol>\n<li>MSETNX KEY VALUE [ KEY2 VALUE2 …]<br>   设置多个键值对, 这是一个原子操作, 当且仅当所有KEY都不存在的时候才会成功</li>\n</ol>\n<h3 id=\"STRLEN-命令\"><a href=\"#STRLEN-命令\" class=\"headerlink\" title=\"STRLEN 命令\"></a>STRLEN 命令</h3><ol>\n<li>STRLEN KEY 获取值的字节长度</li>\n</ol>\n<h3 id=\"GETRANGE-命令\"><a href=\"#GETRANGE-命令\" class=\"headerlink\" title=\"GETRANGE 命令\"></a>GETRANGE 命令</h3><ol>\n<li>GETRANGE KEY start end<br>根据指定索引范围设置值，相当于取值的子串</li>\n</ol>\n<h3 id=\"SETRANGE-命令\"><a href=\"#SETRANGE-命令\" class=\"headerlink\" title=\"SETRANGE 命令\"></a>SETRANGE 命令</h3><ol>\n<li>SETRANGE KEY startIndex substitute<br>根据指定开始索引，开始替换新串substitute; 当startIndex大于值长度(len - 1), redis会自动扩展值长度，并且填充空字节(\\x00)</li>\n</ol>\n<h3 id=\"APPEND-命令\"><a href=\"#APPEND-命令\" class=\"headerlink\" title=\"APPEND 命令\"></a>APPEND 命令</h3><ol>\n<li>APPEND KEY suffix 对值进行追加操作, 并返回新串长度<br>当KEY不存在, 那么APPEND命令等价于SET操作</li>\n</ol>\n<h3 id=\"INCRBY-DECRBY-命令\"><a href=\"#INCRBY-DECRBY-命令\" class=\"headerlink\" title=\"INCRBY DECRBY 命令\"></a>INCRBY DECRBY 命令</h3><ol>\n<li>INCRBY&#x2F;DECRBY KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减<br>当KEY不存在，那么会被初始化为0，然后再进行操作</li>\n</ol>\n<h3 id=\"INCR-DECR-命令\"><a href=\"#INCR-DECR-命令\" class=\"headerlink\" title=\"INCR DECR 命令\"></a>INCR DECR 命令</h3><ol>\n<li>INCR&#x2F;DECR KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减1<br>当KEY不存在，那么会被初始化为0，然后再进行操作</li>\n</ol>\n<h3 id=\"INCRBYFLOAT-命令\"><a href=\"#INCRBYFLOAT-命令\" class=\"headerlink\" title=\"INCRBYFLOAT 命令\"></a>INCRBYFLOAT 命令</h3><ol>\n<li>INCRBYFLOAT KEY incrment， 命令与INCRBY无差别，主要是针对的是浮点数<br>但是没有DECRBYFLOAT命令，可以通过设置incrment为负数来实现减法<br>INCRBYFLOAT 命令对值的格式更加宽松，那么值是整数的时候，命令与INCRBY等同，存储的值也会是整数<br>注意Redis在处理浮点数的时候，小数位长度是有限制，最长为17位，对于大部分应用是足够的</li>\n</ol>\n<h2 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><table>\n<thead>\n<tr>\n<th align=\"center\">KEY</th>\n<th align=\"center\">FIELD</th>\n<th align=\"center\">VALUE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">article</td>\n<td align=\"center\">title</td>\n<td align=\"center\">“Hello World”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">content</td>\n<td align=\"center\">“son of bitch”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">author</td>\n<td align=\"center\">genge</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">created_at</td>\n<td align=\"center\">2010-10-10</td>\n</tr>\n</tbody></table>\n<h3 id=\"HSET-命令\"><a href=\"#HSET-命令\" class=\"headerlink\" title=\"HSET 命令\"></a>HSET 命令</h3><ol>\n<li>HSET HASHKEY FIELD VALUE<br>如果key或者field不存在, 那么会创建，返回值为1<br>如果field存在, 那么会更新，返回值为0</li>\n</ol>\n<h3 id=\"HSETNX-命令\"><a href=\"#HSETNX-命令\" class=\"headerlink\" title=\"HSETNX 命令\"></a>HSETNX 命令</h3><ol>\n<li>HSETNX HASH FIELD VALUE<br>只在字段不存在的时候设置值，返回值为1，设置失败返回0</li>\n</ol>\n<h3 id=\"HGET-命令\"><a href=\"#HGET-命令\" class=\"headerlink\" title=\"HGET 命令\"></a>HGET 命令</h3><ol>\n<li>HGET HASH FIELD VALUE<br>获取字段值</li>\n</ol>\n<h3 id=\"HINCRBY-or-HINCRFLOATBY\"><a href=\"#HINCRBY-or-HINCRFLOATBY\" class=\"headerlink\" title=\"HINCRBY or HINCRFLOATBY\"></a>HINCRBY or HINCRFLOATBY</h3><ol>\n<li>HINCRBY HASH FIELD INCRMENT 对数值进行加减</li>\n</ol>\n<h3 id=\"HSTRLEN-命令\"><a href=\"#HSTRLEN-命令\" class=\"headerlink\" title=\"HSTRLEN 命令\"></a>HSTRLEN 命令</h3><ol>\n<li>HSTRLEN HASH FIELD 获取字段值长度</li>\n</ol>\n<h3 id=\"HEXISTS-命令\"><a href=\"#HEXISTS-命令\" class=\"headerlink\" title=\"HEXISTS 命令\"></a>HEXISTS 命令</h3><ol>\n<li>检查字段值是否存在</li>\n</ol>\n<h3 id=\"HDEL-命令\"><a href=\"#HDEL-命令\" class=\"headerlink\" title=\"HDEL 命令\"></a>HDEL 命令</h3><ol>\n<li>HDEL HASH FILED 删除字段</li>\n</ol>\n<h3 id=\"HLEN-命令\"><a href=\"#HLEN-命令\" class=\"headerlink\" title=\"HLEN 命令\"></a>HLEN 命令</h3><ol>\n<li>HLEN HASH 获取散列表字段个数</li>\n</ol>\n<h3 id=\"HMSET-x2F-HMGET-系列命令\"><a href=\"#HMSET-x2F-HMGET-系列命令\" class=\"headerlink\" title=\"HMSET&#x2F;HMGET 系列命令\"></a>HMSET&#x2F;HMGET 系列命令</h3><ol>\n<li>效果同MSET&#x2F;MGET</li>\n</ol>\n<h3 id=\"HKEYS-x2F-HVALS-x2F-HGETALL-命令\"><a href=\"#HKEYS-x2F-HVALS-x2F-HGETALL-命令\" class=\"headerlink\" title=\"HKEYS&#x2F;HVALS&#x2F;HGETALL 命令\"></a>HKEYS&#x2F;HVALS&#x2F;HGETALL 命令</h3><ol>\n<li>获取散列表中所有字段FIELD</li>\n<li>获取散列表中所有VALUE</li>\n<li>获取散列表中所有FIELD和VALUE<br>格式为数组： FIELD1:VALUE1:FILED2:VALUE2……</li>\n</ol>\n<h2 id=\"List列表结构\"><a href=\"#List列表结构\" class=\"headerlink\" title=\"List列表结构\"></a>List列表结构</h2><h3 id=\"Redis-List列表是一种线性的有序结构\"><a href=\"#Redis-List列表是一种线性的有序结构\" class=\"headerlink\" title=\"Redis List列表是一种线性的有序结构\"></a>Redis List列表是一种线性的有序结构</h3><h3 id=\"LPUSH-命令\"><a href=\"#LPUSH-命令\" class=\"headerlink\" title=\"LPUSH 命令\"></a>LPUSH 命令</h3><ol>\n<li>LPUSH KEY VALUE0 [ VALUE1 VALUE2 …]  返回推入会列表元素个数<br>向列表左端新增n个VALUE, ‘L’ 表示是left 而不是 list</li>\n</ol>\n<h3 id=\"RPUSH-命令\"><a href=\"#RPUSH-命令\" class=\"headerlink\" title=\"RPUSH 命令\"></a>RPUSH 命令</h3><ol>\n<li>RPUSH KEY VALUE0 [ VALUE1 VALUE2 …] 返回推入会列表元素个数<br>向列表右端新增n个VALUE, ‘R’ 表示是right</li>\n</ol>\n<h3 id=\"RPUSHX-x2F-LPUSHX-命令\"><a href=\"#RPUSHX-x2F-LPUSHX-命令\" class=\"headerlink\" title=\"RPUSHX&#x2F;LPUSHX 命令\"></a>RPUSHX&#x2F;LPUSHX 命令</h3><ol>\n<li>与上两个命令同，但是在列表KEY不存在的时候的结果不一样，这两个命令在列表KEY不存在的时候会推入失败， 返回0</li>\n</ol>\n<h3 id=\"LPOP-x2F-RPOP\"><a href=\"#LPOP-x2F-RPOP\" class=\"headerlink\" title=\"LPOP&#x2F;RPOP\"></a>LPOP&#x2F;RPOP</h3><ol>\n<li>LPOP&#x2F;RPOP LISTKEY 弹出最左边&#x2F;右边的元素， 返回POP后的元素</li>\n</ol>\n<h3 id=\"RPOPLPUSH-命令\"><a href=\"#RPOPLPUSH-命令\" class=\"headerlink\" title=\"RPOPLPUSH 命令\"></a>RPOPLPUSH 命令</h3><ol>\n<li>RPOPLPUSH source target 返回被弹出的元素值<br>将源source列表最右端元素弹出，插入到目标target列表最左端<br>其中source和target可以相同，即将列表首尾对调<br>当source 为空时，执行会失败，返回空</li>\n</ol>\n<h3 id=\"LLEN-命令\"><a href=\"#LLEN-命令\" class=\"headerlink\" title=\"LLEN 命令\"></a>LLEN 命令</h3><ol>\n<li>获取列表长度</li>\n</ol>\n<h3 id=\"LINDEX-命令\"><a href=\"#LINDEX-命令\" class=\"headerlink\" title=\"LINDEX 命令\"></a>LINDEX 命令</h3><ol>\n<li>LINDEX list index 获取列表指定索引元素<br>index为正数： 左端为0， 范围为 0 – N-1<br>index为负数： 右端为-1， 范围为 -N – -1</li>\n</ol>\n<h3 id=\"LRANGE-命令\"><a href=\"#LRANGE-命令\" class=\"headerlink\" title=\"LRANGE 命令\"></a>LRANGE 命令</h3><ol>\n<li>获取指定索引范围内的所有元素<br>LRANGE list start end<br>LRANGE list 0 -1 获取全部元素<br>当start和end都超出范围时，将会返回空列表；当只有一个超出时，Redis会对超出的索引进行修正，开始索引超出会被修正为0，结束索引会被修正为-1</li>\n</ol>\n<h3 id=\"LSET-命令\"><a href=\"#LSET-命令\" class=\"headerlink\" title=\"LSET 命令\"></a>LSET 命令</h3><ol>\n<li>LSET list index new_value<br>对列表指定索引元素值更新</li>\n</ol>\n<h3 id=\"LINSERT-命令\"><a href=\"#LINSERT-命令\" class=\"headerlink\" title=\"LINSERT 命令\"></a>LINSERT 命令</h3><ol>\n<li>LINSERT list BEFORE&#x2F;AFTER target_element new_element</li>\n</ol>\n<h3 id=\"LTRIM-裁剪\"><a href=\"#LTRIM-裁剪\" class=\"headerlink\" title=\"LTRIM 裁剪\"></a>LTRIM 裁剪</h3><ol>\n<li>LTRIM list start index 删除索引范围外所有元素</li>\n</ol>\n<h3 id=\"LREM-移除\"><a href=\"#LREM-移除\" class=\"headerlink\" title=\"LREM 移除\"></a>LREM 移除</h3><ol>\n<li>LREM list count element  返回被移除的元素数量<ul>\n<li>如果count等于0，那么命令将会移除list中所有值等于element的元素</li>\n<li>如果count等于正数，那么命令会从左端开始扫描，移除列表中值为element的count个元素</li>\n<li>如果count等于负数，那么命令会从右端开始扫描，移除列表中值为element的abs(count)个元素</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"BLPOP-阻塞式左端弹出\"><a href=\"#BLPOP-阻塞式左端弹出\" class=\"headerlink\" title=\"BLPOP 阻塞式左端弹出\"></a>BLPOP 阻塞式左端弹出</h3><ol>\n<li>BLPOP list1 [ list2 list3 …] timeout<ul>\n<li>命令会按照传入的列表从左至右挨个检查是否为空，如果发现某个列表不为空，那么执行LPOP操作，返回值为两个元素的数组，第一个元素是被弹出的列表list名，第二个元素是被弹出的元素值；</li>\n<li>如果当前传入的所有list为空，那么Redis将会阻塞等待直至timeout超时，返回空值，超时时间单位为秒，设置为0时表示会一直等待</li>\n<li>如果当前有多个客户端因为某个列表空而阻塞，那么按照先阻塞先服务原则进行唤醒</li>\n<li>这个命令只会当前Redis客户端</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"BRPOP-命令-与上同\"><a href=\"#BRPOP-命令-与上同\" class=\"headerlink\" title=\"BRPOP 命令 与上同\"></a>BRPOP 命令 与上同</h3><h3 id=\"BRPOPLPUSH-阻塞式弹出和推入操作-与上同\"><a href=\"#BRPOPLPUSH-阻塞式弹出和推入操作-与上同\" class=\"headerlink\" title=\"BRPOPLPUSH 阻塞式弹出和推入操作 与上同\"></a>BRPOPLPUSH 阻塞式弹出和推入操作 与上同</h3><ol>\n<li>可用于实现带有阻塞式的消息队列</li>\n</ol>\n<h2 id=\"无序集合Set\"><a href=\"#无序集合Set\" class=\"headerlink\" title=\"无序集合Set\"></a>无序集合Set</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>说明无序集合，集合中元素不重复</p>\n<h3 id=\"SADD-命令\"><a href=\"#SADD-命令\" class=\"headerlink\" title=\"SADD 命令\"></a>SADD 命令</h3><p>SADD set element [ element …]</p>\n<p>返回值为新增元素个数，会去重</p>\n<h3 id=\"SREM-命令\"><a href=\"#SREM-命令\" class=\"headerlink\" title=\"SREM 命令\"></a>SREM 命令</h3><p>SREM set element [element …]<br>移除一个或多个元素，返回真实移除元素的个数</p>\n<h3 id=\"SMOVE-命令\"><a href=\"#SMOVE-命令\" class=\"headerlink\" title=\"SMOVE 命令\"></a>SMOVE 命令</h3><p><code>SMOVE source target element</code> 将指定元素从source移除，并且加入到目标集合，当source中不存在element的时候会返回失败</p>\n<h3 id=\"SMEMBERS-命令\"><a href=\"#SMEMBERS-命令\" class=\"headerlink\" title=\"SMEMBERS 命令\"></a>SMEMBERS 命令</h3><p><code>SMEMBERS set</code> 获取集合所有元素</p>\n<h3 id=\"SCARD-命令\"><a href=\"#SCARD-命令\" class=\"headerlink\" title=\"SCARD 命令\"></a>SCARD 命令</h3><ol>\n<li><code>SCARD set</code> 获取集合元素个数</li>\n</ol>\n<h3 id=\"SISMEMBER-命令\"><a href=\"#SISMEMBER-命令\" class=\"headerlink\" title=\"SISMEMBER 命令\"></a>SISMEMBER 命令</h3><ol>\n<li><code>SISMEMBER set element</code> 判断指定元素是否存在集合中</li>\n</ol>\n<h3 id=\"SRANDMEMBER-命令\"><a href=\"#SRANDMEMBER-命令\" class=\"headerlink\" title=\"SRANDMEMBER 命令\"></a>SRANDMEMBER 命令</h3><ol>\n<li><p><code>SRANDMEMBER SET [count]</code> 随机获取集合汇总count个元素，count默认值为1</p>\n</li>\n<li><p>count为正数时候，返回随机不重复的min(count, SCARD) 个元素，属于不放回随机抽取</p>\n</li>\n<li><p>count为负数的时候，随机的机制发生变化，属于放回随机抽取，也就是说返回集合有可能出现重复的元素</p>\n</li>\n</ol>\n<h3 id=\"SPOP-命令\"><a href=\"#SPOP-命令\" class=\"headerlink\" title=\"SPOP 命令\"></a>SPOP 命令</h3><ol>\n<li><code>SPOP set [count]</code> 随机的重集中移除count个元素，返回被移除的元素集合</li>\n</ol>\n<h3 id=\"SINTER-x2F-SINTERSTORE-命令\"><a href=\"#SINTER-x2F-SINTERSTORE-命令\" class=\"headerlink\" title=\"SINTER&#x2F;SINTERSTORE 命令\"></a>SINTER&#x2F;SINTERSTORE 命令</h3><ol>\n<li><p><code>SINTER set [set]</code> 求多个集合的交集</p>\n</li>\n<li><p><code>SINTER dest_set set [set ]</code> 求多个集合的交集，并将结果存储到新的集合中，返回新集合的元素个数</p>\n</li>\n</ol>\n<h3 id=\"SUNION-x2F-SUNIONSTORE-命令\"><a href=\"#SUNION-x2F-SUNIONSTORE-命令\" class=\"headerlink\" title=\"SUNION&#x2F;SUNIONSTORE 命令\"></a>SUNION&#x2F;SUNIONSTORE 命令</h3><ol>\n<li>并集, 含义同上</li>\n</ol>\n<h3 id=\"SDIFF-x2F-SDIFFSTORE-命令\"><a href=\"#SDIFF-x2F-SDIFFSTORE-命令\" class=\"headerlink\" title=\"SDIFF&#x2F;SDIFFSTORE 命令\"></a>SDIFF&#x2F;SDIFFSTORE 命令</h3><ol>\n<li>差集，含义同上</li>\n<li>集合操作都非常消耗性能，可能导致Redis主线程阻塞</li>\n</ol>\n<h2 id=\"有序集合Sorted-SET\"><a href=\"#有序集合Sorted-SET\" class=\"headerlink\" title=\"有序集合Sorted SET\"></a>有序集合Sorted SET</h2><h3 id=\"对应数据结构\"><a href=\"#对应数据结构\" class=\"headerlink\" title=\"对应数据结构\"></a>对应数据结构</h3><ol>\n<li>同时具有有序和集合的性质</li>\n<li>每个元素都由一个成员和一个与成员相关联的分值score组成</li>\n<li>排行榜最佳实现</li>\n</ol>\n<p><code>sorted set</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">score</th>\n<th align=\"center\">member</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">genge</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">apple</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">inuby</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">oiuby</td>\n</tr>\n<tr>\n<td align=\"center\">19</td>\n<td align=\"center\">qwmok</td>\n</tr>\n</tbody></table>\n<h3 id=\"ZADD-命令\"><a href=\"#ZADD-命令\" class=\"headerlink\" title=\"ZADD 命令\"></a>ZADD 命令</h3><ol>\n<li><code>ZADD sorted_set [CH] score element [score element]</code> 向有序集合中添加元素</li>\n<li>默认返回新添加元素的个数，当命令带 CH 的时候返回修改元素的个数</li>\n</ol>\n<h3 id=\"ZREM-命令\"><a href=\"#ZREM-命令\" class=\"headerlink\" title=\"ZREM 命令\"></a>ZREM 命令</h3><ol>\n<li><code>ZREM sorted_set member [member]</code>  移除指定元素  返回真实被移除的元素个数</li>\n</ol>\n<h3 id=\"ZSCORE-命令\"><a href=\"#ZSCORE-命令\" class=\"headerlink\" title=\"ZSCORE 命令\"></a>ZSCORE 命令</h3><ol>\n<li><code>ZSCORE sorted_set member</code> 获取指定元素的分值</li>\n</ol>\n<h3 id=\"ZINCRBY-命令\"><a href=\"#ZINCRBY-命令\" class=\"headerlink\" title=\"ZINCRBY 命令\"></a>ZINCRBY 命令</h3><ol>\n<li><code>ZINCRBY sorted_set increment_score memeber</code> 对指定元素的分值加减</li>\n<li>当member不存在的时候，命令等同于ZADD</li>\n</ol>\n<h3 id=\"ZCARD-命令\"><a href=\"#ZCARD-命令\" class=\"headerlink\" title=\"ZCARD 命令\"></a>ZCARD 命令</h3><ol>\n<li>获取有序集合元素个数</li>\n</ol>\n<h3 id=\"ZRANK-x2F-ZREVRANK-命令\"><a href=\"#ZRANK-x2F-ZREVRANK-命令\" class=\"headerlink\" title=\"ZRANK&#x2F;ZREVRANK 命令\"></a>ZRANK&#x2F;ZREVRANK 命令</h3><ol>\n<li><code>ZRANK sorted_set member</code> 指定元素的的正排名 （从小到大）</li>\n<li><code>ZREVRANK sorted_set member</code> 指定元素的的排名 （从大到小）</li>\n</ol>\n<h3 id=\"ZRANGE-x2F-ZREVRANGE-命令\"><a href=\"#ZRANGE-x2F-ZREVRANGE-命令\" class=\"headerlink\" title=\"ZRANGE &#x2F; ZREVRANGE 命令\"></a>ZRANGE &#x2F; ZREVRANGE 命令</h3><ol>\n<li>获取指定范围内成员 <code>ZRANGE/ZREVRANGE sorted_set start end</code></li>\n<li>start 和 end均可接受负值, 含义是排名</li>\n<li><code>ZRANGE/ZREVRANGE sorted_set start end WITHSCORES</code> 会返回分值和元素值</li>\n</ol>\n<h3 id=\"ZRANGEBYSCORE-x2F-ZREVRANGEBYSCORE-命令\"><a href=\"#ZRANGEBYSCORE-x2F-ZREVRANGEBYSCORE-命令\" class=\"headerlink\" title=\"ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE 命令\"></a>ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE 命令</h3><ol>\n<li><code>ZRANGEBYSCORE/ZREVRANGEBYSCORE sorted_set min max/max min</code> 获取指定范围分数内的成员</li>\n<li><code>WITHSCORES</code> 可以附带返回分数值</li>\n<li><code>LIMIT offset count</code> 可以限制返回元素的数量， offset为起止偏移量，count为最大返回数量</li>\n<li><code>(min (max</code> 使用左括号的表示开区间，默认是闭区间</li>\n<li><code>-inf +inf</code>来表示负无穷和正无穷</li>\n</ol>\n<h3 id=\"ZCOUNT-命令\"><a href=\"#ZCOUNT-命令\" class=\"headerlink\" title=\"ZCOUNT 命令\"></a>ZCOUNT 命令</h3><ol>\n<li><code>ZCOUNT sorted_set min max</code> 获取指定分值范围内的成员数量</li>\n<li>和上面的RAGNE命令相同，都支持开闭区间无穷等设置</li>\n</ol>\n<h3 id=\"ZREMRANGEBYRANK-命令\"><a href=\"#ZREMRANGEBYRANK-命令\" class=\"headerlink\" title=\"ZREMRANGEBYRANK 命令\"></a>ZREMRANGEBYRANK 命令</h3><ol>\n<li><code>ZREMRANGEBYRANK sorted_set start end</code> 根据给定的排名区间来移除成员</li>\n<li>参数支持负值，表示倒数排名</li>\n</ol>\n<h3 id=\"ZREMRANGEBYSCORE-命令\"><a href=\"#ZREMRANGEBYSCORE-命令\" class=\"headerlink\" title=\"ZREMRANGEBYSCORE 命令\"></a>ZREMRANGEBYSCORE 命令</h3><ol>\n<li><code>ZREMRANGEBYSCORE sorted_set start end</code> 根据给定的分数区间来移除成员</li>\n<li>和上面的RAGNE命令相同，都支持开闭区间无穷等设置</li>\n</ol>\n<h3 id=\"ZINTERSTORE-x2F-ZUNIONSTORE-命令\"><a href=\"#ZINTERSTORE-x2F-ZUNIONSTORE-命令\" class=\"headerlink\" title=\"ZINTERSTORE&#x2F;ZUNIONSTORE 命令\"></a>ZINTERSTORE&#x2F;ZUNIONSTORE 命令</h3><ol>\n<li><code>ZINTERSTORE/ZUNIONSTORE destination numbers sorted_set [sorted_set ]</code> 求多个集合的交集和并集</li>\n<li>numbers为sorted_set 参数的个数</li>\n<li>返回交集元素或者并集元素个数</li>\n<li>集合元素的分值是由两个集合分值的和</li>\n<li><code>[AGGREGATE SUM/MIN/MAX]</code> 可以通过设置聚合函数来控制分值(求和&#x2F;最小值&#x2F;最大值)</li>\n<li><code>[WEIGHTS w1 w2 w3]</code> 可以为每个集合设置权重，这样计算方式将会是分值乘以权重再相加</li>\n<li>除此之外，还可以接受集合（非有序）来执行命令，此时score默认都是1，还可以带WEIGHTS</li>\n</ol>\n<h3 id=\"ZEANGEBYLEX-x2F-ZREVRANGEBYLEX-x2F-ZLEXCOUNT-x2F-ZREMRANGEBYLEX-系列命令\"><a href=\"#ZEANGEBYLEX-x2F-ZREVRANGEBYLEX-x2F-ZLEXCOUNT-x2F-ZREMRANGEBYLEX-系列命令\" class=\"headerlink\" title=\"ZEANGEBYLEX&#x2F;ZREVRANGEBYLEX&#x2F;ZLEXCOUNT&#x2F;ZREMRANGEBYLEX 系列命令\"></a>ZEANGEBYLEX&#x2F;ZREVRANGEBYLEX&#x2F;ZLEXCOUNT&#x2F;ZREMRANGEBYLEX 系列命令</h3><ol>\n<li>以上所有命令格式雷同，都是处理当有序集合中分数全部相当的情况min和max分别指定是字典字母</li>\n<li><code>ZEANGEBYLEX sorted_set min max</code></li>\n<li>比如<code>ZEANGEBYLEX sorted_set - +</code>返回所有成员，<code>[a (t</code> 返回字典大于等于a并且小于t的所有成员</li>\n<li>逆序&#x2F;成员个数&#x2F;移除操作都是类似的</li>\n</ol>\n<h3 id=\"ZPOPMAX-x2F-ZPOPMIN-命令\"><a href=\"#ZPOPMAX-x2F-ZPOPMIN-命令\" class=\"headerlink\" title=\"ZPOPMAX&#x2F;ZPOPMIN 命令\"></a>ZPOPMAX&#x2F;ZPOPMIN 命令</h3><ol>\n<li>弹出分值最高或者最低分值的元素</li>\n<li>返回成员和分值</li>\n<li><code>ZPOPMAX sorted_set [count]</code>可以通过 count 来指定最多移除的成员数量，默认为1</li>\n<li>Redis5.0  以上版本才支持</li>\n</ol>\n<h3 id=\"BZPOPMIN-x2F-BZPOPMAX-命令\"><a href=\"#BZPOPMIN-x2F-BZPOPMAX-命令\" class=\"headerlink\" title=\"BZPOPMIN&#x2F;BZPOPMAX 命令\"></a>BZPOPMIN&#x2F;BZPOPMAX 命令</h3><ol>\n<li>阻塞式的最小或最大的弹出操作, 可以接受多个集合参数，进行遍历检测</li>\n<li><code>BZPOPMIN/BZPOPMAX sorted_set [sorted_set ] timeout</code></li>\n<li>timeout 为 0 表示无限阻塞等待</li>\n</ol>\n<h2 id=\"HperLogLog\"><a href=\"#HperLogLog\" class=\"headerlink\" title=\"HperLogLog\"></a>HperLogLog</h2><h3 id=\"HperLogLog数据结构\"><a href=\"#HperLogLog数据结构\" class=\"headerlink\" title=\"HperLogLog数据结构\"></a>HperLogLog数据结构</h3><ol>\n<li>神奇的HyperLogLog算法<a href=\"http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html\">http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html</a></li>\n<li>Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure <a href=\"http://content.research.neustar.biz/blog/hll.html\">http://content.research.neustar.biz/blog/hll.html</a></li>\n<li>这是一个专门解决大数据计数器消耗太多内存问题的一个概率算法，只需要12k就可以统计2^64个元素</li>\n<li>当然这不是精确统计，存在误差，数据量大的时候误差有的时候是允许的，可容允的</li>\n</ol>\n<h3 id=\"PFADD-命令\"><a href=\"#PFADD-命令\" class=\"headerlink\" title=\"PFADD 命令\"></a>PFADD 命令</h3><ol>\n<li><code>PFADD hperloglog element [element]</code> 新增元素</li>\n<li>当新增元素是的统计基数值发生变化就返回1，否则反正0</li>\n</ol>\n<h3 id=\"PFCOUNT-命令\"><a href=\"#PFCOUNT-命令\" class=\"headerlink\" title=\"PFCOUNT 命令\"></a>PFCOUNT 命令</h3><ol>\n<li><code>PFCOUNT hyperloglog [hyperloglog ...]</code> 计算集合的近视基数</li>\n<li>当参数为多个时候，计算方式为：首先求多个集合的并集，然后对并集求近视基数</li>\n</ol>\n<h3 id=\"PFMERGE-命令\"><a href=\"#PFMERGE-命令\" class=\"headerlink\" title=\"PFMERGE 命令\"></a>PFMERGE 命令</h3><ol>\n<li><p><code>PFMERGE destination hyperloglog [hyperloglog ...]</code>  对多个hyperloglog集合求并集，然后将结果存在dest中</p>\n</li>\n<li><p>PFCOUNT 其实是有调用PFMERGE命令的</p>\n</li>\n</ol>\n<h2 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h2><h3 id=\"位图结构\"><a href=\"#位图结构\" class=\"headerlink\" title=\"位图结构\"></a>位图结构</h3><ol>\n<li><p>Redis位图bitmap是由多个二进制位组成的数组，数组中每一位都有与之对应的偏移量(索引)</p>\n</li>\n<li><p>BITMAP 图</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>位</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1｜</td>\n</tr>\n</tbody></table>\n<h3 id=\"SETBIT-命令\"><a href=\"#SETBIT-命令\" class=\"headerlink\" title=\"SETBIT 命令\"></a>SETBIT 命令</h3><ol>\n<li><code>SETBIT bitmap offset value</code> 设置指定偏移位的值</li>\n<li>返回指定偏移量旧值，默认为0</li>\n<li>bitmap默认按照字节扩展</li>\n<li>offset只能为正值</li>\n</ol>\n<h3 id=\"GETBIT-命令\"><a href=\"#GETBIT-命令\" class=\"headerlink\" title=\"GETBIT 命令\"></a>GETBIT 命令</h3><ol>\n<li><code>GETBIT bitmap offset</code>获取指定位置的值</li>\n</ol>\n<h3 id=\"BITCOUNT-命令\"><a href=\"#BITCOUNT-命令\" class=\"headerlink\" title=\"BITCOUNT 命令\"></a>BITCOUNT 命令</h3><ol>\n<li><code>BITCOUNT bitmap</code> 统计位图中1的个数</li>\n<li><code>BITCOUNT bitmap start end</code>  返回指定字节范围内1的个数，注意start和end为字节偏移量，并不是位offset， 可以使用负数作为参数</li>\n</ol>\n<h3 id=\"BITPOS-命令\"><a href=\"#BITPOS-命令\" class=\"headerlink\" title=\"BITPOS 命令\"></a>BITPOS 命令</h3><ol>\n<li><code>BITPOS bitmap value</code> 查询bitmap中第一个被设置为value值的位置</li>\n<li><code>BITPOS bitmap value [start end]</code>  在指定范围内查找，但是返回的offset是基于整个bigmap的偏移</li>\n<li>start和end可以为负值</li>\n</ol>\n<h3 id=\"BITOP-命令\"><a href=\"#BITOP-命令\" class=\"headerlink\" title=\"BITOP 命令\"></a>BITOP 命令</h3><ol>\n<li><code>BITOP OP result_key bitmap [bitmap ...]</code> 对多个bitmap数组执行op操作，将结果存储在result中</li>\n<li>op可以是 AND &#x2F; OR &#x2F;XOR &#x2F; NOT</li>\n</ol>\n<h3 id=\"BITFIELD-命令\"><a href=\"#BITFIELD-命令\" class=\"headerlink\" title=\"BITFIELD 命令\"></a>BITFIELD 命令</h3><ol>\n<li><code>BITFIELD bitmap SET type offset value</code> 根据位偏移来设置bitmap中值value，其中type是指定value的类型，比如i8：8位有符号，u16：16位无符号等</li>\n<li>offset 可以换成 #index， 这样可以以字节位来索引具体位置，然后设置值</li>\n<li>可以同时执行多个set命令</li>\n<li><code>BITFIELD bitmap GET type offset/#index</code> 获取对应的值，同样的也可以同时执行多个GET</li>\n<li><code>BITFIELD bitmap INCRYBY type offset/#index increment</code> 对指定范围值加减操作</li>\n<li><code>BITFIELD bitmap [OVERFLOW WRAP/SAT/FAIL] INCRYBY type offset/#index increment</code> 可以用来处理加减法结果溢出的情况，分别为环绕&#x2F;饱和运算&#x2F;失败</li>\n</ol>\n<h3 id=\"BITMAP-STRING\"><a href=\"#BITMAP-STRING\" class=\"headerlink\" title=\"BITMAP STRING\"></a>BITMAP STRING</h3><ol>\n<li>可以把二进制数组当作是字符串来操作</li>\n<li>GET 命令来获取二进制数组值，返回值为二进制字符串</li>\n<li>STRLEN 可以得到二进制字符串的长度</li>\n<li>GETRANGE 获取指定范围的二进制字符串</li>\n</ol>\n<h2 id=\"GEO位置服务\"><a href=\"#GEO位置服务\" class=\"headerlink\" title=\"GEO位置服务\"></a>GEO位置服务</h2><h3 id=\"GEOADD-命令\"><a href=\"#GEOADD-命令\" class=\"headerlink\" title=\"GEOADD 命令\"></a>GEOADD 命令</h3><ol>\n<li><code>GEOADD location_set longitude latitude name [longitude latitude name]</code> 添加一个或者多个位置坐标（经纬度）</li>\n<li>当执行的是添加的，那么返回添加的位置个数；如果是更新那么返回0</li>\n</ol>\n<h3 id=\"GEOPOS-命令\"><a href=\"#GEOPOS-命令\" class=\"headerlink\" title=\"GEOPOS 命令\"></a>GEOPOS 命令</h3><ol>\n<li><code>GEOPOS location_set name [name ...]</code>  获取指定位置的经纬度</li>\n<li>返回值是数组，其中数组元素为二元数组，第一项为经度，第二项为纬度</li>\n</ol>\n<h3 id=\"GEODIST-命令\"><a href=\"#GEODIST-命令\" class=\"headerlink\" title=\"GEODIST 命令\"></a>GEODIST 命令</h3><ol>\n<li><code>GEODIST location_set name1 name2</code> 计算俩个位置的直线距离</li>\n<li>默认单位为米，可以通过<code>[unit]</code> 来指定单位m&#x2F;km&#x2F;mi英里&#x2F;ft英寸</li>\n</ol>\n<h3 id=\"GEORADIUS-命令\"><a href=\"#GEORADIUS-命令\" class=\"headerlink\" title=\"GEORADIUS 命令\"></a>GEORADIUS 命令</h3><ol>\n<li><code>GEORADIUS location_set longitude latitude radius unit</code>  获取指定位置为中心点，radius半径内所有的地点</li>\n<li><code>WITHDIST</code> 加上这个后缀参数，可以返回地点和地点与中心位置的直线距离</li>\n<li><code>WITHCOORD</code>  返回地点和地点坐标</li>\n<li><code>[ASD|DESC]</code> 对返回的结果排序</li>\n<li><code>[COUNT n]</code>  限制返回地点的数量</li>\n<li>可以同时指定多个可选参数</li>\n</ol>\n<h3 id=\"GEORADIUSBYMEMBER-命令\"><a href=\"#GEORADIUSBYMEMBER-命令\" class=\"headerlink\" title=\"GEORADIUSBYMEMBER 命令\"></a>GEORADIUSBYMEMBER 命令</h3><ol>\n<li><code>longitude latitude</code> 参数换成 <code>name</code>地名</li>\n</ol>\n<h3 id=\"GEOHASH-命令\"><a href=\"#GEOHASH-命令\" class=\"headerlink\" title=\"GEOHASH 命令\"></a>GEOHASH 命令</h3><ol>\n<li>获取指定位置的GEOhash值，GEOhash值是经纬度转换而来，并且可以通过GEohash来计算得到经纬度</li>\n<li>在上面的两个命令中都可以指定<code>WITHHASH</code>  来返回GEOHASH 而非 经纬度</li>\n</ol>\n<h3 id=\"GEO数据内部存储结构\"><a href=\"#GEO数据内部存储结构\" class=\"headerlink\" title=\"GEO数据内部存储结构\"></a>GEO数据内部存储结构</h3><ol>\n<li>为有序集合，因此可以使用ZSORTED来操作数据，其中score为Geohash值</li>\n</ol>\n<h2 id=\"Stream流\"><a href=\"#Stream流\" class=\"headerlink\" title=\"Stream流\"></a>Stream流</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Redis-数据结构与应用\"><a href=\"#Redis-数据结构与应用\" class=\"headerlink\" title=\"Redis 数据结构与应用\"></a>Redis 数据结构与应用</h1><h2 id=\"普通字符串\"><a href=\"#普通字符串\" class=\"headerlink\" title=\"普通字符串\"></a>普通字符串</h2><h3 id=\"SET-命令\"><a href=\"#SET-命令\" class=\"headerlink\" title=\"SET 命令\"></a>SET 命令</h3><ol>\n<li>SET KEY VALUE 设置</li>\n<li>NX 不存在才设置  可用于实现分布式锁</li>\n<li>XX 存在才设置</li>\n</ol>\n<h3 id=\"GET-命令\"><a href=\"#GET-命令\" class=\"headerlink\" title=\"GET 命令\"></a>GET 命令</h3><ol>\n<li>GET KEY 返回 VALUE 值  </li>\n<li>GETSET 返回旧 OLD_VALUE 值 , 并且设置新 NEW_VALUE</li>\n</ol>\n<h3 id=\"MSET-命令\"><a href=\"#MSET-命令\" class=\"headerlink\" title=\"MSET 命令\"></a>MSET 命令</h3><ol>\n<li>MSET KEY1 VALUE1 [ KEY2 VALUE2 …] 一次设置多个键值对</li>\n</ol>\n<h3 id=\"MGET-命令\"><a href=\"#MGET-命令\" class=\"headerlink\" title=\"MGET 命令\"></a>MGET 命令</h3><ol>\n<li>MGET KEY1 [ KEY2 …] 一次设置多个键值对<br>返回VALUE列表, 这在批量获取多个键值对的时候非常实用, 业务层不用做封装</li>\n</ol>\n<h3 id=\"MSETNX-命令\"><a href=\"#MSETNX-命令\" class=\"headerlink\" title=\"MSETNX 命令\"></a>MSETNX 命令</h3><ol>\n<li>MSETNX KEY VALUE [ KEY2 VALUE2 …]<br>   设置多个键值对, 这是一个原子操作, 当且仅当所有KEY都不存在的时候才会成功</li>\n</ol>\n<h3 id=\"STRLEN-命令\"><a href=\"#STRLEN-命令\" class=\"headerlink\" title=\"STRLEN 命令\"></a>STRLEN 命令</h3><ol>\n<li>STRLEN KEY 获取值的字节长度</li>\n</ol>\n<h3 id=\"GETRANGE-命令\"><a href=\"#GETRANGE-命令\" class=\"headerlink\" title=\"GETRANGE 命令\"></a>GETRANGE 命令</h3><ol>\n<li>GETRANGE KEY start end<br>根据指定索引范围设置值，相当于取值的子串</li>\n</ol>\n<h3 id=\"SETRANGE-命令\"><a href=\"#SETRANGE-命令\" class=\"headerlink\" title=\"SETRANGE 命令\"></a>SETRANGE 命令</h3><ol>\n<li>SETRANGE KEY startIndex substitute<br>根据指定开始索引，开始替换新串substitute; 当startIndex大于值长度(len - 1), redis会自动扩展值长度，并且填充空字节(\\x00)</li>\n</ol>\n<h3 id=\"APPEND-命令\"><a href=\"#APPEND-命令\" class=\"headerlink\" title=\"APPEND 命令\"></a>APPEND 命令</h3><ol>\n<li>APPEND KEY suffix 对值进行追加操作, 并返回新串长度<br>当KEY不存在, 那么APPEND命令等价于SET操作</li>\n</ol>\n<h3 id=\"INCRBY-DECRBY-命令\"><a href=\"#INCRBY-DECRBY-命令\" class=\"headerlink\" title=\"INCRBY DECRBY 命令\"></a>INCRBY DECRBY 命令</h3><ol>\n<li>INCRBY&#x2F;DECRBY KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减<br>当KEY不存在，那么会被初始化为0，然后再进行操作</li>\n</ol>\n<h3 id=\"INCR-DECR-命令\"><a href=\"#INCR-DECR-命令\" class=\"headerlink\" title=\"INCR DECR 命令\"></a>INCR DECR 命令</h3><ol>\n<li>INCR&#x2F;DECR KEY incrment 当存储的值能够被解释为整数时， 可以使用这两个命令来对值进行加或减1<br>当KEY不存在，那么会被初始化为0，然后再进行操作</li>\n</ol>\n<h3 id=\"INCRBYFLOAT-命令\"><a href=\"#INCRBYFLOAT-命令\" class=\"headerlink\" title=\"INCRBYFLOAT 命令\"></a>INCRBYFLOAT 命令</h3><ol>\n<li>INCRBYFLOAT KEY incrment， 命令与INCRBY无差别，主要是针对的是浮点数<br>但是没有DECRBYFLOAT命令，可以通过设置incrment为负数来实现减法<br>INCRBYFLOAT 命令对值的格式更加宽松，那么值是整数的时候，命令与INCRBY等同，存储的值也会是整数<br>注意Redis在处理浮点数的时候，小数位长度是有限制，最长为17位，对于大部分应用是足够的</li>\n</ol>\n<h2 id=\"散列\"><a href=\"#散列\" class=\"headerlink\" title=\"散列\"></a>散列</h2><h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><table>\n<thead>\n<tr>\n<th align=\"center\">KEY</th>\n<th align=\"center\">FIELD</th>\n<th align=\"center\">VALUE</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">article</td>\n<td align=\"center\">title</td>\n<td align=\"center\">“Hello World”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">content</td>\n<td align=\"center\">“son of bitch”</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">author</td>\n<td align=\"center\">genge</td>\n</tr>\n<tr>\n<td align=\"center\"></td>\n<td align=\"center\">created_at</td>\n<td align=\"center\">2010-10-10</td>\n</tr>\n</tbody></table>\n<h3 id=\"HSET-命令\"><a href=\"#HSET-命令\" class=\"headerlink\" title=\"HSET 命令\"></a>HSET 命令</h3><ol>\n<li>HSET HASHKEY FIELD VALUE<br>如果key或者field不存在, 那么会创建，返回值为1<br>如果field存在, 那么会更新，返回值为0</li>\n</ol>\n<h3 id=\"HSETNX-命令\"><a href=\"#HSETNX-命令\" class=\"headerlink\" title=\"HSETNX 命令\"></a>HSETNX 命令</h3><ol>\n<li>HSETNX HASH FIELD VALUE<br>只在字段不存在的时候设置值，返回值为1，设置失败返回0</li>\n</ol>\n<h3 id=\"HGET-命令\"><a href=\"#HGET-命令\" class=\"headerlink\" title=\"HGET 命令\"></a>HGET 命令</h3><ol>\n<li>HGET HASH FIELD VALUE<br>获取字段值</li>\n</ol>\n<h3 id=\"HINCRBY-or-HINCRFLOATBY\"><a href=\"#HINCRBY-or-HINCRFLOATBY\" class=\"headerlink\" title=\"HINCRBY or HINCRFLOATBY\"></a>HINCRBY or HINCRFLOATBY</h3><ol>\n<li>HINCRBY HASH FIELD INCRMENT 对数值进行加减</li>\n</ol>\n<h3 id=\"HSTRLEN-命令\"><a href=\"#HSTRLEN-命令\" class=\"headerlink\" title=\"HSTRLEN 命令\"></a>HSTRLEN 命令</h3><ol>\n<li>HSTRLEN HASH FIELD 获取字段值长度</li>\n</ol>\n<h3 id=\"HEXISTS-命令\"><a href=\"#HEXISTS-命令\" class=\"headerlink\" title=\"HEXISTS 命令\"></a>HEXISTS 命令</h3><ol>\n<li>检查字段值是否存在</li>\n</ol>\n<h3 id=\"HDEL-命令\"><a href=\"#HDEL-命令\" class=\"headerlink\" title=\"HDEL 命令\"></a>HDEL 命令</h3><ol>\n<li>HDEL HASH FILED 删除字段</li>\n</ol>\n<h3 id=\"HLEN-命令\"><a href=\"#HLEN-命令\" class=\"headerlink\" title=\"HLEN 命令\"></a>HLEN 命令</h3><ol>\n<li>HLEN HASH 获取散列表字段个数</li>\n</ol>\n<h3 id=\"HMSET-x2F-HMGET-系列命令\"><a href=\"#HMSET-x2F-HMGET-系列命令\" class=\"headerlink\" title=\"HMSET&#x2F;HMGET 系列命令\"></a>HMSET&#x2F;HMGET 系列命令</h3><ol>\n<li>效果同MSET&#x2F;MGET</li>\n</ol>\n<h3 id=\"HKEYS-x2F-HVALS-x2F-HGETALL-命令\"><a href=\"#HKEYS-x2F-HVALS-x2F-HGETALL-命令\" class=\"headerlink\" title=\"HKEYS&#x2F;HVALS&#x2F;HGETALL 命令\"></a>HKEYS&#x2F;HVALS&#x2F;HGETALL 命令</h3><ol>\n<li>获取散列表中所有字段FIELD</li>\n<li>获取散列表中所有VALUE</li>\n<li>获取散列表中所有FIELD和VALUE<br>格式为数组： FIELD1:VALUE1:FILED2:VALUE2……</li>\n</ol>\n<h2 id=\"List列表结构\"><a href=\"#List列表结构\" class=\"headerlink\" title=\"List列表结构\"></a>List列表结构</h2><h3 id=\"Redis-List列表是一种线性的有序结构\"><a href=\"#Redis-List列表是一种线性的有序结构\" class=\"headerlink\" title=\"Redis List列表是一种线性的有序结构\"></a>Redis List列表是一种线性的有序结构</h3><h3 id=\"LPUSH-命令\"><a href=\"#LPUSH-命令\" class=\"headerlink\" title=\"LPUSH 命令\"></a>LPUSH 命令</h3><ol>\n<li>LPUSH KEY VALUE0 [ VALUE1 VALUE2 …]  返回推入会列表元素个数<br>向列表左端新增n个VALUE, ‘L’ 表示是left 而不是 list</li>\n</ol>\n<h3 id=\"RPUSH-命令\"><a href=\"#RPUSH-命令\" class=\"headerlink\" title=\"RPUSH 命令\"></a>RPUSH 命令</h3><ol>\n<li>RPUSH KEY VALUE0 [ VALUE1 VALUE2 …] 返回推入会列表元素个数<br>向列表右端新增n个VALUE, ‘R’ 表示是right</li>\n</ol>\n<h3 id=\"RPUSHX-x2F-LPUSHX-命令\"><a href=\"#RPUSHX-x2F-LPUSHX-命令\" class=\"headerlink\" title=\"RPUSHX&#x2F;LPUSHX 命令\"></a>RPUSHX&#x2F;LPUSHX 命令</h3><ol>\n<li>与上两个命令同，但是在列表KEY不存在的时候的结果不一样，这两个命令在列表KEY不存在的时候会推入失败， 返回0</li>\n</ol>\n<h3 id=\"LPOP-x2F-RPOP\"><a href=\"#LPOP-x2F-RPOP\" class=\"headerlink\" title=\"LPOP&#x2F;RPOP\"></a>LPOP&#x2F;RPOP</h3><ol>\n<li>LPOP&#x2F;RPOP LISTKEY 弹出最左边&#x2F;右边的元素， 返回POP后的元素</li>\n</ol>\n<h3 id=\"RPOPLPUSH-命令\"><a href=\"#RPOPLPUSH-命令\" class=\"headerlink\" title=\"RPOPLPUSH 命令\"></a>RPOPLPUSH 命令</h3><ol>\n<li>RPOPLPUSH source target 返回被弹出的元素值<br>将源source列表最右端元素弹出，插入到目标target列表最左端<br>其中source和target可以相同，即将列表首尾对调<br>当source 为空时，执行会失败，返回空</li>\n</ol>\n<h3 id=\"LLEN-命令\"><a href=\"#LLEN-命令\" class=\"headerlink\" title=\"LLEN 命令\"></a>LLEN 命令</h3><ol>\n<li>获取列表长度</li>\n</ol>\n<h3 id=\"LINDEX-命令\"><a href=\"#LINDEX-命令\" class=\"headerlink\" title=\"LINDEX 命令\"></a>LINDEX 命令</h3><ol>\n<li>LINDEX list index 获取列表指定索引元素<br>index为正数： 左端为0， 范围为 0 – N-1<br>index为负数： 右端为-1， 范围为 -N – -1</li>\n</ol>\n<h3 id=\"LRANGE-命令\"><a href=\"#LRANGE-命令\" class=\"headerlink\" title=\"LRANGE 命令\"></a>LRANGE 命令</h3><ol>\n<li>获取指定索引范围内的所有元素<br>LRANGE list start end<br>LRANGE list 0 -1 获取全部元素<br>当start和end都超出范围时，将会返回空列表；当只有一个超出时，Redis会对超出的索引进行修正，开始索引超出会被修正为0，结束索引会被修正为-1</li>\n</ol>\n<h3 id=\"LSET-命令\"><a href=\"#LSET-命令\" class=\"headerlink\" title=\"LSET 命令\"></a>LSET 命令</h3><ol>\n<li>LSET list index new_value<br>对列表指定索引元素值更新</li>\n</ol>\n<h3 id=\"LINSERT-命令\"><a href=\"#LINSERT-命令\" class=\"headerlink\" title=\"LINSERT 命令\"></a>LINSERT 命令</h3><ol>\n<li>LINSERT list BEFORE&#x2F;AFTER target_element new_element</li>\n</ol>\n<h3 id=\"LTRIM-裁剪\"><a href=\"#LTRIM-裁剪\" class=\"headerlink\" title=\"LTRIM 裁剪\"></a>LTRIM 裁剪</h3><ol>\n<li>LTRIM list start index 删除索引范围外所有元素</li>\n</ol>\n<h3 id=\"LREM-移除\"><a href=\"#LREM-移除\" class=\"headerlink\" title=\"LREM 移除\"></a>LREM 移除</h3><ol>\n<li>LREM list count element  返回被移除的元素数量<ul>\n<li>如果count等于0，那么命令将会移除list中所有值等于element的元素</li>\n<li>如果count等于正数，那么命令会从左端开始扫描，移除列表中值为element的count个元素</li>\n<li>如果count等于负数，那么命令会从右端开始扫描，移除列表中值为element的abs(count)个元素</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"BLPOP-阻塞式左端弹出\"><a href=\"#BLPOP-阻塞式左端弹出\" class=\"headerlink\" title=\"BLPOP 阻塞式左端弹出\"></a>BLPOP 阻塞式左端弹出</h3><ol>\n<li>BLPOP list1 [ list2 list3 …] timeout<ul>\n<li>命令会按照传入的列表从左至右挨个检查是否为空，如果发现某个列表不为空，那么执行LPOP操作，返回值为两个元素的数组，第一个元素是被弹出的列表list名，第二个元素是被弹出的元素值；</li>\n<li>如果当前传入的所有list为空，那么Redis将会阻塞等待直至timeout超时，返回空值，超时时间单位为秒，设置为0时表示会一直等待</li>\n<li>如果当前有多个客户端因为某个列表空而阻塞，那么按照先阻塞先服务原则进行唤醒</li>\n<li>这个命令只会当前Redis客户端</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"BRPOP-命令-与上同\"><a href=\"#BRPOP-命令-与上同\" class=\"headerlink\" title=\"BRPOP 命令 与上同\"></a>BRPOP 命令 与上同</h3><h3 id=\"BRPOPLPUSH-阻塞式弹出和推入操作-与上同\"><a href=\"#BRPOPLPUSH-阻塞式弹出和推入操作-与上同\" class=\"headerlink\" title=\"BRPOPLPUSH 阻塞式弹出和推入操作 与上同\"></a>BRPOPLPUSH 阻塞式弹出和推入操作 与上同</h3><ol>\n<li>可用于实现带有阻塞式的消息队列</li>\n</ol>\n<h2 id=\"无序集合Set\"><a href=\"#无序集合Set\" class=\"headerlink\" title=\"无序集合Set\"></a>无序集合Set</h2><h3 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h3><p>说明无序集合，集合中元素不重复</p>\n<h3 id=\"SADD-命令\"><a href=\"#SADD-命令\" class=\"headerlink\" title=\"SADD 命令\"></a>SADD 命令</h3><p>SADD set element [ element …]</p>\n<p>返回值为新增元素个数，会去重</p>\n<h3 id=\"SREM-命令\"><a href=\"#SREM-命令\" class=\"headerlink\" title=\"SREM 命令\"></a>SREM 命令</h3><p>SREM set element [element …]<br>移除一个或多个元素，返回真实移除元素的个数</p>\n<h3 id=\"SMOVE-命令\"><a href=\"#SMOVE-命令\" class=\"headerlink\" title=\"SMOVE 命令\"></a>SMOVE 命令</h3><p><code>SMOVE source target element</code> 将指定元素从source移除，并且加入到目标集合，当source中不存在element的时候会返回失败</p>\n<h3 id=\"SMEMBERS-命令\"><a href=\"#SMEMBERS-命令\" class=\"headerlink\" title=\"SMEMBERS 命令\"></a>SMEMBERS 命令</h3><p><code>SMEMBERS set</code> 获取集合所有元素</p>\n<h3 id=\"SCARD-命令\"><a href=\"#SCARD-命令\" class=\"headerlink\" title=\"SCARD 命令\"></a>SCARD 命令</h3><ol>\n<li><code>SCARD set</code> 获取集合元素个数</li>\n</ol>\n<h3 id=\"SISMEMBER-命令\"><a href=\"#SISMEMBER-命令\" class=\"headerlink\" title=\"SISMEMBER 命令\"></a>SISMEMBER 命令</h3><ol>\n<li><code>SISMEMBER set element</code> 判断指定元素是否存在集合中</li>\n</ol>\n<h3 id=\"SRANDMEMBER-命令\"><a href=\"#SRANDMEMBER-命令\" class=\"headerlink\" title=\"SRANDMEMBER 命令\"></a>SRANDMEMBER 命令</h3><ol>\n<li><p><code>SRANDMEMBER SET [count]</code> 随机获取集合汇总count个元素，count默认值为1</p>\n</li>\n<li><p>count为正数时候，返回随机不重复的min(count, SCARD) 个元素，属于不放回随机抽取</p>\n</li>\n<li><p>count为负数的时候，随机的机制发生变化，属于放回随机抽取，也就是说返回集合有可能出现重复的元素</p>\n</li>\n</ol>\n<h3 id=\"SPOP-命令\"><a href=\"#SPOP-命令\" class=\"headerlink\" title=\"SPOP 命令\"></a>SPOP 命令</h3><ol>\n<li><code>SPOP set [count]</code> 随机的重集中移除count个元素，返回被移除的元素集合</li>\n</ol>\n<h3 id=\"SINTER-x2F-SINTERSTORE-命令\"><a href=\"#SINTER-x2F-SINTERSTORE-命令\" class=\"headerlink\" title=\"SINTER&#x2F;SINTERSTORE 命令\"></a>SINTER&#x2F;SINTERSTORE 命令</h3><ol>\n<li><p><code>SINTER set [set]</code> 求多个集合的交集</p>\n</li>\n<li><p><code>SINTER dest_set set [set ]</code> 求多个集合的交集，并将结果存储到新的集合中，返回新集合的元素个数</p>\n</li>\n</ol>\n<h3 id=\"SUNION-x2F-SUNIONSTORE-命令\"><a href=\"#SUNION-x2F-SUNIONSTORE-命令\" class=\"headerlink\" title=\"SUNION&#x2F;SUNIONSTORE 命令\"></a>SUNION&#x2F;SUNIONSTORE 命令</h3><ol>\n<li>并集, 含义同上</li>\n</ol>\n<h3 id=\"SDIFF-x2F-SDIFFSTORE-命令\"><a href=\"#SDIFF-x2F-SDIFFSTORE-命令\" class=\"headerlink\" title=\"SDIFF&#x2F;SDIFFSTORE 命令\"></a>SDIFF&#x2F;SDIFFSTORE 命令</h3><ol>\n<li>差集，含义同上</li>\n<li>集合操作都非常消耗性能，可能导致Redis主线程阻塞</li>\n</ol>\n<h2 id=\"有序集合Sorted-SET\"><a href=\"#有序集合Sorted-SET\" class=\"headerlink\" title=\"有序集合Sorted SET\"></a>有序集合Sorted SET</h2><h3 id=\"对应数据结构\"><a href=\"#对应数据结构\" class=\"headerlink\" title=\"对应数据结构\"></a>对应数据结构</h3><ol>\n<li>同时具有有序和集合的性质</li>\n<li>每个元素都由一个成员和一个与成员相关联的分值score组成</li>\n<li>排行榜最佳实现</li>\n</ol>\n<p><code>sorted set</code></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">score</th>\n<th align=\"center\">member</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">genge</td>\n</tr>\n<tr>\n<td align=\"center\">3</td>\n<td align=\"center\">apple</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">inuby</td>\n</tr>\n<tr>\n<td align=\"center\">7</td>\n<td align=\"center\">oiuby</td>\n</tr>\n<tr>\n<td align=\"center\">19</td>\n<td align=\"center\">qwmok</td>\n</tr>\n</tbody></table>\n<h3 id=\"ZADD-命令\"><a href=\"#ZADD-命令\" class=\"headerlink\" title=\"ZADD 命令\"></a>ZADD 命令</h3><ol>\n<li><code>ZADD sorted_set [CH] score element [score element]</code> 向有序集合中添加元素</li>\n<li>默认返回新添加元素的个数，当命令带 CH 的时候返回修改元素的个数</li>\n</ol>\n<h3 id=\"ZREM-命令\"><a href=\"#ZREM-命令\" class=\"headerlink\" title=\"ZREM 命令\"></a>ZREM 命令</h3><ol>\n<li><code>ZREM sorted_set member [member]</code>  移除指定元素  返回真实被移除的元素个数</li>\n</ol>\n<h3 id=\"ZSCORE-命令\"><a href=\"#ZSCORE-命令\" class=\"headerlink\" title=\"ZSCORE 命令\"></a>ZSCORE 命令</h3><ol>\n<li><code>ZSCORE sorted_set member</code> 获取指定元素的分值</li>\n</ol>\n<h3 id=\"ZINCRBY-命令\"><a href=\"#ZINCRBY-命令\" class=\"headerlink\" title=\"ZINCRBY 命令\"></a>ZINCRBY 命令</h3><ol>\n<li><code>ZINCRBY sorted_set increment_score memeber</code> 对指定元素的分值加减</li>\n<li>当member不存在的时候，命令等同于ZADD</li>\n</ol>\n<h3 id=\"ZCARD-命令\"><a href=\"#ZCARD-命令\" class=\"headerlink\" title=\"ZCARD 命令\"></a>ZCARD 命令</h3><ol>\n<li>获取有序集合元素个数</li>\n</ol>\n<h3 id=\"ZRANK-x2F-ZREVRANK-命令\"><a href=\"#ZRANK-x2F-ZREVRANK-命令\" class=\"headerlink\" title=\"ZRANK&#x2F;ZREVRANK 命令\"></a>ZRANK&#x2F;ZREVRANK 命令</h3><ol>\n<li><code>ZRANK sorted_set member</code> 指定元素的的正排名 （从小到大）</li>\n<li><code>ZREVRANK sorted_set member</code> 指定元素的的排名 （从大到小）</li>\n</ol>\n<h3 id=\"ZRANGE-x2F-ZREVRANGE-命令\"><a href=\"#ZRANGE-x2F-ZREVRANGE-命令\" class=\"headerlink\" title=\"ZRANGE &#x2F; ZREVRANGE 命令\"></a>ZRANGE &#x2F; ZREVRANGE 命令</h3><ol>\n<li>获取指定范围内成员 <code>ZRANGE/ZREVRANGE sorted_set start end</code></li>\n<li>start 和 end均可接受负值, 含义是排名</li>\n<li><code>ZRANGE/ZREVRANGE sorted_set start end WITHSCORES</code> 会返回分值和元素值</li>\n</ol>\n<h3 id=\"ZRANGEBYSCORE-x2F-ZREVRANGEBYSCORE-命令\"><a href=\"#ZRANGEBYSCORE-x2F-ZREVRANGEBYSCORE-命令\" class=\"headerlink\" title=\"ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE 命令\"></a>ZRANGEBYSCORE&#x2F;ZREVRANGEBYSCORE 命令</h3><ol>\n<li><code>ZRANGEBYSCORE/ZREVRANGEBYSCORE sorted_set min max/max min</code> 获取指定范围分数内的成员</li>\n<li><code>WITHSCORES</code> 可以附带返回分数值</li>\n<li><code>LIMIT offset count</code> 可以限制返回元素的数量， offset为起止偏移量，count为最大返回数量</li>\n<li><code>(min (max</code> 使用左括号的表示开区间，默认是闭区间</li>\n<li><code>-inf +inf</code>来表示负无穷和正无穷</li>\n</ol>\n<h3 id=\"ZCOUNT-命令\"><a href=\"#ZCOUNT-命令\" class=\"headerlink\" title=\"ZCOUNT 命令\"></a>ZCOUNT 命令</h3><ol>\n<li><code>ZCOUNT sorted_set min max</code> 获取指定分值范围内的成员数量</li>\n<li>和上面的RAGNE命令相同，都支持开闭区间无穷等设置</li>\n</ol>\n<h3 id=\"ZREMRANGEBYRANK-命令\"><a href=\"#ZREMRANGEBYRANK-命令\" class=\"headerlink\" title=\"ZREMRANGEBYRANK 命令\"></a>ZREMRANGEBYRANK 命令</h3><ol>\n<li><code>ZREMRANGEBYRANK sorted_set start end</code> 根据给定的排名区间来移除成员</li>\n<li>参数支持负值，表示倒数排名</li>\n</ol>\n<h3 id=\"ZREMRANGEBYSCORE-命令\"><a href=\"#ZREMRANGEBYSCORE-命令\" class=\"headerlink\" title=\"ZREMRANGEBYSCORE 命令\"></a>ZREMRANGEBYSCORE 命令</h3><ol>\n<li><code>ZREMRANGEBYSCORE sorted_set start end</code> 根据给定的分数区间来移除成员</li>\n<li>和上面的RAGNE命令相同，都支持开闭区间无穷等设置</li>\n</ol>\n<h3 id=\"ZINTERSTORE-x2F-ZUNIONSTORE-命令\"><a href=\"#ZINTERSTORE-x2F-ZUNIONSTORE-命令\" class=\"headerlink\" title=\"ZINTERSTORE&#x2F;ZUNIONSTORE 命令\"></a>ZINTERSTORE&#x2F;ZUNIONSTORE 命令</h3><ol>\n<li><code>ZINTERSTORE/ZUNIONSTORE destination numbers sorted_set [sorted_set ]</code> 求多个集合的交集和并集</li>\n<li>numbers为sorted_set 参数的个数</li>\n<li>返回交集元素或者并集元素个数</li>\n<li>集合元素的分值是由两个集合分值的和</li>\n<li><code>[AGGREGATE SUM/MIN/MAX]</code> 可以通过设置聚合函数来控制分值(求和&#x2F;最小值&#x2F;最大值)</li>\n<li><code>[WEIGHTS w1 w2 w3]</code> 可以为每个集合设置权重，这样计算方式将会是分值乘以权重再相加</li>\n<li>除此之外，还可以接受集合（非有序）来执行命令，此时score默认都是1，还可以带WEIGHTS</li>\n</ol>\n<h3 id=\"ZEANGEBYLEX-x2F-ZREVRANGEBYLEX-x2F-ZLEXCOUNT-x2F-ZREMRANGEBYLEX-系列命令\"><a href=\"#ZEANGEBYLEX-x2F-ZREVRANGEBYLEX-x2F-ZLEXCOUNT-x2F-ZREMRANGEBYLEX-系列命令\" class=\"headerlink\" title=\"ZEANGEBYLEX&#x2F;ZREVRANGEBYLEX&#x2F;ZLEXCOUNT&#x2F;ZREMRANGEBYLEX 系列命令\"></a>ZEANGEBYLEX&#x2F;ZREVRANGEBYLEX&#x2F;ZLEXCOUNT&#x2F;ZREMRANGEBYLEX 系列命令</h3><ol>\n<li>以上所有命令格式雷同，都是处理当有序集合中分数全部相当的情况min和max分别指定是字典字母</li>\n<li><code>ZEANGEBYLEX sorted_set min max</code></li>\n<li>比如<code>ZEANGEBYLEX sorted_set - +</code>返回所有成员，<code>[a (t</code> 返回字典大于等于a并且小于t的所有成员</li>\n<li>逆序&#x2F;成员个数&#x2F;移除操作都是类似的</li>\n</ol>\n<h3 id=\"ZPOPMAX-x2F-ZPOPMIN-命令\"><a href=\"#ZPOPMAX-x2F-ZPOPMIN-命令\" class=\"headerlink\" title=\"ZPOPMAX&#x2F;ZPOPMIN 命令\"></a>ZPOPMAX&#x2F;ZPOPMIN 命令</h3><ol>\n<li>弹出分值最高或者最低分值的元素</li>\n<li>返回成员和分值</li>\n<li><code>ZPOPMAX sorted_set [count]</code>可以通过 count 来指定最多移除的成员数量，默认为1</li>\n<li>Redis5.0  以上版本才支持</li>\n</ol>\n<h3 id=\"BZPOPMIN-x2F-BZPOPMAX-命令\"><a href=\"#BZPOPMIN-x2F-BZPOPMAX-命令\" class=\"headerlink\" title=\"BZPOPMIN&#x2F;BZPOPMAX 命令\"></a>BZPOPMIN&#x2F;BZPOPMAX 命令</h3><ol>\n<li>阻塞式的最小或最大的弹出操作, 可以接受多个集合参数，进行遍历检测</li>\n<li><code>BZPOPMIN/BZPOPMAX sorted_set [sorted_set ] timeout</code></li>\n<li>timeout 为 0 表示无限阻塞等待</li>\n</ol>\n<h2 id=\"HperLogLog\"><a href=\"#HperLogLog\" class=\"headerlink\" title=\"HperLogLog\"></a>HperLogLog</h2><h3 id=\"HperLogLog数据结构\"><a href=\"#HperLogLog数据结构\" class=\"headerlink\" title=\"HperLogLog数据结构\"></a>HperLogLog数据结构</h3><ol>\n<li>神奇的HyperLogLog算法<a href=\"http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html\">http://www.rainybowe.com/blog/2017/07/13/%E7%A5%9E%E5%A5%87%E7%9A%84HyperLogLog%E7%AE%97%E6%B3%95/index.html</a></li>\n<li>Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure <a href=\"http://content.research.neustar.biz/blog/hll.html\">http://content.research.neustar.biz/blog/hll.html</a></li>\n<li>这是一个专门解决大数据计数器消耗太多内存问题的一个概率算法，只需要12k就可以统计2^64个元素</li>\n<li>当然这不是精确统计，存在误差，数据量大的时候误差有的时候是允许的，可容允的</li>\n</ol>\n<h3 id=\"PFADD-命令\"><a href=\"#PFADD-命令\" class=\"headerlink\" title=\"PFADD 命令\"></a>PFADD 命令</h3><ol>\n<li><code>PFADD hperloglog element [element]</code> 新增元素</li>\n<li>当新增元素是的统计基数值发生变化就返回1，否则反正0</li>\n</ol>\n<h3 id=\"PFCOUNT-命令\"><a href=\"#PFCOUNT-命令\" class=\"headerlink\" title=\"PFCOUNT 命令\"></a>PFCOUNT 命令</h3><ol>\n<li><code>PFCOUNT hyperloglog [hyperloglog ...]</code> 计算集合的近视基数</li>\n<li>当参数为多个时候，计算方式为：首先求多个集合的并集，然后对并集求近视基数</li>\n</ol>\n<h3 id=\"PFMERGE-命令\"><a href=\"#PFMERGE-命令\" class=\"headerlink\" title=\"PFMERGE 命令\"></a>PFMERGE 命令</h3><ol>\n<li><p><code>PFMERGE destination hyperloglog [hyperloglog ...]</code>  对多个hyperloglog集合求并集，然后将结果存在dest中</p>\n</li>\n<li><p>PFCOUNT 其实是有调用PFMERGE命令的</p>\n</li>\n</ol>\n<h2 id=\"位图\"><a href=\"#位图\" class=\"headerlink\" title=\"位图\"></a>位图</h2><h3 id=\"位图结构\"><a href=\"#位图结构\" class=\"headerlink\" title=\"位图结构\"></a>位图结构</h3><ol>\n<li><p>Redis位图bitmap是由多个二进制位组成的数组，数组中每一位都有与之对应的偏移量(索引)</p>\n</li>\n<li><p>BITMAP 图</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>index</th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>位</td>\n<td>1</td>\n<td>0</td>\n<td>0</td>\n<td>1｜</td>\n</tr>\n</tbody></table>\n<h3 id=\"SETBIT-命令\"><a href=\"#SETBIT-命令\" class=\"headerlink\" title=\"SETBIT 命令\"></a>SETBIT 命令</h3><ol>\n<li><code>SETBIT bitmap offset value</code> 设置指定偏移位的值</li>\n<li>返回指定偏移量旧值，默认为0</li>\n<li>bitmap默认按照字节扩展</li>\n<li>offset只能为正值</li>\n</ol>\n<h3 id=\"GETBIT-命令\"><a href=\"#GETBIT-命令\" class=\"headerlink\" title=\"GETBIT 命令\"></a>GETBIT 命令</h3><ol>\n<li><code>GETBIT bitmap offset</code>获取指定位置的值</li>\n</ol>\n<h3 id=\"BITCOUNT-命令\"><a href=\"#BITCOUNT-命令\" class=\"headerlink\" title=\"BITCOUNT 命令\"></a>BITCOUNT 命令</h3><ol>\n<li><code>BITCOUNT bitmap</code> 统计位图中1的个数</li>\n<li><code>BITCOUNT bitmap start end</code>  返回指定字节范围内1的个数，注意start和end为字节偏移量，并不是位offset， 可以使用负数作为参数</li>\n</ol>\n<h3 id=\"BITPOS-命令\"><a href=\"#BITPOS-命令\" class=\"headerlink\" title=\"BITPOS 命令\"></a>BITPOS 命令</h3><ol>\n<li><code>BITPOS bitmap value</code> 查询bitmap中第一个被设置为value值的位置</li>\n<li><code>BITPOS bitmap value [start end]</code>  在指定范围内查找，但是返回的offset是基于整个bigmap的偏移</li>\n<li>start和end可以为负值</li>\n</ol>\n<h3 id=\"BITOP-命令\"><a href=\"#BITOP-命令\" class=\"headerlink\" title=\"BITOP 命令\"></a>BITOP 命令</h3><ol>\n<li><code>BITOP OP result_key bitmap [bitmap ...]</code> 对多个bitmap数组执行op操作，将结果存储在result中</li>\n<li>op可以是 AND &#x2F; OR &#x2F;XOR &#x2F; NOT</li>\n</ol>\n<h3 id=\"BITFIELD-命令\"><a href=\"#BITFIELD-命令\" class=\"headerlink\" title=\"BITFIELD 命令\"></a>BITFIELD 命令</h3><ol>\n<li><code>BITFIELD bitmap SET type offset value</code> 根据位偏移来设置bitmap中值value，其中type是指定value的类型，比如i8：8位有符号，u16：16位无符号等</li>\n<li>offset 可以换成 #index， 这样可以以字节位来索引具体位置，然后设置值</li>\n<li>可以同时执行多个set命令</li>\n<li><code>BITFIELD bitmap GET type offset/#index</code> 获取对应的值，同样的也可以同时执行多个GET</li>\n<li><code>BITFIELD bitmap INCRYBY type offset/#index increment</code> 对指定范围值加减操作</li>\n<li><code>BITFIELD bitmap [OVERFLOW WRAP/SAT/FAIL] INCRYBY type offset/#index increment</code> 可以用来处理加减法结果溢出的情况，分别为环绕&#x2F;饱和运算&#x2F;失败</li>\n</ol>\n<h3 id=\"BITMAP-STRING\"><a href=\"#BITMAP-STRING\" class=\"headerlink\" title=\"BITMAP STRING\"></a>BITMAP STRING</h3><ol>\n<li>可以把二进制数组当作是字符串来操作</li>\n<li>GET 命令来获取二进制数组值，返回值为二进制字符串</li>\n<li>STRLEN 可以得到二进制字符串的长度</li>\n<li>GETRANGE 获取指定范围的二进制字符串</li>\n</ol>\n<h2 id=\"GEO位置服务\"><a href=\"#GEO位置服务\" class=\"headerlink\" title=\"GEO位置服务\"></a>GEO位置服务</h2><h3 id=\"GEOADD-命令\"><a href=\"#GEOADD-命令\" class=\"headerlink\" title=\"GEOADD 命令\"></a>GEOADD 命令</h3><ol>\n<li><code>GEOADD location_set longitude latitude name [longitude latitude name]</code> 添加一个或者多个位置坐标（经纬度）</li>\n<li>当执行的是添加的，那么返回添加的位置个数；如果是更新那么返回0</li>\n</ol>\n<h3 id=\"GEOPOS-命令\"><a href=\"#GEOPOS-命令\" class=\"headerlink\" title=\"GEOPOS 命令\"></a>GEOPOS 命令</h3><ol>\n<li><code>GEOPOS location_set name [name ...]</code>  获取指定位置的经纬度</li>\n<li>返回值是数组，其中数组元素为二元数组，第一项为经度，第二项为纬度</li>\n</ol>\n<h3 id=\"GEODIST-命令\"><a href=\"#GEODIST-命令\" class=\"headerlink\" title=\"GEODIST 命令\"></a>GEODIST 命令</h3><ol>\n<li><code>GEODIST location_set name1 name2</code> 计算俩个位置的直线距离</li>\n<li>默认单位为米，可以通过<code>[unit]</code> 来指定单位m&#x2F;km&#x2F;mi英里&#x2F;ft英寸</li>\n</ol>\n<h3 id=\"GEORADIUS-命令\"><a href=\"#GEORADIUS-命令\" class=\"headerlink\" title=\"GEORADIUS 命令\"></a>GEORADIUS 命令</h3><ol>\n<li><code>GEORADIUS location_set longitude latitude radius unit</code>  获取指定位置为中心点，radius半径内所有的地点</li>\n<li><code>WITHDIST</code> 加上这个后缀参数，可以返回地点和地点与中心位置的直线距离</li>\n<li><code>WITHCOORD</code>  返回地点和地点坐标</li>\n<li><code>[ASD|DESC]</code> 对返回的结果排序</li>\n<li><code>[COUNT n]</code>  限制返回地点的数量</li>\n<li>可以同时指定多个可选参数</li>\n</ol>\n<h3 id=\"GEORADIUSBYMEMBER-命令\"><a href=\"#GEORADIUSBYMEMBER-命令\" class=\"headerlink\" title=\"GEORADIUSBYMEMBER 命令\"></a>GEORADIUSBYMEMBER 命令</h3><ol>\n<li><code>longitude latitude</code> 参数换成 <code>name</code>地名</li>\n</ol>\n<h3 id=\"GEOHASH-命令\"><a href=\"#GEOHASH-命令\" class=\"headerlink\" title=\"GEOHASH 命令\"></a>GEOHASH 命令</h3><ol>\n<li>获取指定位置的GEOhash值，GEOhash值是经纬度转换而来，并且可以通过GEohash来计算得到经纬度</li>\n<li>在上面的两个命令中都可以指定<code>WITHHASH</code>  来返回GEOHASH 而非 经纬度</li>\n</ol>\n<h3 id=\"GEO数据内部存储结构\"><a href=\"#GEO数据内部存储结构\" class=\"headerlink\" title=\"GEO数据内部存储结构\"></a>GEO数据内部存储结构</h3><ol>\n<li>为有序集合，因此可以使用ZSORTED来操作数据，其中score为Geohash值</li>\n</ol>\n<h2 id=\"Stream流\"><a href=\"#Stream流\" class=\"headerlink\" title=\"Stream流\"></a>Stream流</h2>"},{"title":"linux 系统信号和中断常识","date":"2020-01-23T07:12:40.000Z","_content":"### 什么是中断\n1. 中断基本概念\n> 中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。引起中断发生的事件被称为中断源。中断源向CPU发出的请求中断处理信号称为中断请求，而CPU收到中断请求后转到相应的事件处理程序称为中断响应。\n在有些情况下，尽管产生了中断源和发出了中断请求，但CPU内部的处理器状态、字PSW的中断允许位已被清除，从而不允许CPU响应中断。这种情况称为禁止中断。CPU禁止中断后只有等到PSW的中断允许位被重新设置后才能接收中断。禁止中断也称为关中断，PSW的中断允许位的设置也被称为开中断。开中断和关中断是为了保证某段程序执行的原子性。\n还有一个比较常用的概念是中断屏蔽。中断屏蔽是指在中断请求产生之后，系统有选择地封锁一部分中断而允许另一部分中断仍能得到响应。不过，有些中断请求是不能屏蔽甚至不能禁止的，也就是说，这些中断具有最高优先级，只要这些中断请求一旦提出，CPU必须立即响应。例如，电源掉电事件所引起的中断就是不可禁止和不可屏蔽的。\n\n2. 中断分类与等级\n> 根据系统对中断处理的需要，操作系统一般对中断进行分类并对不同的中断赋予不同的处理优先级，以便在不同的中断同时发生时，按轻重缓急进行处理。\n根据中断源产生的条件，可把中断分为外中断和内中断。外中断是指来自处理器和内存外部的中断，包括I／0设备发出的I／O中断、外部信号中断(例如用户键人ESC键)。各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断在狭义上一般被称为中断。\n内中断主要指在处理器和内存内部产生的中断。内中断一般称为陷阱(trap)或异常。它包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等都是陷阱的例子。\n为了按中断源的轻重缓急处理响应中断，操作系统为不同的中断赋予不同的优先级。例如在UNIX系统中，外中断和陷阱的优先级共分为8级。为了禁止中断或屏蔽中断，CPU的处理器状态字PSW中也设有相应的优先级。如果中断源的优先级高于PSW的优先级，则CPU响应该中断源的请求；反之，CPU屏蔽该中断源的中断请求。\n各中断源的优先级在系统设计时给定，在系统运行时是固定的。而处理器的优先级则根据执行情况由系统程序动态设定。\n除了在优先级的设置方面有区别之外，中断和陷阱还有如下主要区别：\n陷阱通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。\nCPU执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。例如执行指令非法时，尽管被执行的非法指令不能执行结束，但CPU仍可对其进行处理。\n\n3. 软中断\n> 软中断的概念主要来源于UNIX系统。软中断是对应于硬中断而言的。通过硬件产生相应的中断请求，称为硬中断。而软中断则不然，它是在通信进程之间通过模拟硬中断而实现的一种通信方式。中断源发出软中断信号后，CPU或者接收进程在“适当的时机”进行中断处理或者完成软中断信号所对应的功能。这里“适当的时机”，表示接收软中断信号的进程须等到该接收进程得到处理器之后才能进行。如果该接收进程是占据处理器的，那么，该接收进程在接收到软中断信号后将立即转去执行该软中断信号所对应的功能。\n\n4. 中断处理过程\n一旦CPU响应中断，转人中断处理程序，系统就开始进行中断处理。下面对中断处理过程进行详细说明：\n\n\t1. CPU检查响应中断的条件是否满足。CPU响应中断的条件是：有来自于中断源的中断请求、CPU允许中断。如果中断响应条件不满足，则中断处理无法进行。\n\n\t2. 如果CPU响应中断，则CPU关中断，使其进入不可再次响应中断的状态。\n\n\t3. 保存被中断进程现场。为了在中断处理结束后能使进程正确地返回到中断点，系统必须保存当前处理器状态字PSW和程序计数器PC等的值。这些值一般保存在特定堆栈或硬件寄存器中。\n\n\t4. 分析中断原因，调用中断处理子程序。在多个中断请求同时发生时，处理优先级最高的中断源发出的中断请求。在系统中，为了处理上的方便，通常都是针对不同的中断源编制有不同的中断处理子程序(陷阱处理子程序)。这些子程序的人口地址(或陷阱指令的人口地址)存放在内存的特定单元中。再者，不同的中断源也对应着不同的处理器状态字PSW。这些不同的PSW被放在相应的内存单元中，与中断处理子程序人口地址一起构成中断向量。显然，根据中断或陷阱的种类，系统可由中断向量表迅速地找到该中断响应的优先级、中断处理子程序(或陷阱指令)的入口地址和对应的PSW。\n\n\t5. 执行中断处理子程序。对陷阱来说，在有些系统中则是通过陷阱指令向当前执行进程发出软中断信号后调用对应的处理子程序执行。\n\n\t6. 退出中断，恢复被中断进程的现场或调度新进程占据处理器。\n\n\t7. 开中断，CPU继续执行。\n\n5. 设备管理程序与中断方式\n> 处理器的高速和输入输出设备低速之间的矛盾，是设备管理要解决的一个重要问题。为了提高整体效率，减少在程序直接控制方式中的CPU等待时间以及提高系统的并行工作效率，采用中断方式来控制输入输出设备和内存与CPU之间的数据传送，是很有必要的。在硬件结构上，这种方式要求CPU与输入输出设备(或控制器)之间有相应的中断请求线，而且在输入输出设备控制器的控制状态寄存器上有相应的中断允许位。\n\n\n### 信号\n信号驱动的异步I/O是指一旦设备准备好，就主动通知应用程序，这种情况下应用程序就不需要查询设备状态。异步 I/O 和硬件上常提的中断的概念类似，信号是在软件层次上对中断机制的一种模拟。\n\n1. 信号通信机制\n软中断信号（signal，又简称为信号）是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。\n进程之间可以互相通过系统调用kill发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。\n\n2. 处理信号\n收到信号的进程对各种信号有不同的处理方法，主要分为以下三类：\n\t- 类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。进程通过系统调用signal来指定进程对某个信号的处理行为。\n\t- 忽略某个信号，对该信号不做任何处理，就象未发生过一样。\n\t- 对该信号的处理保留系统的默认值，对大部分的信号的缺省操作是使得进程终止。\n\n需要注意的是，信号处理函数注册后，当信号来临并被触发调用信号处理函数，当同样类型信号再次到来时，并不会执行信号处理函数，而是使用信号的系统默认处理方式，大部分都是使得进程终止。\n\n\n3. 信号可靠性\n从可靠性方面信号分为可靠信号与不可靠信号；信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。\n非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。\n不可靠信号就是指发送的信号内核不一定能够发送给 目标进程，信号可能丢失。 不可靠信号在内核中存储的方式是位图和链表，当内核接收一个信号后，先判断它是否 已经存在，不存在就把他对应的位置一，并将信号挂入链表，存在则丢弃信号。 可靠信号则是把信号放入队列，再链入链表，所以也就保证了信号不丢失。\n非可靠信号一般都有确定的用途及含义,  可靠信号则可以让用户自定义使用\n需要注意的是：这里的“实时”和实时操作系统中的“实时”没有任何联系，实时信号在处理速度上并不会比普通信号快，它们之间的区别就是：普通信号会对多次的同一个信号进行“合并”处理，而实时信号会一一处理。这就要求我们在编写信号监听函数时，要捕获普通信号，必须时刻轮训监听，因为系统默认会丢弃同种类型的普通信号！\n\n4. 信号传递顺序\n如果存在多个未决信号，同一个未决信号会按照发送顺序来递送信号，不同的未决信 号按照信号的序号大小来递送，序号小的信号会先被递送到进程。另外，linux中会优 先递送不可靠信号\nLinux中的信号机制优先级是：高优先级中断->低优先级中断->软中断->信号->进程运行。\n需要注意的是，在用户态不存在未决信号。信号处理一般发生在进程从内核态返回用户态的时候。内核空间没有信号处理机制，内核态也不会处理信号否者信号拥有系统最高权限，变得不再安全\n\n5. 多线程中信号造成死锁\n如果一个线程持有锁，在操作临界区内容时，被信号中断了，转而去执行信号处理函数， 而信号处理函数再次对临界区加锁就会造成死锁。 \n解决的方法就是使用信号等待函数，线程阻塞等待信号处理函数直到处理完毕，也就是 所说的化异步为同步。\n\n6. 信号响应过程\n\t1) A进程调用信号发送函数，发送信号给B，这是软中断，所以A进程会进入内核态运行操作系统的信号调度代码\n\t2) 操作系统发现B进程正在运行，于是写入管理B进程的某个数据结构\n\t3) 操作系统返回给A，A继续执行\n\t4) B进程分配的处理器时间用完了，被时钟硬件中断\n\t5) 操作系统的时钟硬件中断处理函数准备挂起B进程，也就是把寄存器和函数堆栈保存起来，发现B进程收到了singal\n\t6) 操作系统在保存好B进程的stack和register后，新开stack(为了不干扰B进程真正的代码stack），激活B进程，B进程的信号处理函数。\n\n7. 信号生命周期（和响应过程类似）\n\t- 在目的进程中安装该信号。即设置捕获该信号时进程执行的操作，采用signal 或者 sigaction 系统调用来实现。\n\t- 信号被某个进程产生，同时设置该信号的目的进程（使用pid），之后交给操作系统进行管理。采用kill()、arise()、alarm()等系统调用来实现。\n\t- 信号在目的进程被注册。就是把信号值加入到进程的PCB（task_struct）中相关的数据结构里——未决信号的数据成员，信号携带的其他信息被保留到未决信的队列的某个sigqueue结构中。\n\t- 信号在进程中注销。在执行信号处理函数前，要把信号在进程中注销。\n\t- 信号生命的终结。进程终止当前的工作，保护上下文，执行信号处理函数，之后恢复。\n\n8. 信号阻塞集(屏蔽集、掩码)\n信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。\n所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。\n\n### 信号实现机制\n1. 发送信号\n内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。如果信号发送给一个正在睡眠的进程，那么要看该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。\n进程的 PCB 中有关于本进程中未决信号的数据成员` struct sigpending pending`：\n```\nstruct sigpending{\n\tstruct sigqueue *head, *tail;\n\tsigset_t signal;\n};\n\n```\n\n第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个sigqueue类型的结构链（称之为\"未决信号信息链\"）的首尾，信息链中的每个sigqueue结构刻画一个特定信号所携带的信息，并指向下一个sigqueue结构:\n```\nstruct sigqueue{\n\tstruct sigqueue *next;\n\tsiginfo_t info;\n}\n```\n\n信号在进程中注册指的就是信号值加入到进程的未决信号集sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该进程被信号阻塞。\n\n当一个可靠信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失。这意味着同一个可靠信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个可靠信号，都会为它分配一个结构来注册该信号信息，并把该结构添加在未决信号链尾）。\n\n当一个非可靠信号发送给一个进程时，如果该信号已经在进程中注册（通过sigset_t signal指示），则该信号将被丢弃，造成信号丢失。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构。\n\n总之信号注册与否，与发送信号的函数（如kill()或sigqueue()等）以及信号安装函数（signal()及sigaction()）无关，只与信号值有关（信号值小于SIGRTMIN的信号最多只注册一次，信号值在SIGRTMIN及SIGRTMAX之间的信号，只要被进程接收到就被注册）。\n\n2. 处理信号\n内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。\n内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当进程接收到一个它忽略的信号时，进程丢弃该信号，就像没有收到该信号似的继续运行。\n如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。**而且执行用户定义的函数的方法很巧妙，内核在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。**这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）。\n对于非可靠信号来说，由于在未决信号信息链中最多只占用一个sigqueue结构，因此该结构被释放后，应该把信号在进程未决信号集中删除（信号注销完毕）；而对于实时信号来说，可能在未决信号信息链中占用多个sigqueue结构，因此应该针对占用sigqueue结构的数目区别对待：如果只占用一个sigqueue结构（进程只收到该信号一次），则执行完相应的处理函数后应该把信号在进程的未决信号集中删除（信号注销完毕）。否则待该信号的所有sigqueue处理完毕后再在进程的未决信号集中删除该信号。\n当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。对于被屏蔽的信号，当取消屏蔽后，在返回到用户空间时会再次执行上述检查处理的一套流程。\n\n### 参考文献\n[CS_Offer/Signal.md at master · xuelangZF/CS_Offer · GitHub](https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md)\n[信号处理的时机](http://lzz5235.github.io/2015/06/04/signal.html)\n[面试中关于Linux的信号常问的问题 | 等英博客](https://www.waitig.com/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%85%B3%E4%BA%8Elinux%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98.html)\n[linux系统编程之信号（一）：中断与信号 - mickole - 博客园](http://www.cnblogs.com/mickole/p/3189156.html)\n[Linux系统编程——进程间通信：信号中断处理 - CSDN博客](https://blog.csdn.net/tennysonsky/article/details/46010303)","source":"_posts/linux 系统信号和中断常识.md","raw":"---\ntitle: linux 系统信号和中断常识\ndate: 2020-01-23 15:12:40\ntags: linux\ncategories: Linux\n---\n### 什么是中断\n1. 中断基本概念\n> 中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。引起中断发生的事件被称为中断源。中断源向CPU发出的请求中断处理信号称为中断请求，而CPU收到中断请求后转到相应的事件处理程序称为中断响应。\n在有些情况下，尽管产生了中断源和发出了中断请求，但CPU内部的处理器状态、字PSW的中断允许位已被清除，从而不允许CPU响应中断。这种情况称为禁止中断。CPU禁止中断后只有等到PSW的中断允许位被重新设置后才能接收中断。禁止中断也称为关中断，PSW的中断允许位的设置也被称为开中断。开中断和关中断是为了保证某段程序执行的原子性。\n还有一个比较常用的概念是中断屏蔽。中断屏蔽是指在中断请求产生之后，系统有选择地封锁一部分中断而允许另一部分中断仍能得到响应。不过，有些中断请求是不能屏蔽甚至不能禁止的，也就是说，这些中断具有最高优先级，只要这些中断请求一旦提出，CPU必须立即响应。例如，电源掉电事件所引起的中断就是不可禁止和不可屏蔽的。\n\n2. 中断分类与等级\n> 根据系统对中断处理的需要，操作系统一般对中断进行分类并对不同的中断赋予不同的处理优先级，以便在不同的中断同时发生时，按轻重缓急进行处理。\n根据中断源产生的条件，可把中断分为外中断和内中断。外中断是指来自处理器和内存外部的中断，包括I／0设备发出的I／O中断、外部信号中断(例如用户键人ESC键)。各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断在狭义上一般被称为中断。\n内中断主要指在处理器和内存内部产生的中断。内中断一般称为陷阱(trap)或异常。它包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等都是陷阱的例子。\n为了按中断源的轻重缓急处理响应中断，操作系统为不同的中断赋予不同的优先级。例如在UNIX系统中，外中断和陷阱的优先级共分为8级。为了禁止中断或屏蔽中断，CPU的处理器状态字PSW中也设有相应的优先级。如果中断源的优先级高于PSW的优先级，则CPU响应该中断源的请求；反之，CPU屏蔽该中断源的中断请求。\n各中断源的优先级在系统设计时给定，在系统运行时是固定的。而处理器的优先级则根据执行情况由系统程序动态设定。\n除了在优先级的设置方面有区别之外，中断和陷阱还有如下主要区别：\n陷阱通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。\nCPU执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。例如执行指令非法时，尽管被执行的非法指令不能执行结束，但CPU仍可对其进行处理。\n\n3. 软中断\n> 软中断的概念主要来源于UNIX系统。软中断是对应于硬中断而言的。通过硬件产生相应的中断请求，称为硬中断。而软中断则不然，它是在通信进程之间通过模拟硬中断而实现的一种通信方式。中断源发出软中断信号后，CPU或者接收进程在“适当的时机”进行中断处理或者完成软中断信号所对应的功能。这里“适当的时机”，表示接收软中断信号的进程须等到该接收进程得到处理器之后才能进行。如果该接收进程是占据处理器的，那么，该接收进程在接收到软中断信号后将立即转去执行该软中断信号所对应的功能。\n\n4. 中断处理过程\n一旦CPU响应中断，转人中断处理程序，系统就开始进行中断处理。下面对中断处理过程进行详细说明：\n\n\t1. CPU检查响应中断的条件是否满足。CPU响应中断的条件是：有来自于中断源的中断请求、CPU允许中断。如果中断响应条件不满足，则中断处理无法进行。\n\n\t2. 如果CPU响应中断，则CPU关中断，使其进入不可再次响应中断的状态。\n\n\t3. 保存被中断进程现场。为了在中断处理结束后能使进程正确地返回到中断点，系统必须保存当前处理器状态字PSW和程序计数器PC等的值。这些值一般保存在特定堆栈或硬件寄存器中。\n\n\t4. 分析中断原因，调用中断处理子程序。在多个中断请求同时发生时，处理优先级最高的中断源发出的中断请求。在系统中，为了处理上的方便，通常都是针对不同的中断源编制有不同的中断处理子程序(陷阱处理子程序)。这些子程序的人口地址(或陷阱指令的人口地址)存放在内存的特定单元中。再者，不同的中断源也对应着不同的处理器状态字PSW。这些不同的PSW被放在相应的内存单元中，与中断处理子程序人口地址一起构成中断向量。显然，根据中断或陷阱的种类，系统可由中断向量表迅速地找到该中断响应的优先级、中断处理子程序(或陷阱指令)的入口地址和对应的PSW。\n\n\t5. 执行中断处理子程序。对陷阱来说，在有些系统中则是通过陷阱指令向当前执行进程发出软中断信号后调用对应的处理子程序执行。\n\n\t6. 退出中断，恢复被中断进程的现场或调度新进程占据处理器。\n\n\t7. 开中断，CPU继续执行。\n\n5. 设备管理程序与中断方式\n> 处理器的高速和输入输出设备低速之间的矛盾，是设备管理要解决的一个重要问题。为了提高整体效率，减少在程序直接控制方式中的CPU等待时间以及提高系统的并行工作效率，采用中断方式来控制输入输出设备和内存与CPU之间的数据传送，是很有必要的。在硬件结构上，这种方式要求CPU与输入输出设备(或控制器)之间有相应的中断请求线，而且在输入输出设备控制器的控制状态寄存器上有相应的中断允许位。\n\n\n### 信号\n信号驱动的异步I/O是指一旦设备准备好，就主动通知应用程序，这种情况下应用程序就不需要查询设备状态。异步 I/O 和硬件上常提的中断的概念类似，信号是在软件层次上对中断机制的一种模拟。\n\n1. 信号通信机制\n软中断信号（signal，又简称为信号）是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。\n进程之间可以互相通过系统调用kill发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。\n\n2. 处理信号\n收到信号的进程对各种信号有不同的处理方法，主要分为以下三类：\n\t- 类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。进程通过系统调用signal来指定进程对某个信号的处理行为。\n\t- 忽略某个信号，对该信号不做任何处理，就象未发生过一样。\n\t- 对该信号的处理保留系统的默认值，对大部分的信号的缺省操作是使得进程终止。\n\n需要注意的是，信号处理函数注册后，当信号来临并被触发调用信号处理函数，当同样类型信号再次到来时，并不会执行信号处理函数，而是使用信号的系统默认处理方式，大部分都是使得进程终止。\n\n\n3. 信号可靠性\n从可靠性方面信号分为可靠信号与不可靠信号；信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。\n非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。\n不可靠信号就是指发送的信号内核不一定能够发送给 目标进程，信号可能丢失。 不可靠信号在内核中存储的方式是位图和链表，当内核接收一个信号后，先判断它是否 已经存在，不存在就把他对应的位置一，并将信号挂入链表，存在则丢弃信号。 可靠信号则是把信号放入队列，再链入链表，所以也就保证了信号不丢失。\n非可靠信号一般都有确定的用途及含义,  可靠信号则可以让用户自定义使用\n需要注意的是：这里的“实时”和实时操作系统中的“实时”没有任何联系，实时信号在处理速度上并不会比普通信号快，它们之间的区别就是：普通信号会对多次的同一个信号进行“合并”处理，而实时信号会一一处理。这就要求我们在编写信号监听函数时，要捕获普通信号，必须时刻轮训监听，因为系统默认会丢弃同种类型的普通信号！\n\n4. 信号传递顺序\n如果存在多个未决信号，同一个未决信号会按照发送顺序来递送信号，不同的未决信 号按照信号的序号大小来递送，序号小的信号会先被递送到进程。另外，linux中会优 先递送不可靠信号\nLinux中的信号机制优先级是：高优先级中断->低优先级中断->软中断->信号->进程运行。\n需要注意的是，在用户态不存在未决信号。信号处理一般发生在进程从内核态返回用户态的时候。内核空间没有信号处理机制，内核态也不会处理信号否者信号拥有系统最高权限，变得不再安全\n\n5. 多线程中信号造成死锁\n如果一个线程持有锁，在操作临界区内容时，被信号中断了，转而去执行信号处理函数， 而信号处理函数再次对临界区加锁就会造成死锁。 \n解决的方法就是使用信号等待函数，线程阻塞等待信号处理函数直到处理完毕，也就是 所说的化异步为同步。\n\n6. 信号响应过程\n\t1) A进程调用信号发送函数，发送信号给B，这是软中断，所以A进程会进入内核态运行操作系统的信号调度代码\n\t2) 操作系统发现B进程正在运行，于是写入管理B进程的某个数据结构\n\t3) 操作系统返回给A，A继续执行\n\t4) B进程分配的处理器时间用完了，被时钟硬件中断\n\t5) 操作系统的时钟硬件中断处理函数准备挂起B进程，也就是把寄存器和函数堆栈保存起来，发现B进程收到了singal\n\t6) 操作系统在保存好B进程的stack和register后，新开stack(为了不干扰B进程真正的代码stack），激活B进程，B进程的信号处理函数。\n\n7. 信号生命周期（和响应过程类似）\n\t- 在目的进程中安装该信号。即设置捕获该信号时进程执行的操作，采用signal 或者 sigaction 系统调用来实现。\n\t- 信号被某个进程产生，同时设置该信号的目的进程（使用pid），之后交给操作系统进行管理。采用kill()、arise()、alarm()等系统调用来实现。\n\t- 信号在目的进程被注册。就是把信号值加入到进程的PCB（task_struct）中相关的数据结构里——未决信号的数据成员，信号携带的其他信息被保留到未决信的队列的某个sigqueue结构中。\n\t- 信号在进程中注销。在执行信号处理函数前，要把信号在进程中注销。\n\t- 信号生命的终结。进程终止当前的工作，保护上下文，执行信号处理函数，之后恢复。\n\n8. 信号阻塞集(屏蔽集、掩码)\n信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。\n所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。\n\n### 信号实现机制\n1. 发送信号\n内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。如果信号发送给一个正在睡眠的进程，那么要看该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。\n进程的 PCB 中有关于本进程中未决信号的数据成员` struct sigpending pending`：\n```\nstruct sigpending{\n\tstruct sigqueue *head, *tail;\n\tsigset_t signal;\n};\n\n```\n\n第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个sigqueue类型的结构链（称之为\"未决信号信息链\"）的首尾，信息链中的每个sigqueue结构刻画一个特定信号所携带的信息，并指向下一个sigqueue结构:\n```\nstruct sigqueue{\n\tstruct sigqueue *next;\n\tsiginfo_t info;\n}\n```\n\n信号在进程中注册指的就是信号值加入到进程的未决信号集sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该进程被信号阻塞。\n\n当一个可靠信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失。这意味着同一个可靠信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个可靠信号，都会为它分配一个结构来注册该信号信息，并把该结构添加在未决信号链尾）。\n\n当一个非可靠信号发送给一个进程时，如果该信号已经在进程中注册（通过sigset_t signal指示），则该信号将被丢弃，造成信号丢失。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构。\n\n总之信号注册与否，与发送信号的函数（如kill()或sigqueue()等）以及信号安装函数（signal()及sigaction()）无关，只与信号值有关（信号值小于SIGRTMIN的信号最多只注册一次，信号值在SIGRTMIN及SIGRTMAX之间的信号，只要被进程接收到就被注册）。\n\n2. 处理信号\n内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。\n内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当进程接收到一个它忽略的信号时，进程丢弃该信号，就像没有收到该信号似的继续运行。\n如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。**而且执行用户定义的函数的方法很巧妙，内核在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。**这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）。\n对于非可靠信号来说，由于在未决信号信息链中最多只占用一个sigqueue结构，因此该结构被释放后，应该把信号在进程未决信号集中删除（信号注销完毕）；而对于实时信号来说，可能在未决信号信息链中占用多个sigqueue结构，因此应该针对占用sigqueue结构的数目区别对待：如果只占用一个sigqueue结构（进程只收到该信号一次），则执行完相应的处理函数后应该把信号在进程的未决信号集中删除（信号注销完毕）。否则待该信号的所有sigqueue处理完毕后再在进程的未决信号集中删除该信号。\n当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。对于被屏蔽的信号，当取消屏蔽后，在返回到用户空间时会再次执行上述检查处理的一套流程。\n\n### 参考文献\n[CS_Offer/Signal.md at master · xuelangZF/CS_Offer · GitHub](https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md)\n[信号处理的时机](http://lzz5235.github.io/2015/06/04/signal.html)\n[面试中关于Linux的信号常问的问题 | 等英博客](https://www.waitig.com/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%85%B3%E4%BA%8Elinux%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98.html)\n[linux系统编程之信号（一）：中断与信号 - mickole - 博客园](http://www.cnblogs.com/mickole/p/3189156.html)\n[Linux系统编程——进程间通信：信号中断处理 - CSDN博客](https://blog.csdn.net/tennysonsky/article/details/46010303)","slug":"linux 系统信号和中断常识","published":1,"updated":"2020-01-23T07:12:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clfrnbzgg001ookec3n6p76i4","content":"<h3 id=\"什么是中断\"><a href=\"#什么是中断\" class=\"headerlink\" title=\"什么是中断\"></a>什么是中断</h3><ol>\n<li><p>中断基本概念</p>\n<blockquote>\n<p>中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。引起中断发生的事件被称为中断源。中断源向CPU发出的请求中断处理信号称为中断请求，而CPU收到中断请求后转到相应的事件处理程序称为中断响应。<br>在有些情况下，尽管产生了中断源和发出了中断请求，但CPU内部的处理器状态、字PSW的中断允许位已被清除，从而不允许CPU响应中断。这种情况称为禁止中断。CPU禁止中断后只有等到PSW的中断允许位被重新设置后才能接收中断。禁止中断也称为关中断，PSW的中断允许位的设置也被称为开中断。开中断和关中断是为了保证某段程序执行的原子性。<br>还有一个比较常用的概念是中断屏蔽。中断屏蔽是指在中断请求产生之后，系统有选择地封锁一部分中断而允许另一部分中断仍能得到响应。不过，有些中断请求是不能屏蔽甚至不能禁止的，也就是说，这些中断具有最高优先级，只要这些中断请求一旦提出，CPU必须立即响应。例如，电源掉电事件所引起的中断就是不可禁止和不可屏蔽的。</p>\n</blockquote>\n</li>\n<li><p>中断分类与等级</p>\n<blockquote>\n<p>根据系统对中断处理的需要，操作系统一般对中断进行分类并对不同的中断赋予不同的处理优先级，以便在不同的中断同时发生时，按轻重缓急进行处理。<br>根据中断源产生的条件，可把中断分为外中断和内中断。外中断是指来自处理器和内存外部的中断，包括I／0设备发出的I／O中断、外部信号中断(例如用户键人ESC键)。各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断在狭义上一般被称为中断。<br>内中断主要指在处理器和内存内部产生的中断。内中断一般称为陷阱(trap)或异常。它包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等都是陷阱的例子。<br>为了按中断源的轻重缓急处理响应中断，操作系统为不同的中断赋予不同的优先级。例如在UNIX系统中，外中断和陷阱的优先级共分为8级。为了禁止中断或屏蔽中断，CPU的处理器状态字PSW中也设有相应的优先级。如果中断源的优先级高于PSW的优先级，则CPU响应该中断源的请求；反之，CPU屏蔽该中断源的中断请求。<br>各中断源的优先级在系统设计时给定，在系统运行时是固定的。而处理器的优先级则根据执行情况由系统程序动态设定。<br>除了在优先级的设置方面有区别之外，中断和陷阱还有如下主要区别：<br>陷阱通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。<br>CPU执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。例如执行指令非法时，尽管被执行的非法指令不能执行结束，但CPU仍可对其进行处理。</p>\n</blockquote>\n</li>\n<li><p>软中断</p>\n<blockquote>\n<p>软中断的概念主要来源于UNIX系统。软中断是对应于硬中断而言的。通过硬件产生相应的中断请求，称为硬中断。而软中断则不然，它是在通信进程之间通过模拟硬中断而实现的一种通信方式。中断源发出软中断信号后，CPU或者接收进程在“适当的时机”进行中断处理或者完成软中断信号所对应的功能。这里“适当的时机”，表示接收软中断信号的进程须等到该接收进程得到处理器之后才能进行。如果该接收进程是占据处理器的，那么，该接收进程在接收到软中断信号后将立即转去执行该软中断信号所对应的功能。</p>\n</blockquote>\n</li>\n<li><p>中断处理过程<br>一旦CPU响应中断，转人中断处理程序，系统就开始进行中断处理。下面对中断处理过程进行详细说明：</p>\n<ol>\n<li><p>CPU检查响应中断的条件是否满足。CPU响应中断的条件是：有来自于中断源的中断请求、CPU允许中断。如果中断响应条件不满足，则中断处理无法进行。</p>\n</li>\n<li><p>如果CPU响应中断，则CPU关中断，使其进入不可再次响应中断的状态。</p>\n</li>\n<li><p>保存被中断进程现场。为了在中断处理结束后能使进程正确地返回到中断点，系统必须保存当前处理器状态字PSW和程序计数器PC等的值。这些值一般保存在特定堆栈或硬件寄存器中。</p>\n</li>\n<li><p>分析中断原因，调用中断处理子程序。在多个中断请求同时发生时，处理优先级最高的中断源发出的中断请求。在系统中，为了处理上的方便，通常都是针对不同的中断源编制有不同的中断处理子程序(陷阱处理子程序)。这些子程序的人口地址(或陷阱指令的人口地址)存放在内存的特定单元中。再者，不同的中断源也对应着不同的处理器状态字PSW。这些不同的PSW被放在相应的内存单元中，与中断处理子程序人口地址一起构成中断向量。显然，根据中断或陷阱的种类，系统可由中断向量表迅速地找到该中断响应的优先级、中断处理子程序(或陷阱指令)的入口地址和对应的PSW。</p>\n</li>\n<li><p>执行中断处理子程序。对陷阱来说，在有些系统中则是通过陷阱指令向当前执行进程发出软中断信号后调用对应的处理子程序执行。</p>\n</li>\n<li><p>退出中断，恢复被中断进程的现场或调度新进程占据处理器。</p>\n</li>\n<li><p>开中断，CPU继续执行。</p>\n</li>\n</ol>\n</li>\n<li><p>设备管理程序与中断方式</p>\n<blockquote>\n<p>处理器的高速和输入输出设备低速之间的矛盾，是设备管理要解决的一个重要问题。为了提高整体效率，减少在程序直接控制方式中的CPU等待时间以及提高系统的并行工作效率，采用中断方式来控制输入输出设备和内存与CPU之间的数据传送，是很有必要的。在硬件结构上，这种方式要求CPU与输入输出设备(或控制器)之间有相应的中断请求线，而且在输入输出设备控制器的控制状态寄存器上有相应的中断允许位。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h3><p>信号驱动的异步I&#x2F;O是指一旦设备准备好，就主动通知应用程序，这种情况下应用程序就不需要查询设备状态。异步 I&#x2F;O 和硬件上常提的中断的概念类似，信号是在软件层次上对中断机制的一种模拟。</p>\n<ol>\n<li><p>信号通信机制<br>软中断信号（signal，又简称为信号）是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。<br>进程之间可以互相通过系统调用kill发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p>\n</li>\n<li><p>处理信号<br>收到信号的进程对各种信号有不同的处理方法，主要分为以下三类：</p>\n<ul>\n<li>类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。进程通过系统调用signal来指定进程对某个信号的处理行为。</li>\n<li>忽略某个信号，对该信号不做任何处理，就象未发生过一样。</li>\n<li>对该信号的处理保留系统的默认值，对大部分的信号的缺省操作是使得进程终止。</li>\n</ul>\n</li>\n</ol>\n<p>需要注意的是，信号处理函数注册后，当信号来临并被触发调用信号处理函数，当同样类型信号再次到来时，并不会执行信号处理函数，而是使用信号的系统默认处理方式，大部分都是使得进程终止。</p>\n<ol start=\"3\">\n<li><p>信号可靠性<br>从可靠性方面信号分为可靠信号与不可靠信号；信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。<br>非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。<br>不可靠信号就是指发送的信号内核不一定能够发送给 目标进程，信号可能丢失。 不可靠信号在内核中存储的方式是位图和链表，当内核接收一个信号后，先判断它是否 已经存在，不存在就把他对应的位置一，并将信号挂入链表，存在则丢弃信号。 可靠信号则是把信号放入队列，再链入链表，所以也就保证了信号不丢失。<br>非可靠信号一般都有确定的用途及含义,  可靠信号则可以让用户自定义使用<br>需要注意的是：这里的“实时”和实时操作系统中的“实时”没有任何联系，实时信号在处理速度上并不会比普通信号快，它们之间的区别就是：普通信号会对多次的同一个信号进行“合并”处理，而实时信号会一一处理。这就要求我们在编写信号监听函数时，要捕获普通信号，必须时刻轮训监听，因为系统默认会丢弃同种类型的普通信号！</p>\n</li>\n<li><p>信号传递顺序<br>如果存在多个未决信号，同一个未决信号会按照发送顺序来递送信号，不同的未决信 号按照信号的序号大小来递送，序号小的信号会先被递送到进程。另外，linux中会优 先递送不可靠信号<br>Linux中的信号机制优先级是：高优先级中断-&gt;低优先级中断-&gt;软中断-&gt;信号-&gt;进程运行。<br>需要注意的是，在用户态不存在未决信号。信号处理一般发生在进程从内核态返回用户态的时候。内核空间没有信号处理机制，内核态也不会处理信号否者信号拥有系统最高权限，变得不再安全</p>\n</li>\n<li><p>多线程中信号造成死锁<br>如果一个线程持有锁，在操作临界区内容时，被信号中断了，转而去执行信号处理函数， 而信号处理函数再次对临界区加锁就会造成死锁。<br>解决的方法就是使用信号等待函数，线程阻塞等待信号处理函数直到处理完毕，也就是 所说的化异步为同步。</p>\n</li>\n<li><p>信号响应过程</p>\n<ol>\n<li>A进程调用信号发送函数，发送信号给B，这是软中断，所以A进程会进入内核态运行操作系统的信号调度代码</li>\n<li>操作系统发现B进程正在运行，于是写入管理B进程的某个数据结构</li>\n<li>操作系统返回给A，A继续执行</li>\n<li>B进程分配的处理器时间用完了，被时钟硬件中断</li>\n<li>操作系统的时钟硬件中断处理函数准备挂起B进程，也就是把寄存器和函数堆栈保存起来，发现B进程收到了singal</li>\n<li>操作系统在保存好B进程的stack和register后，新开stack(为了不干扰B进程真正的代码stack），激活B进程，B进程的信号处理函数。</li>\n</ol>\n</li>\n<li><p>信号生命周期（和响应过程类似）</p>\n<ul>\n<li>在目的进程中安装该信号。即设置捕获该信号时进程执行的操作，采用signal 或者 sigaction 系统调用来实现。</li>\n<li>信号被某个进程产生，同时设置该信号的目的进程（使用pid），之后交给操作系统进行管理。采用kill()、arise()、alarm()等系统调用来实现。</li>\n<li>信号在目的进程被注册。就是把信号值加入到进程的PCB（task_struct）中相关的数据结构里——未决信号的数据成员，信号携带的其他信息被保留到未决信的队列的某个sigqueue结构中。</li>\n<li>信号在进程中注销。在执行信号处理函数前，要把信号在进程中注销。</li>\n<li>信号生命的终结。进程终止当前的工作，保护上下文，执行信号处理函数，之后恢复。</li>\n</ul>\n</li>\n<li><p>信号阻塞集(屏蔽集、掩码)<br>信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。<br>所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。</p>\n</li>\n</ol>\n<h3 id=\"信号实现机制\"><a href=\"#信号实现机制\" class=\"headerlink\" title=\"信号实现机制\"></a>信号实现机制</h3><ol>\n<li>发送信号<br>内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。如果信号发送给一个正在睡眠的进程，那么要看该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。<br>进程的 PCB 中有关于本进程中未决信号的数据成员<code> struct sigpending pending</code>：<pre><code class=\"hljs gauss\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigpending</span>&#123;\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigqueue</span> *head, *tail;\n    sigset_t signal;\n&#125;;\n</code></pre></li>\n</ol>\n<p>第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个sigqueue类型的结构链（称之为”未决信号信息链”）的首尾，信息链中的每个sigqueue结构刻画一个特定信号所携带的信息，并指向下一个sigqueue结构:</p>\n<pre><code class=\"hljs gauss\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigqueue</span>&#123;\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigqueue</span> *next;\n    siginfo_t info;\n&#125;</code></pre>\n\n<p>信号在进程中注册指的就是信号值加入到进程的未决信号集sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该进程被信号阻塞。</p>\n<p>当一个可靠信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失。这意味着同一个可靠信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个可靠信号，都会为它分配一个结构来注册该信号信息，并把该结构添加在未决信号链尾）。</p>\n<p>当一个非可靠信号发送给一个进程时，如果该信号已经在进程中注册（通过sigset_t signal指示），则该信号将被丢弃，造成信号丢失。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构。</p>\n<p>总之信号注册与否，与发送信号的函数（如kill()或sigqueue()等）以及信号安装函数（signal()及sigaction()）无关，只与信号值有关（信号值小于SIGRTMIN的信号最多只注册一次，信号值在SIGRTMIN及SIGRTMAX之间的信号，只要被进程接收到就被注册）。</p>\n<ol start=\"2\">\n<li>处理信号<br>内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。<br>内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当进程接收到一个它忽略的信号时，进程丢弃该信号，就像没有收到该信号似的继续运行。<br>如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。<strong>而且执行用户定义的函数的方法很巧妙，内核在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。</strong>这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）。<br>对于非可靠信号来说，由于在未决信号信息链中最多只占用一个sigqueue结构，因此该结构被释放后，应该把信号在进程未决信号集中删除（信号注销完毕）；而对于实时信号来说，可能在未决信号信息链中占用多个sigqueue结构，因此应该针对占用sigqueue结构的数目区别对待：如果只占用一个sigqueue结构（进程只收到该信号一次），则执行完相应的处理函数后应该把信号在进程的未决信号集中删除（信号注销完毕）。否则待该信号的所有sigqueue处理完毕后再在进程的未决信号集中删除该信号。<br>当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。对于被屏蔽的信号，当取消屏蔽后，在返回到用户空间时会再次执行上述检查处理的一套流程。</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md\">CS_Offer&#x2F;Signal.md at master · xuelangZF&#x2F;CS_Offer · GitHub</a><br><a href=\"http://lzz5235.github.io/2015/06/04/signal.html\">信号处理的时机</a><br><a href=\"https://www.waitig.com/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%85%B3%E4%BA%8Elinux%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98.html\">面试中关于Linux的信号常问的问题 | 等英博客</a><br><a href=\"http://www.cnblogs.com/mickole/p/3189156.html\">linux系统编程之信号（一）：中断与信号 - mickole - 博客园</a><br><a href=\"https://blog.csdn.net/tennysonsky/article/details/46010303\">Linux系统编程——进程间通信：信号中断处理 - CSDN博客</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"什么是中断\"><a href=\"#什么是中断\" class=\"headerlink\" title=\"什么是中断\"></a>什么是中断</h3><ol>\n<li><p>中断基本概念</p>\n<blockquote>\n<p>中断是指计算机在执行期间，系统内发生任何非寻常的或非预期的急需处理事件，使得CPU暂时中断当前正在执行的程序而转去执行相应的事件处理程序，待处理完毕后又返回原来被中断处继续执行或调度新的进程执行的过程。引起中断发生的事件被称为中断源。中断源向CPU发出的请求中断处理信号称为中断请求，而CPU收到中断请求后转到相应的事件处理程序称为中断响应。<br>在有些情况下，尽管产生了中断源和发出了中断请求，但CPU内部的处理器状态、字PSW的中断允许位已被清除，从而不允许CPU响应中断。这种情况称为禁止中断。CPU禁止中断后只有等到PSW的中断允许位被重新设置后才能接收中断。禁止中断也称为关中断，PSW的中断允许位的设置也被称为开中断。开中断和关中断是为了保证某段程序执行的原子性。<br>还有一个比较常用的概念是中断屏蔽。中断屏蔽是指在中断请求产生之后，系统有选择地封锁一部分中断而允许另一部分中断仍能得到响应。不过，有些中断请求是不能屏蔽甚至不能禁止的，也就是说，这些中断具有最高优先级，只要这些中断请求一旦提出，CPU必须立即响应。例如，电源掉电事件所引起的中断就是不可禁止和不可屏蔽的。</p>\n</blockquote>\n</li>\n<li><p>中断分类与等级</p>\n<blockquote>\n<p>根据系统对中断处理的需要，操作系统一般对中断进行分类并对不同的中断赋予不同的处理优先级，以便在不同的中断同时发生时，按轻重缓急进行处理。<br>根据中断源产生的条件，可把中断分为外中断和内中断。外中断是指来自处理器和内存外部的中断，包括I／0设备发出的I／O中断、外部信号中断(例如用户键人ESC键)。各种定时器引起的时钟中断以及调试程序中设置的断点等引起的调试中断等。外中断在狭义上一般被称为中断。<br>内中断主要指在处理器和内存内部产生的中断。内中断一般称为陷阱(trap)或异常。它包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错、算术操作溢出、数据格式非法、除数为零、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及从用户态到核心态的切换等都是陷阱的例子。<br>为了按中断源的轻重缓急处理响应中断，操作系统为不同的中断赋予不同的优先级。例如在UNIX系统中，外中断和陷阱的优先级共分为8级。为了禁止中断或屏蔽中断，CPU的处理器状态字PSW中也设有相应的优先级。如果中断源的优先级高于PSW的优先级，则CPU响应该中断源的请求；反之，CPU屏蔽该中断源的中断请求。<br>各中断源的优先级在系统设计时给定，在系统运行时是固定的。而处理器的优先级则根据执行情况由系统程序动态设定。<br>除了在优先级的设置方面有区别之外，中断和陷阱还有如下主要区别：<br>陷阱通常由处理器正在执行的现行指令引起，而中断则是由与现行指令无关的中断源引起的。陷阱处理程序提供的服务为当前进程所用，而中断处理程序提供的服务则不是为了当前进程的。<br>CPU执行完一条指令之后，下一条指令开始之前响应中断，而在一条指令执行中也可以响应陷阱。例如执行指令非法时，尽管被执行的非法指令不能执行结束，但CPU仍可对其进行处理。</p>\n</blockquote>\n</li>\n<li><p>软中断</p>\n<blockquote>\n<p>软中断的概念主要来源于UNIX系统。软中断是对应于硬中断而言的。通过硬件产生相应的中断请求，称为硬中断。而软中断则不然，它是在通信进程之间通过模拟硬中断而实现的一种通信方式。中断源发出软中断信号后，CPU或者接收进程在“适当的时机”进行中断处理或者完成软中断信号所对应的功能。这里“适当的时机”，表示接收软中断信号的进程须等到该接收进程得到处理器之后才能进行。如果该接收进程是占据处理器的，那么，该接收进程在接收到软中断信号后将立即转去执行该软中断信号所对应的功能。</p>\n</blockquote>\n</li>\n<li><p>中断处理过程<br>一旦CPU响应中断，转人中断处理程序，系统就开始进行中断处理。下面对中断处理过程进行详细说明：</p>\n<ol>\n<li><p>CPU检查响应中断的条件是否满足。CPU响应中断的条件是：有来自于中断源的中断请求、CPU允许中断。如果中断响应条件不满足，则中断处理无法进行。</p>\n</li>\n<li><p>如果CPU响应中断，则CPU关中断，使其进入不可再次响应中断的状态。</p>\n</li>\n<li><p>保存被中断进程现场。为了在中断处理结束后能使进程正确地返回到中断点，系统必须保存当前处理器状态字PSW和程序计数器PC等的值。这些值一般保存在特定堆栈或硬件寄存器中。</p>\n</li>\n<li><p>分析中断原因，调用中断处理子程序。在多个中断请求同时发生时，处理优先级最高的中断源发出的中断请求。在系统中，为了处理上的方便，通常都是针对不同的中断源编制有不同的中断处理子程序(陷阱处理子程序)。这些子程序的人口地址(或陷阱指令的人口地址)存放在内存的特定单元中。再者，不同的中断源也对应着不同的处理器状态字PSW。这些不同的PSW被放在相应的内存单元中，与中断处理子程序人口地址一起构成中断向量。显然，根据中断或陷阱的种类，系统可由中断向量表迅速地找到该中断响应的优先级、中断处理子程序(或陷阱指令)的入口地址和对应的PSW。</p>\n</li>\n<li><p>执行中断处理子程序。对陷阱来说，在有些系统中则是通过陷阱指令向当前执行进程发出软中断信号后调用对应的处理子程序执行。</p>\n</li>\n<li><p>退出中断，恢复被中断进程的现场或调度新进程占据处理器。</p>\n</li>\n<li><p>开中断，CPU继续执行。</p>\n</li>\n</ol>\n</li>\n<li><p>设备管理程序与中断方式</p>\n<blockquote>\n<p>处理器的高速和输入输出设备低速之间的矛盾，是设备管理要解决的一个重要问题。为了提高整体效率，减少在程序直接控制方式中的CPU等待时间以及提高系统的并行工作效率，采用中断方式来控制输入输出设备和内存与CPU之间的数据传送，是很有必要的。在硬件结构上，这种方式要求CPU与输入输出设备(或控制器)之间有相应的中断请求线，而且在输入输出设备控制器的控制状态寄存器上有相应的中断允许位。</p>\n</blockquote>\n</li>\n</ol>\n<h3 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h3><p>信号驱动的异步I&#x2F;O是指一旦设备准备好，就主动通知应用程序，这种情况下应用程序就不需要查询设备状态。异步 I&#x2F;O 和硬件上常提的中断的概念类似，信号是在软件层次上对中断机制的一种模拟。</p>\n<ol>\n<li><p>信号通信机制<br>软中断信号（signal，又简称为信号）是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。<br>进程之间可以互相通过系统调用kill发送软中断信号，内核也可以因为内部事件而给进程发送信号，通知进程发生了某个事件。信号机制除了基本通知功能外，还可以传递附加信息。</p>\n</li>\n<li><p>处理信号<br>收到信号的进程对各种信号有不同的处理方法，主要分为以下三类：</p>\n<ul>\n<li>类似中断的处理程序，对于需要处理的信号，进程可以指定处理函数，由该函数来处理。进程通过系统调用signal来指定进程对某个信号的处理行为。</li>\n<li>忽略某个信号，对该信号不做任何处理，就象未发生过一样。</li>\n<li>对该信号的处理保留系统的默认值，对大部分的信号的缺省操作是使得进程终止。</li>\n</ul>\n</li>\n</ol>\n<p>需要注意的是，信号处理函数注册后，当信号来临并被触发调用信号处理函数，当同样类型信号再次到来时，并不会执行信号处理函数，而是使用信号的系统默认处理方式，大部分都是使得进程终止。</p>\n<ol start=\"3\">\n<li><p>信号可靠性<br>从可靠性方面信号分为可靠信号与不可靠信号；信号的可靠与不可靠只与信号值有关，与信号的发送及安装函数无关。信号值位于 SIGRTMIN 和 SIGRTMAX 之间的信号都是可靠信号，可靠信号克服了信号可能丢失的问题。<br>非实时信号都不支持排队，都是不可靠信号；实时信号都支持排队，都是可靠信号。<br>不可靠信号就是指发送的信号内核不一定能够发送给 目标进程，信号可能丢失。 不可靠信号在内核中存储的方式是位图和链表，当内核接收一个信号后，先判断它是否 已经存在，不存在就把他对应的位置一，并将信号挂入链表，存在则丢弃信号。 可靠信号则是把信号放入队列，再链入链表，所以也就保证了信号不丢失。<br>非可靠信号一般都有确定的用途及含义,  可靠信号则可以让用户自定义使用<br>需要注意的是：这里的“实时”和实时操作系统中的“实时”没有任何联系，实时信号在处理速度上并不会比普通信号快，它们之间的区别就是：普通信号会对多次的同一个信号进行“合并”处理，而实时信号会一一处理。这就要求我们在编写信号监听函数时，要捕获普通信号，必须时刻轮训监听，因为系统默认会丢弃同种类型的普通信号！</p>\n</li>\n<li><p>信号传递顺序<br>如果存在多个未决信号，同一个未决信号会按照发送顺序来递送信号，不同的未决信 号按照信号的序号大小来递送，序号小的信号会先被递送到进程。另外，linux中会优 先递送不可靠信号<br>Linux中的信号机制优先级是：高优先级中断-&gt;低优先级中断-&gt;软中断-&gt;信号-&gt;进程运行。<br>需要注意的是，在用户态不存在未决信号。信号处理一般发生在进程从内核态返回用户态的时候。内核空间没有信号处理机制，内核态也不会处理信号否者信号拥有系统最高权限，变得不再安全</p>\n</li>\n<li><p>多线程中信号造成死锁<br>如果一个线程持有锁，在操作临界区内容时，被信号中断了，转而去执行信号处理函数， 而信号处理函数再次对临界区加锁就会造成死锁。<br>解决的方法就是使用信号等待函数，线程阻塞等待信号处理函数直到处理完毕，也就是 所说的化异步为同步。</p>\n</li>\n<li><p>信号响应过程</p>\n<ol>\n<li>A进程调用信号发送函数，发送信号给B，这是软中断，所以A进程会进入内核态运行操作系统的信号调度代码</li>\n<li>操作系统发现B进程正在运行，于是写入管理B进程的某个数据结构</li>\n<li>操作系统返回给A，A继续执行</li>\n<li>B进程分配的处理器时间用完了，被时钟硬件中断</li>\n<li>操作系统的时钟硬件中断处理函数准备挂起B进程，也就是把寄存器和函数堆栈保存起来，发现B进程收到了singal</li>\n<li>操作系统在保存好B进程的stack和register后，新开stack(为了不干扰B进程真正的代码stack），激活B进程，B进程的信号处理函数。</li>\n</ol>\n</li>\n<li><p>信号生命周期（和响应过程类似）</p>\n<ul>\n<li>在目的进程中安装该信号。即设置捕获该信号时进程执行的操作，采用signal 或者 sigaction 系统调用来实现。</li>\n<li>信号被某个进程产生，同时设置该信号的目的进程（使用pid），之后交给操作系统进行管理。采用kill()、arise()、alarm()等系统调用来实现。</li>\n<li>信号在目的进程被注册。就是把信号值加入到进程的PCB（task_struct）中相关的数据结构里——未决信号的数据成员，信号携带的其他信息被保留到未决信的队列的某个sigqueue结构中。</li>\n<li>信号在进程中注销。在执行信号处理函数前，要把信号在进程中注销。</li>\n<li>信号生命的终结。进程终止当前的工作，保护上下文，执行信号处理函数，之后恢复。</li>\n</ul>\n</li>\n<li><p>信号阻塞集(屏蔽集、掩码)<br>信号阻塞集也称信号屏蔽集、信号掩码。每个进程都有一个阻塞集，创建子进程时子进程将继承父进程的阻塞集。信号阻塞集用来描述哪些信号递送到该进程的时候被阻塞（在信号发生时记住它，直到进程准备好时再将信号通知进程）。<br>所谓阻塞并不是禁止传送信号, 而是暂缓信号的传送。若将被阻塞的信号从信号阻塞集中删除，且对应的信号在被阻塞时发生了，进程将会收到相应的信号。</p>\n</li>\n</ol>\n<h3 id=\"信号实现机制\"><a href=\"#信号实现机制\" class=\"headerlink\" title=\"信号实现机制\"></a>信号实现机制</h3><ol>\n<li>发送信号<br>内核给一个进程发送软中断信号的方法，是在进程所在的进程表项的信号域设置对应于该信号的位。如果信号发送给一个正在睡眠的进程，那么要看该进程进入睡眠的优先级，如果进程睡眠在可被中断的优先级上，则唤醒进程；否则仅设置进程表中信号域相应的位，而不唤醒进程。<br>进程的 PCB 中有关于本进程中未决信号的数据成员<code> struct sigpending pending</code>：<pre><code class=\"hljs gauss\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigpending</span>&#123;\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigqueue</span> *head, *tail;\n    sigset_t signal;\n&#125;;\n</code></pre></li>\n</ol>\n<p>第三个成员是进程中所有未决信号集，第一、第二个成员分别指向一个sigqueue类型的结构链（称之为”未决信号信息链”）的首尾，信息链中的每个sigqueue结构刻画一个特定信号所携带的信息，并指向下一个sigqueue结构:</p>\n<pre><code class=\"hljs gauss\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigqueue</span>&#123;\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-type\">sigqueue</span> *next;\n    siginfo_t info;\n&#125;</code></pre>\n\n<p>信号在进程中注册指的就是信号值加入到进程的未决信号集sigset_t signal（每个信号占用一位）中，并且信号所携带的信息被保留到未决信号信息链的某个sigqueue结构中。只要信号在进程的未决信号集中，表明进程已经知道这些信号的存在，但还没来得及处理，或者该进程被信号阻塞。</p>\n<p>当一个可靠信号发送给一个进程时，不管该信号是否已经在进程中注册，都会被再注册一次，因此，信号不会丢失。这意味着同一个可靠信号可以在同一个进程的未决信号信息链中占有多个sigqueue结构（进程每收到一个可靠信号，都会为它分配一个结构来注册该信号信息，并把该结构添加在未决信号链尾）。</p>\n<p>当一个非可靠信号发送给一个进程时，如果该信号已经在进程中注册（通过sigset_t signal指示），则该信号将被丢弃，造成信号丢失。这意味着同一个非实时信号在进程的未决信号信息链中，至多占有一个sigqueue结构。</p>\n<p>总之信号注册与否，与发送信号的函数（如kill()或sigqueue()等）以及信号安装函数（signal()及sigaction()）无关，只与信号值有关（信号值小于SIGRTMIN的信号最多只注册一次，信号值在SIGRTMIN及SIGRTMAX之间的信号，只要被进程接收到就被注册）。</p>\n<ol start=\"2\">\n<li>处理信号<br>内核处理一个进程收到的信号的时机是在一个进程从内核态返回用户态时。所以，当一个进程在内核态下运行时，软中断信号并不立即起作用，要等到将返回用户态时才处理。进程只有处理完信号才会返回用户态，进程在用户态下不会有未处理完的信号。<br>内核处理一个进程收到的软中断信号是在该进程的上下文中，因此，进程必须处于运行状态。当进程接收到一个它忽略的信号时，进程丢弃该信号，就像没有收到该信号似的继续运行。<br>如果进程收到一个要捕捉的信号，那么进程从内核态返回用户态时执行用户定义的函数。<strong>而且执行用户定义的函数的方法很巧妙，内核在用户栈上创建一个新的层，该层中将返回地址的值设置成用户定义的处理函数的地址，这样进程从内核返回弹出栈顶时就返回到用户定义的函数处，从函数返回再弹出栈顶时，才返回原先进入内核的地方。</strong>这样做的原因是用户定义的处理函数不能且不允许在内核态下执行（如果用户定义的函数在内核态下运行的话，用户就可以获得任何权限）。<br>对于非可靠信号来说，由于在未决信号信息链中最多只占用一个sigqueue结构，因此该结构被释放后，应该把信号在进程未决信号集中删除（信号注销完毕）；而对于实时信号来说，可能在未决信号信息链中占用多个sigqueue结构，因此应该针对占用sigqueue结构的数目区别对待：如果只占用一个sigqueue结构（进程只收到该信号一次），则执行完相应的处理函数后应该把信号在进程的未决信号集中删除（信号注销完毕）。否则待该信号的所有sigqueue处理完毕后再在进程的未决信号集中删除该信号。<br>当所有未被屏蔽的信号都处理完毕后，即可返回用户空间。对于被屏蔽的信号，当取消屏蔽后，在返回到用户空间时会再次执行上述检查处理的一套流程。</li>\n</ol>\n<h3 id=\"参考文献\"><a href=\"#参考文献\" class=\"headerlink\" title=\"参考文献\"></a>参考文献</h3><p><a href=\"https://github.com/xuelangZF/CS_Offer/blob/master/Linux_OS/Signal.md\">CS_Offer&#x2F;Signal.md at master · xuelangZF&#x2F;CS_Offer · GitHub</a><br><a href=\"http://lzz5235.github.io/2015/06/04/signal.html\">信号处理的时机</a><br><a href=\"https://www.waitig.com/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%85%B3%E4%BA%8Elinux%E7%9A%84%E4%BF%A1%E5%8F%B7%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98.html\">面试中关于Linux的信号常问的问题 | 等英博客</a><br><a href=\"http://www.cnblogs.com/mickole/p/3189156.html\">linux系统编程之信号（一）：中断与信号 - mickole - 博客园</a><br><a href=\"https://blog.csdn.net/tennysonsky/article/details/46010303\">Linux系统编程——进程间通信：信号中断处理 - CSDN博客</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clfrnbzfp0001okec4v6ueh1f","category_id":"clfrnbzft0004okecf6evg6g8","_id":"clfrnbzg1000hokecc4i5btzu"},{"post_id":"clfrnbzfs0003okecgrdagmsz","category_id":"clfrnbzfy000cokec7ju4ack4","_id":"clfrnbzg4000ookechr3qg05q"},{"post_id":"clfrnbzg2000lokecffzxggh4","category_id":"clfrnbzg1000iokecfbwnfxs3","_id":"clfrnbzg6000uokec6bq4fwbr"},{"post_id":"clfrnbzfv0007okechnoz37jh","category_id":"clfrnbzg1000iokecfbwnfxs3","_id":"clfrnbzg7000yokec753q7mg4"},{"post_id":"clfrnbzfw0009okec12yk5nsq","category_id":"clfrnbzg4000qokec50k23gla","_id":"clfrnbzg90012okec0icn2oz3"},{"post_id":"clfrnbzfx000bokec66zw8fs3","category_id":"clfrnbzg1000iokecfbwnfxs3","_id":"clfrnbzg90014okech0uhd4kp"},{"post_id":"clfrnbzfz000fokec584d2ap0","category_id":"clfrnbzg80011okecdhzm13al","_id":"clfrnbzga0019okec7mqreiu4"},{"post_id":"clfrnbzg0000gokecg3e85j7j","category_id":"clfrnbzg1000iokecfbwnfxs3","_id":"clfrnbzga001cokecc4a56mq2"},{"post_id":"clfrnbzg3000nokecboy52m0y","category_id":"clfrnbzga0018okecdy9m1v95","_id":"clfrnbzgb001gokec1g8d0n6e"},{"post_id":"clfrnbzg5000tokece4l989y0","category_id":"clfrnbzga001dokec506d8tbu","_id":"clfrnbzgc001jokec77c82mpq"},{"post_id":"clfrnbzgg001ookec3n6p76i4","category_id":"clfrnbzga001dokec506d8tbu","_id":"clfrnbzgi001sokec18am8cqd"},{"post_id":"clfrnbzge001nokec9nv46k0p","category_id":"clfrnbzgh001pokecf82f0wsz","_id":"clfrnbzgi001uokecba7w0aym"}],"PostTag":[{"post_id":"clfrnbzfp0001okec4v6ueh1f","tag_id":"clfrnbzfu0005okechyjmg56c","_id":"clfrnbzfz000eokec0l2b7sei"},{"post_id":"clfrnbzfz000fokec584d2ap0","tag_id":"clfrnbzfy000dokec7il09d8q","_id":"clfrnbzg2000kokec0uc48s9h"},{"post_id":"clfrnbzfs0003okecgrdagmsz","tag_id":"clfrnbzfy000dokec7il09d8q","_id":"clfrnbzg3000mokec8cmthnld"},{"post_id":"clfrnbzfv0007okechnoz37jh","tag_id":"clfrnbzfy000dokec7il09d8q","_id":"clfrnbzg5000sokechm9u4lx0"},{"post_id":"clfrnbzfw0009okec12yk5nsq","tag_id":"clfrnbzg4000pokecddrhel6k","_id":"clfrnbzg7000zokec2zdmga5d"},{"post_id":"clfrnbzfx000bokec66zw8fs3","tag_id":"clfrnbzfy000dokec7il09d8q","_id":"clfrnbzg90013okech4nt009l"},{"post_id":"clfrnbzg0000gokecg3e85j7j","tag_id":"clfrnbzg80010okec60cx1pcr","_id":"clfrnbzga0017okecc8045o6n"},{"post_id":"clfrnbzg2000lokecffzxggh4","tag_id":"clfrnbzg90015okec5jgp03mx","_id":"clfrnbzga001bokec542r1asb"},{"post_id":"clfrnbzg3000nokecboy52m0y","tag_id":"clfrnbzga001aokeceh8e13ry","_id":"clfrnbzgb001fokececxa014j"},{"post_id":"clfrnbzg5000rokec2foig6t6","tag_id":"clfrnbzgb001eokec5bts36m9","_id":"clfrnbzgb001iokec9mwc24y7"},{"post_id":"clfrnbzg5000tokece4l989y0","tag_id":"clfrnbzgb001hokeccxascgi7","_id":"clfrnbzgc001lokecdhic6kfp"},{"post_id":"clfrnbzg6000xokec92o05anm","tag_id":"clfrnbzgc001kokech4e90apb","_id":"clfrnbzgc001mokecac135mhj"},{"post_id":"clfrnbzgg001ookec3n6p76i4","tag_id":"clfrnbzfy000dokec7il09d8q","_id":"clfrnbzgi001rokec5ccyaqgn"},{"post_id":"clfrnbzge001nokec9nv46k0p","tag_id":"clfrnbzgh001qokec738le4ip","_id":"clfrnbzgi001tokecacmf0i1c"}],"Tag":[{"name":"flag","_id":"clfrnbzfu0005okechyjmg56c"},{"name":"linux","_id":"clfrnbzfy000dokec7il09d8q"},{"name":"网络","_id":"clfrnbzg4000pokecddrhel6k"},{"name":"uuid","_id":"clfrnbzg80010okec60cx1pcr"},{"name":"ringbuff","_id":"clfrnbzg90015okec5jgp03mx"},{"name":"rank","_id":"clfrnbzga001aokeceh8e13ry"},{"name":"git","_id":"clfrnbzgb001eokec5bts36m9"},{"name":"timer","_id":"clfrnbzgb001hokeccxascgi7"},{"name":"面试","_id":"clfrnbzgc001kokech4e90apb"},{"name":"Redis","_id":"clfrnbzgh001qokec738le4ip"}]}}